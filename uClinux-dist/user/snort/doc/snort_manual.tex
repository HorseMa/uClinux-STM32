% $Id$
% 
% BUILDING HTML VERSION:
% latex2html -info 0 -local_icons -show_section_numbers -link +2 -split +2 -noaddress snort_manual.tex
%
% BUILDING PDF VERSION:
% pdflatex snort_manual.tex

\documentclass[english]{report}
%\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\usepackage{longtable}
\geometry{verbose,letterpaper,tmargin=1in,bmargin=.5in,lmargin=1in,rmargin=1in}
\IfFileExists{url.sty}{\usepackage{url}}
                      {\newcommand{\url}{\texttt}}

\usepackage{html}

% \makeatletter

\newcounter{slistnum}
\newcounter{subslistnum}
\newcounter{subsublistnum}

\newenvironment{slist}
{ \begin{list}{ {\bf \arabic{slistnum}.} }{\usecounter{slistnum} } }
{ \end{list} }

\newenvironment{subslist}
{ \begin{list} { {\bf \arabic{slistnum}-\Alph{subslistnum}. } }
        {\usecounter{subslistnum} }   }
{ \end{list} }

\newenvironment{subsubslist} {
    \begin{list}{
        {\bf \arabic{slistnum}-\arabic{subslistnum}-\arabic{subsublistnum}. }
    }{
        \usecounter{subsubslistnum}
    }
}{
    \end{list}
}

%\begin{latexonly}
\newsavebox{\savepar}
\newenvironment{note}{
\samepage
    \vspace{10pt}{\textsf{
        {\hspace{7pt}\Huge{$\triangle$\hspace{-12.5pt}{\Large{$^!$}}}}\hspace{5pt}
        {\Large{NOTE}}
    }
    }
   \begin{center}
    \par\vspace{-17pt}

    \begin{lrbox}{\savepar}
    \begin{minipage}[r]{6in}
}
{
    \end{minipage}
    \end{lrbox}
    \fbox{
        \usebox{
            \savepar
	}
    }
    \par\vskip10pt
    \end{center}
}
%\end{latexonly}

\begin{htmlonly}
\newenvironment{note}{
        \begin{rawhtml}
        <p><table border="1"><tr><td><b>
        Note:&nbsp;&nbsp;</b>
        \end{rawhtml}
}{
        \begin{rawhtml}
        </b></td></tr></table></p>
        \end{rawhtml}
}
\end{htmlonly}

\usepackage{babel}

% \makeatother

\addtolength{\parindent}{-5mm}
\addtolength{\parskip}{2mm}

%\renewcommand\floatpagefraction{.9}
%\renewcommand\topfraction{.9}
%\renewcommand\bottomfraction{.9}
%\renewcommand\textfraction{.1}   
%\setcounter{totalnumber}{50}
%\setcounter{topnumber}{50}
%\setcounter{bottomnumber}{50}

\begin{document}

\title{Snort\texttrademark  Users Manual\\  2.6.1.5 }

\author{The Snort Project}

\maketitle

\newpage

Copyright \copyright 1998-2003 Martin Roesch

Copyright \copyright 2001-2003 Chris Green

Copyright \copyright 2003-2006 Sourcefire, Inc.

\tableofcontents{}


\chapter{Snort Overview}

This manual is based on \emph{Writing Snort Rules} by Martin Roesch and further
work from Chris Green $<$cmg@snort.org$>$.  It is now maintained by Brian
Caswell $<$bmc@snort.org$>$.  If you have a better way to say something or find
that something in the documentation is outdated, drop us a line and we will
update it.  If you would like to submit patches for this document, you can find
the latest version of the documentation in \LaTeX\ format in the Snort CVS
repository at \verb!/doc/snort_manual.tex!.  Small documentation updates are
the easiest way to help out the Snort Project.

\section{Getting Started}

Snort really isn't very hard to use, but there are a lot of command line
options to play with, and it's not always obvious which ones go together well.
This file aims to make using Snort easier for new users.

Before we proceed, there are a few basic concepts you should understand about
Snort. Snort can be configured to run in three modes:
\begin{itemize}
\item {\em Sniffer mode,} which simply reads the packets off of the network and displays them 
for you in a continuous stream on the console (screen). 
\item {\em Packet Logger mode,} which logs the packets to disk. 
\item {\em Network Intrusion Detection System (NIDS) mode,} the most complex and configurable configuration,
which allows Snort to analyze network traffic for matches against a user-defined
rule set and performs several actions based upon what it sees.
\item {\em Inline mode,} which obtains packets from iptables instead of from libpcap and then
causes iptables to drop or pass packets based on Snort rules that use inline-specific rule types.
\end{itemize}

\section{Sniffer Mode}

First, let's start with the basics. If you just want to print out
the TCP/IP packet headers to the screen (i.e. sniffer mode), try this:

\begin{verbatim}
./snort -v
\end{verbatim}
This command will run Snort and just show the IP and TCP/UDP/ICMP
headers, nothing else. If you want to see the application data in
transit, try the following:

\begin{verbatim}
./snort -vd
\end{verbatim}
This instructs Snort to display the packet data as well as the headers.
If you want an even more descriptive display, showing the data link
layer headers, do this:

\begin{verbatim}
./snort -vde
\end{verbatim}
(As an aside, these switches may be divided up or smashed together
in any combination. The last command could also be typed out as:

\begin{verbatim}
./snort -d -v -e
\end{verbatim}
and it would do the same thing.)


\section{Packet Logger Mode}

OK, all of these commands are pretty cool, but if you want to record
the packets to the disk, you need to specify a logging directory and
Snort will automatically know to go into packet logger mode:

\begin{verbatim}
./snort -dev -l ./log
\end{verbatim}
Of course, this assumes you have a directory named \verb!log!
in the current directory. If you don't, Snort will exit with an error
message. When Snort runs in this mode, it collects every packet it
sees and places it in a directory hierarchy based upon the IP address
of one of the hosts in the datagram.

If you just specify a plain -l switch, you may
notice that Snort sometimes uses the address of the remote computer
as the directory in which it places packets and sometimes it uses
the local host address. In order to log relative to the home network,
you need to tell Snort which network is the home network:

\begin{verbatim}
./snort -dev -l ./log -h 192.168.1.0/24
\end{verbatim}
This rule tells Snort that you want to print out the data link and
TCP/IP headers as well as application data into the directory \verb!./log!,
and you want to log the packets relative to the 192.168.1.0 class
C network. All incoming packets will be recorded into subdirectories
of the log directory, with the directory names being based on the
address of the remote (non-192.168.1) host. 

\begin{note}
Note that if both the source and destination hosts are on the home 
network, they are logged to a directory with a name based on the higher 
of the two port numbers or, in the case of a tie, the source address.
\end{note}

If you're on a high speed network or you want to log the packets into
a more compact form for later analysis, you should consider logging
in binary mode. Binary mode logs the packets in
tcpdump format to a single binary file in the
logging directory:

\begin{verbatim}
./snort -l ./log -b
\end{verbatim}
Note the command line changes here. We don't need to specify a home
network any longer because binary mode logs everything into a single
file, which eliminates the need to tell it how to format the output
directory structure. Additionally, you don't need to run in verbose
mode or specify the -d or -e switches because in binary mode the entire
packet is logged, not just sections of it. All you really need to do
to place Snort into logger mode is to specify a logging
directory at the command line using the -l switch---the -b binary logging
switch merely provides a modifier that tells Snort to log the packets in
something other than the default output format of plain ASCII text.

Once the packets have been logged to the binary file, you can read
the packets back out of the file with any sniffer that supports the
tcpdump binary format (such as tcpdump or Ethereal). Snort can also
read the packets back by using the -r switch, which puts it into playback
mode. Packets from any tcpdump formatted file can be processed through
Snort in any of its run modes. For example, if you wanted to run a
binary log file through Snort in sniffer mode to dump the packets
to the screen, you can try something like this:

\begin{verbatim}
./snort -dv -r packet.log
\end{verbatim}
You can manipulate the data in the file in a number of ways through
Snort's packet logging and intrusion detection modes, as well as with
the BPF interface that's available from the command line. For example,
if you only wanted to see the ICMP packets from the log file, simply
specify a BPF filter at the command line and Snort will only see
the ICMP packets in the file:

\begin{verbatim}
./snort -dvr packet.log icmp 
\end{verbatim}
For more info on how to use the BPF interface, read the Snort and
tcpdump man pages.

\section{Network Intrusion Detection System Mode}

To enable Network Intrusion Detection System (NIDS) mode so that you don't
record every single packet sent down the wire, try this:

\begin{verbatim}
./snort -dev -l ./log -h 192.168.1.0/24 -c snort.conf
\end{verbatim}
where \texttt{snort.conf} is the name of your rules file. This will apply the
rules configured in the \verb!snort.conf! file to each packet to decide if an action
based upon the rule type in the file should be taken. If you don't
specify an output directory for the program, it will default to \verb!/var/log/snort!.

One thing to note about the last command line is that if Snort is
going to be used in a long term way as an IDS, the -v
switch should be left off the command line for the sake of speed.
The screen is a slow place to write data to, and packets can be dropped
while writing to the display.

It's also not necessary to record the data link headers for most applications,
so you can usually omit the -e switch, too.

\begin{verbatim}
./snort -d -h 192.168.1.0/24 -l ./log -c snort.conf
\end{verbatim}
This will configure Snort to run in its most basic NIDS form, logging
packets that trigger rules specified in the \texttt{snort.conf} in plain ASCII 
to disk using a hierarchical directory structure (just like packet logger mode). 


\subsection{NIDS Mode Output Options}

There are a number of ways to configure the output of Snort in NIDS
mode. The default logging and alerting mechanisms are to log in decoded
ASCII format and use full alerts. The full alert
mechanism prints out the alert message in addition to the full packet
headers. There are several other alert output modes available at the
command line, as well as two logging facilities.

Alert modes are somewhat more complex. There are seven alert modes available
at the command line: full, fast, socket, syslog, console, cmg, and
none. Six of these modes are accessed with the -A command line switch.
These options are:

\begin{tabular}{| l | p{5.4in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
{\tt -A fast} & Fast alert mode. Writes the alert in a simple format with a timestamp, alert message, source
and destination IPs/ports.\\
\hline
{\tt -A full} & Full alert mode. This is the default alert mode and will be used automatically if you do not specify a mode.\\
\hline
{\tt -A unsock} & Sends alerts to a UNIX socket that another program can listen on.\\
\hline
{\tt -A none} & Turns off alerting.\\
\hline
{\tt -A console} & Sends ``fast-style'' alerts to the console (screen).\\
\hline
{\tt -A cmg} & Generates ``cmg style'' alerts.\\
\hline
\end{tabular}

Packets can be logged to their default decoded ASCII format or to
a binary log file via the -b command line switch. To disable
packet logging altogether, use the -N command line switch.

For output modes available through the configuration file, see Section
\ref{output config}.

\begin{note}
Command line logging options override any output options specified 
in the configuration file. This allows debugging of configuration 
issues quickly via the command line.
\end{note}

To send alerts to syslog, use the -s switch. The default facilities
for the syslog alerting mechanism are LOG\_AUTHPRIV and LOG\_ALERT.
If you want to configure other facilities for syslog output, use the
output plugin directives in the rules files. See Section \ref{alert syslog lable}
for more details on configuring syslog output.

For example, use the following command line to log to default (decoded ASCII) facility and send alerts to syslog: 

\begin{verbatim}
./snort -c snort.conf -l ./log -h 192.168.1.0/24 -s
\end{verbatim}

As another example, use the following command line to log to the default facility in /var/log/snort and send alerts to a
fast alert file: 

\begin{verbatim}
./snort -c snort.conf -A fast -h 192.168.1.0/24
\end{verbatim}

\subsection{Understanding Standard Alert Output}

When Snort generates an alert message, it will usually look like the following:
 
 \begin{verbatim}	 
  [**] [116:56:1] (snort_decoder): T/TCP Detected [**]
 \end{verbatim}
  	 
  The first number is the Generator ID, this tells the user what
  component of Snort generated this alert. For a list of GIDs, please read
  etc/generators in the Snort source. In this case, we know that this event
  came from the ``decode'' (116) component of Snort.
  	 
  The second number is the Snort ID (sometimes referred to as
  Signature ID). For a list of preprocessor SIDs, please see
  etc/gen-msg.map.  Rule-based SIDs are written directly into the rules
  with the \emph{sid} option. In this case, \emph{56} represents a T/TCP event.
  	 
  The third number is the revision ID. This number is primarily
  used when writing signatures, as each rendition of the rule should
  increment this number with the \emph{rev} option.



\subsection{High Performance Configuration}

If you want Snort to go \emph{fast} (like keep up with a 1000 Mbps connection),
you need to use unified logging and a unified log reader such as
\emph{barnyard}.  This allows Snort to log alerts in a binary form as fast as
possible while another program performs the slow actions, such as writing to a
database.

If you want a text file that's easily parsable, but still somewhat fast, try
using binary logging with the ``fast'' output mechanism. 

This will log packets in tcpdump format and produce minimal alerts. For
example:

\begin{center}
\begin{verbatim}
./snort -b -A fast -c snort.conf
\end{verbatim}
\end{center}

\subsection{Changing Alert Order}

The default way in which Snort applies its rules to packets may not be
appropriate for all installations.  The Alert rules are applied first, then the
Pass rules, and finally, Log rules are applied. This sequence is somewhat
counterintuitive, but it's a more foolproof method than allowing a user to
write a hundred alert rules that are then disabled by an errant pass rule.  For
more information on rule types, see Section \ref{rules action section}.

If you know what you're doing, you can use the -o switch to change the default
rule application behavior to apply Pass rules, then Alert rules, then Log
rules:
\begin{center}
\begin{verbatim}
./snort -d -h 192.168.1.0/24 -l ./log -c snort.conf -o
\end{verbatim}
\end{center}

As of Snort 2.6.0, the command line flags \texttt{--alert-before-pass}
and \texttt{--treat-drop-as-alert} were added to handle changes to rule
ordering and fix an issue when pass and drop rules were not always
enforced.  The \texttt{--alert-before-pass} option forces alert rules
to take affect in favor of a pass rule.  The \texttt{--treat-drop-as-alert}
causes drop, sdrop, and reject rules and any associated alerts to be logged
as alerts, rather then the normal action.  This allows use of an inline
policy with passive/IDS mode.

Additionally, the \texttt{--process-all-events} option causes Snort to
process every event associated with a packet, while taking the actions
based on the rules ordering.  Without this option (default case), only
the events for the first action based on rules ordering are processed.

\begin{note}
Pass rules are special cases here, in that the event processing is
terminated when a pass rule is encountered, regardless of the use of
\texttt{--process-all-events}.
\end{note}

\begin{note}
The additions with Snort 2.6.0 will result in the deprecation of the
-o switch in a future release.
\end{note}

\section{Inline Mode\label{Snort Inline}}

Snort 2.3.0 RC1 integrated the intrusion prevention system (IPS) capability of
\texttt{Snort Inline} into the official Snort project. \texttt{Snort Inline} obtains packets
from iptables instead of libpcap and then uses new rule types to help iptables
pass or drop packets based on Snort rules.  

In order for \texttt{Snort Inline} to work properly, you must download and compile the
iptables code to include ``make install-devel''
(\url{http://www.iptables.org}).  This will install the \texttt{libipq} library
that allows \texttt{Snort Inline} to interface with iptables.  Also, you must build and
install LibNet, which is available from \url{http://www.packetfactory.net}.

There are three rule types you can use when running Snort with \texttt{Snort Inline}:

\begin{itemize}
\item \textbf{drop} - The drop rule type will tell iptables to drop the packet and log it 
       via usual Snort means.
\item \textbf{reject} - The reject rule type will tell iptables to drop the packet, log it 
         via usual Snort means, and send a TCP reset if the protocol is 
         TCP or an icmp port unreachable if the protocol is UDP.
\item \textbf{sdrop} - The sdrop rule type will tell iptables to drop the packet.  Nothing
        is logged.
\end{itemize}

\begin{note}
You can also replace sections of the packet payload when using \texttt{Snort Inline}.
See Section \ref{ReplaceInline} for more information.
\end{note}

When using a \texttt{reject} rule, there are two options you can use to send
TCP resets:
\begin{itemize}

\item You can use a RAW socket (the default behavior for \texttt{Snort Inline}), in which case you must have an interface that has an IP address assigned to it. If there is not an interface with an IP address assigned with access to the source of the packet, the packet will be logged and the reset packet will never make it onto the network.

\item You can also now perform resets via a physical device when using iptables.  We take the indev name from ip\_queue and use this as the interface on which to send resets. We no longer need an IP loaded on the bridge, and can remain pretty stealthy as the \texttt{config layer2\_resets} in snort\_inline.conf takes a source MAC address which we substitue for the MAC of the bridge. For example:
\begin{verbatim}
config layer2resets
\end{verbatim}
tells \texttt{Snort Inline} to use layer2 resets and uses the MAC address of the bridge as the source MAC in the packet, and:
\begin{verbatim}
config layer2resets: 00:06:76:DD:5F:E3  
\end{verbatim}
will tell Snort Inline to use layer2 resets and uses the source MAC of 
00:06:76:DD:5F:E3 in the reset packet.

\item The command-line option \texttt{--disable-inline-initialization} can be
used to not initialize IPTables when in inline mode.  To be used with
command-line option \texttt{-T} to test for a valid configuration without
requiring opening inline devices and adversely affecting traffic flow.

\end{itemize}

\subsection{Snort Inline Rule Application Order\label{InlineRuleOrder}}

The current rule application order is: 
\begin{verbatim}
	->activation->dynamic->drop->sdrop->reject->alert->pass->log
\end{verbatim}
This will ensure that a drop rule has precedence over an alert or log rule.
You can use the -o flag to change the rule application order to:
\begin{verbatim}
	->activation->dynamic->pass->drop->sdrop->reject->alert->log
\end{verbatim}

\subsection{New STREAM4 Options for Use with Snort Inline\label{Stream4Inline}}

When using \texttt{Snort Inline}, you can use two additional stream4 options:

\begin{itemize}
\item \texttt{enforce\_state drop}
   
   Adding \texttt{drop} to the \texttt{enforce\_state} option causes Snort to
    drop TCP packets that are not associated with an existing TCP session, and
    that are not valid TCP initiators.

\item \texttt{midstream\_drop\_alerts} (no arguments)
   
   By default, when running in inline mode, Snort will silently drop any
    packets that are matched against a \texttt{drop} rule and considered
    to be part of a midstream session, instead of logging the alert as usual.
    This is to mitigate stick/snot type attacks when the user
    hasn't enabled the \texttt{enforce\_state} option.  If you want to log
    these drops, enable this option. Note
    that by enabling this option, you have opened yourself up to
    stick/snot-type attacks if you haven't also used the
    \texttt{enforce\_state} option.

\item \texttt{disable\_session\_blocking} (no arguments)

   By default, when running in inline mode, Snort will block all traffic
    on a TCP session after it is told to drop a non-stateless packet on
    that session. Enable this option if you don't want Snort to exhibit
    this default behavior.

\end{itemize}

For more information about Stream4, see Section \ref{stream 4 section}.

\subsection{Replacing Packets with Snort Inline\label{ReplaceInline}}

Additionally, Jed Haile's content replace code allows you to modify packets
before they leave the network.  For example:

\begin{verbatim}
alert tcp any any <> any 80 (msg: "tcp replace"; content:"GET"; replace:"BET";)
alert udp any any <> any 53 (msg: "udp replace"; \
    content: "yahoo"; replace: "xxxxx";)
\end{verbatim}

These rules will comb TCP port 80 traffic looking for GET, and UDP port 53
traffic looking for yahoo.  Once they are found, they are replaced with BET and
xxxxx, respectively.  The only catch is that the replace must be the same
length as the content.


\subsection{Installing Snort Inline\label{InlineInstall}}
To install Snort inline, use the following command:
\begin{verbatim}
./configure --enable-inline
make
make install
\end{verbatim} 


\subsection{Running Snort Inline}

First, you need to ensure that the ip\_queue module is loaded.  Then,
you need to send traffic to Snort Inline using the QUEUE target.  For
example:
\begin{verbatim}
iptables -A OUTPUT -p tcp --dport 80 -j QUEUE
\end{verbatim}
sends all TCP traffic leaving the firewall going to port 80 to the QUEUE
target.  This is what sends the packet from kernel space to user space 
(\texttt{Snort Inline}).  A quick way to get all outbound traffic going to the
QUEUE is to use the rc.firewall script created and maintained by the 
Honeynet Project (\url{http://www.honeynet.org/papers/honeynet/tools/})
This script is well-documented and allows you to direct packets
to \texttt{Snort Inline} by simply changing the QUEUE variable to yes.

Finally, start Snort Inline:

\begin{verbatim}
snort_inline -QDc ../etc/drop.conf -l /var/log/snort
\end{verbatim}

You can use the following command line options:
\begin{itemize}
\item \texttt{-Q} - Gets packets from iptables.
\item \texttt{-D} - Runs \texttt{Snort Inline} in daemon mode.  The process ID is stored
                    at \texttt{/var/run/snort\_inline.pid}
\item \texttt{-c} - Reads the following configuration file.
\item \texttt{-l} - Logs to the following directory.

\end{itemize}

Ideally, Snort Inline will be run using only its own drop.rules.  If
you want to use Snort for just alerting, a separate process should be
running with its own rule set.

\subsection{Using the Honeynet Snort Inline Toolkit}

The Honeynet Snort Inline Toolkit is a statically compiled \texttt{Snort Inline} 
binary put together by the
Honeynet Project for the Linux operating system.  It comes with a set
of drop.rules, the \texttt{Snort Inline} binary, a snort-inline rotation shell
script, and a good README.  It can be found at:

\url{http://www.honeynet.org/papers/honeynet/tools/}

\subsection{Troubleshooting Snort Inline}

If you run Snort Inline and see something like this:
\begin{verbatim}
Initializing Output Plugins!
Reading from iptables
Log directory = /var/log/snort
Initializing Inline mode
InlineInit: : Failed to send netlink message: Connection refused
\end{verbatim}
More than likely, the ip\_queue module is not loaded or ip\_queue 
support is not compiled into your kernel.  Either recompile
your kernel to support ip\_queue, or load the module.

The ip\_queue module is loaded by executing:
\begin{verbatim}
insmod ip_queue
\end{verbatim}
Also, if you want to ensure Snort Inline is getting packets, you can 
start it in the following manner:
\begin{verbatim}
snort_inline -Qvc <configuration file>
\end{verbatim}
This will display the header of every packet that Snort Inline sees. 

\section{Miscellaneous}

\subsection{Running in Daemon Mode}

If you want to run Snort in daemon mode, you can the add -D switch to any
combination described in the previous sections. Please notice that if you want to be able to restart Snort
by sending a SIGHUP signal to the daemon, you {\em must} specify the full path to the Snort
binary when you start it, for example:

\begin{center}
\begin{verbatim}
/usr/local/bin/snort -d -h 192.168.1.0/24 \
    -l /var/log/snortlogs -c /usr/local/etc/snort.conf -s -D
\end{verbatim}
\end{center}

Relative paths are not supported due to security concerns.

\subsubsection{Snort PID File}

When Snort is run in daemon mode, the daemon creates a PID file in
the log directory.  In Snort 2.6, the \texttt{--pid-path} command line
switch causes Snort to write the PID file in the directory specified.

Additionally, the \texttt{--create-pidfile} switch can be used to
force creation of a PID file even when not running in daemon mode.

The PID file will be locked so that other snort processes cannot
start.  Use the \texttt{--nolock-pidfile} switch to not lock the
PID file.

\subsection{Obfuscating IP Address Printouts}

If you need to post packet logs to public mailing lists, you might
want to use the -O switch. This switch obfuscates your IP addresses in
packet printouts. This is handy if you don't want people on the mailing
list to know the IP addresses involved. You can also combine the -O switch with
the -h switch to only obfuscate the IP addresses of hosts on the home network.
This is useful if you don't care who sees the address of the attacking host.
For example, you could use the following command to read the packets from a log 
file and dump them to the screen, obfuscating only the addresses from the 
192.168.1.0/24 class C network:
 
\begin{center}
\begin{verbatim}
./snort -d -v -r snort.log -O -h 192.168.1.0/24
\end{verbatim}
\end{center}

\subsection{Specifying Multiple-Instance Identifiers}

In Snort v2.4, the \texttt{-G} command line option was added that specifies
an instance identifier for the event logs.  This option can be used when
running multiple instances of snort, either on different CPUs, or on the same
CPU but a different interface.  Each Snort instance will use the value
specified to generate unique event IDs.  Users can specify either a
decimal value (\texttt{-G 1}) or hex value preceded by 0x (\texttt{-G 0x11}).
This is also supported via a long option \texttt{--logid}.

\section{More Information}

Chapter \ref{Configuring Snort} contains much information about many
configuration options available in the configuration file.  The Snort manual
page and the output of \texttt{snort -?} or \texttt{snort --help} contain
information that can help you get Snort running in several different modes.

\begin{note}
In many shells, a backslash (\textbackslash{}) is needed to escape the ?, so you may have to type 
\texttt{snort -\textbackslash{}?} instead of \texttt{snort -?} for a list of Snort command line options.
\end{note}

The Snort web page (\url{http://www.snort.org}) and the Snort Users mailing
list (\url{http://marc.theaimsgroup.com/?l=snort-users} at
\verb?snort-users@lists.sourceforge.net? provide informative announcements as
well as a venue for community discussion and support. There's a lot to Snort, so
sit back with a beverage of your choosing and read the documentation and
mailing list archives.

\newpage
\chapter{Configuring Snort \label{Configuring Snort}}

\subsection{Includes}

The {\tt include} keyword allows other rules files to be included within the rules
file indicated on the Snort command line. It works much like an \#include from
the C programming language, reading the contents of the named file and adding the contents
in the place where the include statement appears in the file.

\subsubsection{Format}
\begin{verbatim}
include <include file path/name>
\end{verbatim}

\begin{note}
Note that there is no semicolon at the end of this line. 
\end{note}

Included files will
substitute any predefined variable values into their own variable references.
See Section \ref{variables} for more information on defining and
using variables in Snort rules files.

\subsection{Variables \label{variables}}

Variables may be defined in Snort. These are simple substitution variables
set with the {\tt var} keyword as shown in Figure \ref{variable definition}.

\subsubsection{Format}

\begin{verbatim}
var <name> <value>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
var MY_NET [192.168.1.0/24,10.1.1.0/24]
alert tcp any any -> $MY_NET any (flags:S; msg:"SYN packet";)
\end{verbatim}

\caption{Example of Variable Definition and Usage\label{variable definition}}
\end{figure}

Rule variable names can be modified in several ways. You can define
meta-variables using the \$ operator. These can be used with the variable
modifier operators {\tt ?}  and {\tt -}, as described in the following table: 

\begin{tabular}{| l | p{5in} |}
\hline
\textbf{Variable Syntax} & \textbf{Description}\\
\hline
\hline
\texttt{var} & Defines a meta-variable.\\
\hline
\texttt{\$(var) or \$var} & Replaces with the contents of variable \texttt{var}.\\
\hline
\texttt{\$(var:-default)} & Replaces the contents of the variable \texttt{var} with ``default'' if 
   \texttt{var} is undefined.\\
\hline
\texttt{\$(var:?message)} & Replaces with the contents of variable \texttt{var} or prints out the
error message and exits.\\
\hline
\end{tabular}


See Figure \ref{advanced variable usage} for an example of advanced variable usage in action.

\begin{figure}[!hbpt]
\begin{verbatim}
var MY_NET 192.168.1.0/24
log tcp any any -> $(MY_NET:?MY_NET is undefined!) 23
\end{verbatim}

\caption{Figure Advanced Variable Usage Example\label{advanced variable usage}}
\end{figure}

\subsection{Config}

Many configuration and command line options of Snort can be specified
in the configuration file. 

\subsubsection{Format}

\begin{center}
\begin{verbatim}
config <directive> [: <value>]
\end{verbatim}
\end{center}


\subsubsection{Directives}
\begin{center}
\begin{longtable}{| p{2in} | p{2.25in} | p{2.25in} |}
\caption{Config Directives} \\
\hline
{\bf Command} & {\bf Example} & {\bf Description}\\
\hline
\hline
\texttt{order} & \texttt{config order: pass alert log activation} & Changes the order that rules are evaluated. \\
\hline
\texttt{alertfile} & \texttt{config alertfile: alerts} & Sets the alerts output file. \\
\hline
\texttt{classification} & \texttt{config classification: misc-activity,Misc activity,3} & See Table \ref{Snort Default Classifications} for a list of
  classifications.\\
\hline
%%\texttt{decode\_arp} & \texttt{config decode\_arp} & Turns on ARP decoding (\texttt{snort -a}).  \\
%%\hline
\texttt{dump\_chars\_only} & \texttt{config dump\_chars\_only} & Turns on character dumps (\texttt{snort -C}). \\

\hline
\texttt{dump\_payload} & \texttt{config dump\_payload} & Dumps application layer (\texttt{snort -d}). \\
\hline
\texttt{decode\_data\_link} & \texttt{config decode\_data\_link} & Decodes Layer2 headers (\texttt{snort -e}). \\
\hline
\texttt{bpf\_file} & \texttt{config bpf\_file: filters.bpf} & Specifies BPF filters (\texttt{snort -F}). \\
\hline
\texttt{daemon} & \texttt{config daemon} & Forks as a daemon (\texttt{snort -D}). \\
% yeah, this should go away...
% reference\_net]Set home network (snort -h). Example: config reference\_net: 192.168.1.0/24
\hline
\texttt{interface} & \texttt{config interface: xl0} & Sets the network interface (\texttt{snort -i}). \\
\hline
\texttt{alert\_with\_interface\_name} & \texttt{config alert\_with\_interface\_name} & Appends interface name to alert (\texttt{snort -I}). \\
\hline
\texttt{logdir} & \texttt{config logdir: /var/log/snort} & Sets the logdir (\texttt{snort -l}). \\
\hline
\texttt{umask} & \texttt{config umask: 022} & Sets umask when running (\texttt{snort -m}). \\
\hline
\texttt{pkt\_count} & \texttt{config pkt\_count: 13} & Exits after N packets (\texttt{snort -n}). \\
\hline
\texttt{nolog} & \texttt{config nolog} & Disables logging. Note: Alerts will still occur. (\texttt{snort -N}). \\
\hline
\texttt{obfuscate} & \texttt{config obfuscate} & Obfuscates IP Addresses (\texttt{snort -O}). \\
\hline
\texttt{no\_promisc} & \texttt{config no\_promisc} & Disables promiscuous mode (\texttt{snort -p}). \\
\hline
\texttt{quiet} & \texttt{config quiet}& Disables banner and status reports (\texttt{snort -q}). \\
\hline
\texttt{chroot} & \texttt{config chroot: /home/snort} & Chroots to specified dir (\texttt{snort -t}). \\
\hline
\texttt{checksum\_mode} & \texttt{config checksum\_mode : all} & Types of packets 
to calculate checksums. Values: \texttt{none}, \texttt{noip}, \texttt{notcp}, 
\texttt{noicmp}, \texttt{noudp}, \texttt{ip}, \texttt{tcp}, \texttt{udp}, \texttt{icmp} or \texttt{all}. \\
\hline
\texttt{checksum\_drop} & \texttt{config checksum\_drop : all} & Types of packets 
to drop if invalid checksums. Values: \texttt{none}, \texttt{noip}, \texttt{notcp}, 
\texttt{noicmp}, \texttt{noudp}, \texttt{ip}, \texttt{tcp}, \texttt{udp}, \texttt{icmp} or \texttt{all} (only applicable in inline mode and for packets checked per \texttt{checksum\_mode} config option). \\
\hline
\texttt{set\_gid} & \texttt{config set\_gid: 30} & Changes GID to specified GID (\texttt{snort -g}). \\
\hline
\texttt{set\_uid} & \texttt{set\_uid: snort\_user} & Sets UID to $<$id$>$ (\texttt{snort -u}). \\
\hline
\texttt{utc} & \texttt{config utc} & Uses UTC instead of local time for timestamps (\texttt{snort -U}). \\
\hline
\texttt{verbose} & \texttt{config verbose} & Uses verbose logging to STDOUT (\texttt{snort -v}). \\
\hline
\texttt{dump\_payload\_verbose} & \texttt{config dump\_payload\_verbose} & Dumps raw packet starting at link layer (\texttt{snort -X}). \\
\hline
\texttt{show\_year} & \texttt{config show\_year} & Shows year in timestamps (\texttt{snort -y}). \\
\hline
\texttt{stateful} & \texttt{config stateful} & Sets assurance mode for stream4 (est). See the stream4\_reassemble configuration in table \ref{stream4 reassemble defaults}. \\
\hline
\texttt{min\_ttl} & \texttt{config min\_ttl:30} & Sets a Snort-wide minimum ttl to ignore all traffic. \\
\hline
\texttt{disable\_decode\_alerts} & \texttt{config disable\_decode\_alerts} & Turns off the alerts generated by the decode phase of Snort. \\
\hline
\texttt{disable\_tcpopt\_experimental\_\linebreak alerts} & \texttt{config disable\_tcpopt\_experiment\linebreak al\_alerts} & Turns off alerts generated by experimental TCP options. \\
\hline
\texttt{disable\_tcpopt\_obsolete\_\linebreak alerts} & \texttt{config disable\_tcpopt\_obsole\linebreak te\_alerts} & Turns off alerts generated by obsolete TCP options. \\
\hline
\hline
\texttt{disable\_tcpopt\_ttcp\_alerts} & \texttt{config disable\_tcpopt\_ttcp\_alerts} & Turns off alerts generated by T/TCP options. \\
\hline
\texttt{disable\_ttcp\_alerts} & \texttt{config disable\_ttcp\_alerts} & Turns off alerts generated by T/TCP options. \\
\hline
\texttt{disable\_tcpopt\_alerts} & \texttt{config disable\_tcpopt\_alerts} & Disables option length validation alerts. \\
\hline
\texttt{disable\_ipopt\_alerts} & \texttt{config disable\_ipopt\_alerts} & Disables IP option length validation alerts. \\
\hline
\texttt{enable\_decode\_drops} & \texttt{config enable\_decode\_drops} & Enables the dropping of
bad packets identified by decoder (only applicable in inline mode).\\
\hline
\texttt{enable\_tcpopt\_experimental\_\linebreak drops} & \texttt{config enable\_tcpopt\_experi\linebreak mental\_drops} & Enables the dropping of bad packets with experimental TCP option.
        (only applicable in inline mode).\\
\hline
\texttt{enable\_tcpopt\_obsolete\_\linebreak drops} & \texttt{config enable\_tcpopt\_obsole\linebreak te\_drops} & Enables the dropping of bad packets with obsolete TCP option.
        (only applicable in inline mode).\\
\hline
\texttt{enable\_tcpopt\_ttcp\_drops} & \texttt{enable\_tcpopt\_ttcp\_drops} & Enables the dropping of bad packets with T/TCP option.
        (only applicable in inline mode).\\
\hline
\texttt{enable\_tcpopt\_drops} & \texttt{config enable\_tcpopt\_drops} & Enables the dropping of bad packets with bad/truncated TCP
        option (only applicable in inline mode).\\
\hline
\texttt{enable\_ipopt\_drops} &  \texttt{config enable\_ipopt\_drops} & Enables the dropping of bad packets with bad/truncated IP
        options (only applicable in inline mode).\\
\hline
\texttt{flowbits\_size} & \texttt{config flowbits\_size: 128} & Specifies the maximum number of flowbit tags that can be used within
        a rule set.\\
\hline
\texttt{event\_queue} & \texttt{config event\_queue: max\_queue 512 log 100 order\_events priority} &  
Specifies conditions about Snort's event queue. You can use the following options:
\begin{itemize}
\item \texttt{max\_queue $<$integer$>$} (max events supported)
\item \texttt{log $<$integer$>$} (number of events to log) 
\item \texttt{order\_events [priority$|$content\_length]} (how to order events within the queue)\end{itemize}
See Section \ref{eventqueue} for more information and examples.\\
% XXX - NEED MORE HERE!!!
\hline
\texttt{layer2resets} & \texttt{config layer2resets: 00:06:76:DD:5F:E3} & This option is only available when running in inline mode. See Section \ref{Snort Inline}.\\
\hline
\texttt{detection} & \texttt{config detection: search-method ac no\_stream\_inserts max\_queue\_events 128} & Makes changes to the detection engine. 
The following options can be used:\begin{itemize}\item \texttt{search-method $<$ac $|$ ac-std $|$ ac-bnfa $|$ acs $|$ ac-banded $|$ ac-sparsebands $|$ lowmem $>$}
\begin{itemize}
\item \texttt{ac} Aho-Corasick Full (high memory, best performance)
\item \texttt{ac-std} Aho-Corasick Standard (moderate memory, high performance)
\item \texttt{ac-bnfa} Aho-Corasick NFA (low memory, high performance)
\item \texttt{acs} Aho-Corasick Sparse (small memory, moderate performance)
\item \texttt{ac-banded} Aho-Corasick Banded (small memory, moderate performance)
\item \texttt{ac-sparsebands} Aho-Corasick Sparse-Banded (small memory, high performance)
\item \texttt{lowmem} Low Memory Keyword Trie (small memory, low performance)
%\item \texttt{mwm} Wu-Manber (small memory, low performance)
\end{itemize}
\item \texttt{no\_stream\_inserts}
\item \texttt{max\_queue\_events$<$integer$>$}\end{itemize}\\
\hline
\texttt{asn1} & \texttt{config asn1:256} & Specifies the maximum number of nodes to 
track when doing ASN1 decoding. See Section \ref{asn1} for more information and examples.\\
\hline
\texttt{snaplen} & \texttt{config snaplen: 2048} & Set the snaplength of packet, same effect as 
\texttt{-P $<$snaplen$>$} or \texttt{--snaplen $<$snaplen$>$} options.\\
\hline
\texttt{read\_bin\_file} & \texttt{config read\_bin\_file: test\_alert.pcap} & Specifies a pcap file to use 
(instead of reading from network),
        same effect as -r $<$tf$>$ option.\\
%debug Make snort print out debugging info debug \\
%no\_stream\_inserts] Do not perform detection on packets that that are going to be rebuilt 
%max\_queue\_events] Queues multiple alerts per packet and selects the most specific one (default: 5) Example: config max\_queue\_events: 5
\hline
\texttt{reference} & \texttt{config reference: myref http://myurl.com/?id=} & Adds a new reference system to Snort.  \\
\hline
\texttt{ignore\_ports} & \texttt{config ignore\_ports: udp 1:17 53} & Specifies ports to ignore (useful for ignoring noisy NFS traffic). Specify the protocol (TCP, UDP, IP, or ICMP), followed by a list of ports. Port ranges are supported.\\
\hline
\end{longtable}
\end{center}

%\begin{note}
%The Wu-Manber pattern matching engine (\texttt{search-method mwm}) will be
%deprecated in a future Snort release in favor of pattern matching algorithms
%with better performance and smaller memory consumption.
%\end{note}

\newpage
\section{Preprocessors}

Preprocessors were introduced in version 1.5 of Snort. They allow
the functionality of Snort to be extended by allowing users and programmers
to drop modular plugins into Snort fairly easily.
Preprocessor code is run before the detection engine is called, but
after the packet has been decoded. The packet can be modified or analyzed
in an out-of-band manner using this mechanism.

Preprocessors are loaded and configured using the {\tt preprocessor} keyword.
The format of the preprocessor directive in the Snort rules file is:

\begin{verbatim}
preprocessor <name>: <options>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
preprocessor minfrag: 128
\end{verbatim}

\caption{\label{Preprocessor Example}Preprocessor Directive Format Example}
\end{figure}


\subsection{Frag2\label{Frag2 Section}}

\begin{note}
Frag2 is deprecated in Snort 2.4.0 and later in favor of frag3. See Section \ref{frag3 section} for more information about frag3.
\end{note}

%Frag2 is a new IP defragmentation preprocessor introduced in Snort 1.8 and is 
%designed to replace the Defrag preprocessor.
%This defragmenter is designed to be memory efficient and use the same
%memory management routines that are in use in other parts of Snort. 
%
%Frag2 has configurable memory usage and fragment timeout options.
%Given no arguments, Frag2 uses the default memory limit of 4194304
%bytes (4\textsc{mb}) and a timeout period of 60 seconds. The timeout
%period is used to determine a length of time after which an unassembled fragment
%should be discarded.
%
%In Snort 1.8.7, several options were added to help catch the use of
%evasion techniques, such as fragroute. 
%
%
%\subsubsection{Format}
%
%\begin{verbatim}
%preprocessor frag2: [memcap <xxx>], [timeout <xx>], [min_ttl <xx>], \
%                    [detect_state_problems], [ttl_limit <xx>] 
%\end{verbatim}
%\begin{tabular}{| l | p{5in} |}
%\hline
%\textbf{Option} & \textbf{Description}\\
%\hline
%\hline
%\texttt{timeout~<seconds>} & Amount of time to keep an inactive stream in
%the state table; sessions that are flushed will automatically be picked
%up again if more activity is seen. The default value is 30 seconds.\\
%\hline
%\texttt{memcap~<bytes>} & Number of bytes to set the memory cap at; if this
%limit is exceeded, Frag2 will aggressively prune inactive reassemblers. The
%default value is 4\textsc{mb}.\\
%\hline
%\texttt{detect\_state\_problems} & Turns on alerts for events such as overlapping
%fragments.\\
%\hline
%\texttt{min\_ttl} & Sets the minimum ttl that Frag2 will accept.\\
%\hline
%\texttt{ttl\_limit} & Sets the delta value that will set off an evasion alert
%(initial fragment ttl +/- ttl limit). \\
%\hline
%\end{tabular}
%%
%\begin{figure}[!hbpt]
%\begin{verbatim}
%preprocessor frag2: memcap 16777216, timeout 30
%\end{verbatim}
%
%\caption{Frag2 Preprocessor Configuration \label{Frag2 Example}}
%\end{figure}

\subsection{Frag3 \label{frag3 section}}

The frag3 preprocessor is a target-based IP defragmentation module for Snort.
Frag3 is intended as a replacement for the frag2 defragmentation module and 
was designed with the following goals:
\begin{slist}
\item Faster execution than frag2 with less complex data management.
\item Target-based host modeling anti-evasion techniques.
\end{slist}

The frag2 preprocessor used splay trees extensively for managing the data 
structures associated with defragmenting packets.  Splay trees are excellent 
data structures to use when you have some assurance of locality of reference
for the data that you are handling but in high speed, heavily fragmented 
environments the nature of the splay trees worked against the system and 
actually hindered performance.  Frag3 uses the sfxhash data structure and 
linked lists for data handling internally which allows it to have much more
predictable and deterministic performance in any environment which should 
aid us in managing heavily fragmented environments.

Target-based analysis is a relatively new concept in network-based intrusion
detection.  The idea of a target-based system is to model the actual targets
on the network instead of merely modeling the protocols and looking for 
attacks within them.  When IP stacks are written for different operating 
systems, they are usually implemented by people who read the RFCs and then
write their interpretation of what the RFC outlines into code.  Unfortunately, there
are ambiguities in the way that the RFCs define some of the edge conditions 
that may occurr and when this happens different people implement certain aspects
of their IP stacks differently.  For an IDS this is a big problem.

In an environment where the attacker can determine what style of IP 
defragmentation is being used on a particular target, the attacker can try to
fragment packets such that the target will put them back together in a 
specific manner while any passive systems trying to model the host traffic 
have to guess which way the target OS is going to handle the overlaps and 
retransmits.  As I like to say, if the attacker has more information about the
targets on a network than the IDS does, it is possible to evade the IDS.  This
is where the idea for ``target-based IDS'' came from.  For more detail on this
issue and how it affects IDS, check out the famous Ptacek \& Newsham paper at
\url{http://www.snort.org/docs/idspaper/}.

The basic idea behind target-based IDS is that we tell the IDS information 
about hosts on the network so that it can avoid Ptacek \& Newsham style evasion
attacks based on information about how an individual target IP stack operates.
Vern Paxson and Umesh Shankar did a great paper on this very topic in 2003 that 
detailed mapping the hosts on a network and determining how their various IP 
stack implementations handled the types of problems seen in IP defragmentation 
and TCP stream reassembly.  Check it out at \url{http://www.icir.org/vern/papers/activemap-oak03.pdf}.

We can also present the IDS with topology information to avoid TTL-based 
evasions and a variety of other issues, but that's a topic for another day.  
Once we have this information we can start to really change the game for these 
complex modeling problems.

Frag3 was implemented to showcase and prototype a target-based module within
Snort to test this idea.

\subsubsection{Frag 3 Configuration}

Frag3 configuration is somewhat more complex than frag2.  There are at least
two preprocessor directives required to activate frag3, a global configuration
directive and an engine instantiation.  There can be an arbitrary number of
engines defined at startup with their own configuration, but only one global
configuration.

\textbf{Global Configuration}
\begin{itemize}
\item Preprocessor name: \texttt{frag3\_global}
\item Available options:
  \begin{itemize}
   \item     \texttt{max\_frags $<$number$>$} - Maximum simultaneous fragments to track. Default is 8192.
   \item     \texttt{memcap $<$bytes$>$} - Memory cap for self preservation.  Default is 4MB.  
   \item    \texttt{prealloc\_frags $<$number$>$} - Alternate memory management mode.  Use preallocated fragment nodes (faster in some situations).
  \end{itemize}                               
\end{itemize}    
 
\textbf{Engine Configuration}
\begin{itemize}
\item Preprocessor name: \texttt{frag3\_engine}
\item Available options:
  \begin{itemize}
  \item   \texttt{timeout $<$seconds$>$} - Timeout for fragments.  Fragments in the engine for 
                         longer than this period will be automatically dropped.
                         Default is 60 seconds.
                         
  \item   \texttt{ttl\_limit $<$hops$>$} - Max TTL delta acceptable for packets based on the first
                        packet in the fragment.  Default is 5.
                        
  \item   \texttt{min\_ttl $<$value$>$} - Minimum acceptable TTL value for a fragment packet.  
                       Default is 1.
                       
  \item  \texttt{detect\_anomalies} - Detect fragment anomalies.
     
   \item  \texttt{bind\_to $<$ip\_list$>$} - IP List to bind this engine to.  This engine will only
                         run for packets with destination addresses contained
                         within the IP List.  Default value is \texttt{all}.
                         
   \item \texttt{policy $<$type$>$} - Select a target-based defragmentation mode.  Available 
                     types are first, last, bsd, bsd-right, linux.  Default
                     type is bsd.

                     The Paxson Active Mapping paper introduced the terminology
                     frag3 is using to describe policy types.  The known 
                     mappings are as follows.  Anyone who develops more 
                     mappings and would like to add to this list please feel
                     free to send us an email!
                     
\begin{tabular}{| l | l |}
\hline
\textbf{Platform} & \textbf{Type}\\
\hline
\hline                     
                        AIX 2  & BSD \\
                        \hline
                AIX 4.3 8.9.3  & BSD \\
                        \hline
                    Cisco IOS  & Last \\
                        \hline
                      FreeBSD  & BSD\\
                        \hline 
       HP JetDirect (printer)  & BSD-right \\
                        \hline
                HP-UX B.10.20  & BSD \\
                        \hline
                  HP-UX 11.00  & First \\
                        \hline
                  IRIX 4.0.5F  & BSD \\
                        \hline
                     IRIX 6.2  & BSD \\
                        \hline
                     IRIX 6.3  & BSD \\
                        \hline
                   IRIX64 6.4  & BSD \\
                        \hline
                 Linux 2.2.10  & linux \\
                        \hline
             Linux 2.2.14-5.0  & linux \\
                        \hline
               Linux 2.2.16-3  & linux \\
                        \hline
       Linux 2.2.19-6.2.10smp  & linux \\
                        \hline
               Linux 2.4.7-10  & linux \\
                        \hline
   Linux 2.4.9-31SGI 1.0.2smp  & linux \\
                        \hline
   Linux 2.4 (RedHat 7.1-7.3)  & linux \\
                        \hline
      MacOS (version unknown)  & First \\
                        \hline
             NCD Thin Clients  & BSD \\
                        \hline
    OpenBSD (version unknown)  & linux \\
                        \hline
    OpenBSD (version unknown)  & linux \\
                        \hline
                  OpenVMS 7.1  & BSD \\
                        \hline
       OS/2 (version unknown)  & BSD \\
                        \hline
                    OSF1 V3.0  & BSD \\
                        \hline
                    OSF1 V3.2  & BSD \\
                        \hline
            OSF1 V4.0,5.0,5.1  & BSD \\
                        \hline
                  SunOS 4.1.4  & BSD \\
                        \hline
      SunOS 5.5.1,5.6,5.7,5.8  & First \\
                        \hline
        Tru64 Unix V5.0A,V5.1  & BSD \\
                        \hline
                      Vax/VMS  & BSD \\
                        \hline
   Windows (95/98/NT4/W2K/XP)  & First\\
                        \hline
                        \end{tabular}

 \end{itemize}
\end{itemize}

\subsubsection{format}

\begin{figure}[!hbpt]
\begin{verbatim}
preprocessor frag3_global
preprocessor frag3_engine
\end{verbatim}

\caption{Example configuration (Basic)\label{Frag3 Example Basic}}
\end{figure}

\begin{figure}[!hbpt]
\begin{verbatim}
preprocessor frag3_global: prealloc_nodes 8192 
preprocessor frag3_engine: policy linux, bind_to 192.168.1.0/24
preprocessor frag3_engine: policy first, bind_to [10.1.47.0/24,172.16.8.0/24]
preprocessor frag3_engine: policy last, detect_anomalies
\end{verbatim}

\caption{Example configuration (Advanced)\label{Frag3 Example Advanced}}
\end{figure}

Note in the advanced example (Figure \ref{Frag3 Example Advanced}), there are three engines specified running with 
\emph{Linux}, \texttt{first} and \texttt{last} policies assigned.  The first two engines are bound to
specific IP address ranges and the last one applies to all other traffic.
Packets that don't fall within the address requirements of the first two engines
automatically fall through to the third one.

\subsubsection{Frag 3 Alert Output\label{frag3 alert output}}

Frag3 is capable of detecting eight different types of anomalies.  Its event
output is packet-based so it will work with all output modes of Snort.  Read
the documentation in the \texttt{doc/signatures} directory with filenames that begin
with ``123-'' for information on the different event types.
%%Need to doc these eight types of anomalies and truncate beginning of section.



\subsection{Stream4\label{stream 4 section}}

The Stream4 module provides TCP stream reassembly and stateful analysis
capabilities to Snort. Robust stream reassembly capabilities allow Snort
to ignore "stateless" attacks (which include the types of attacks that
Stick and Snot produce). Stream4 also gives large scale users the ability
to track many simultaneous TCP streams.  Stream4 is set to handle 8192
simultaneous TCP connections in its default configuration; however, it
scales to handle over 100,000 simultaneous connections.

Stream4 can also provide session tracking of UDP conversations. To enable
this in the Snort binary, pass \texttt{--enable-stream4udp} to
\texttt{configure} before compiling.  You will also need to enable it
in the \texttt{stream4} configuration.

Stream4 contains two configurable modules: the global \texttt{stream4} preprocessor
and the \texttt{stream4\_reassemble} preprocessor. 

\begin{note}
Additional options can be used if Snort is running in inline mode. See Section \ref{Stream4Inline} for more information.
\end{note}


\subsubsection{Stream4 Format}

\begin{verbatim}
preprocessor stream4: [noinspect], [asynchronous_link], [keepstats [machine|binary]], \
                      [detect_scans], [log_flushed_streams], [detect_state_problems], \
                      [disable_evasion_alerts], [timeout <seconds>], [memcap <bytes>],  \
                      [max_sessions <num sessions>], [enforce_state], \
                      [cache_clean_sessions <num of sessions>], [ttl_limit <count>], \
                      [self_preservation_threshold <threshold>], \
                      [self_preservation_period <seconds>], \
                      [suspend_threshold <threshold>], [suspend_period <seconds>], \
                      [state_protection], [server_inspect_limit <bytes>], \
                      [enable_udp_sessions], [max_udp_sessions <num sessions>], \
                      [udp_ignore_any]
\end{verbatim}
\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Description}\\
\hline 
\hline 
\texttt{asynchronous\_link} & Uses state transitions based only on one-sided conversation (no tracking of acknowledge/sequence numbers).\\
\hline
\texttt{cache\_clean\_sessions~<num~sessions>} & Purges this number of least-recently used sessions from the session cache.\\
\hline
\texttt{detect\_scans} & Turns on alerts for portscan events.\\
\hline
\texttt{detect\_state\_problems} & Turns on alerts for stream events of note, such as evasive RST packets, data on the SYN packet, and out of window sequence numbers.\\
\hline
\texttt{enforce\_state} & Enforces statefulness so that sessions aren't picked up mid-stream.\\
\hline
\texttt{keepstats} & Records session summary information in \texttt{$<$logdir$>$/session.log}. If no options are specified, output is human readable.\\
\hline
\texttt{log\_flushed\_streams} & Log the packets that are part of reassembled stream.\\
\hline
\texttt{disable\_evasion\_alerts} & Turns off alerts for events such as TCP
overlap.\\
\hline
\texttt{timeout <seconds>} & Amount of time to keep an inactive stream in the state table; sessions that are flushed will automatically be picked up again if more activity is seen. The default value is 30 seconds.\\
\hline
\texttt{memcap <bytes>} & Sets the number of bytes used to store packets for reassembly.\\
\hline
\texttt{max\_sessions <num sessions>} & Sets the maximum number of simultaneous sessions.\\
\hline
\texttt{noinspect} & Disables stateful inspection.\\
\hline
\texttt{ttl\_limit <count>} & Sets the delta value that will set off an evasion alert.\\
\hline
\texttt{self\_preservation\_threshold <threshold>} & Set limit on number of sessions before entering self-preservation mode (only reassemble data on the default ports).\\
\hline
\texttt{self\_preservation\_period <seconds>} & Set length of time (seconds) to remain in self-preservation mode.\\
\hline
\texttt{suspend\_threshold <threshold>} & Sets limit on number of sessions before entering suspend mode (no reassembly).\\
\hline
\texttt{suspend\_period <seconds>} & Sets length of time (seconds) to remain in suspend mode.\\
\hline
\texttt{server\_inspect\_limit <bytes>} & Restricts inspection of server traffic to this many bytes until another client request is seen (ie: client packet with data).\\
\hline
\texttt{state\_protection} & Protects self against DoS attacks.\\
\hline
\texttt{enable\_udp\_sessions} & Enable UDP session tracking.\\
\hline
\texttt{max\_udp\_sessions <num sessions>} & The maximum number of UDP sessions to be tracked. Default is 8192 if UDP sessions are enabled.\\
\hline
\texttt{udp\_ignore\_any} & Ignore traffic on port without port-specific rules.  The result of this is that NO rules (include IP only rules) are applied to UDP traffic that has a source/destination port that is listed in a port-specific ruls.\\
\hline
\end{tabular}

\subsubsection{stream4\_reassemble Format}

\begin{verbatim}
preprocessor stream4_reassemble: [clientonly], [serveronly], [both], [noalerts], \
                                 [favor_old], [favor_new], [flush_on_alert], \
                                 [flush_behavior random|default|large_window], \
                                 [flush_base <number>], [flush_range <number>], \
                                 [flush_seed <number>], [overlap_limit <number>], \
                                 [ports <portlist>], [emergency_ports <portlist>] \
                                 [zero_flushed_packets], [flush_data_diff_size <number>] \
                                 [large_packet_performance]
\end{verbatim}
\begin{tabular}{| p{0.50\textwidth} | p{0.50\textwidth} |}
\hline
\textbf{Option} & \textbf{Description}\\
\hline
\hline
\texttt{clientonly} & Provides reassembly for the client side of a connection
only.\\
\hline
\texttt{serveronly} & Provides reassembly for the server side of a connection
only.\\
\hline
\texttt{both} & Reassemble for client and server sides of connection.\\
\hline
\texttt{noalerts} & Won't alert on events that may be insertion or evasion
attacks.\\
\hline
\texttt{favor\_old} & Favor old segments based on sequence number over a new segments. \\
\hline
\texttt{favor\_new} & Favor new segments based on sequence number over a old segments. \\
\hline
\texttt{flush\_on\_alert} & Flush a stream when an individual packet causes an alert.\\
\hline
\texttt{flush\_behavior random|default|large\_window} & Use specified flush behavior. \texttt{default} means use old static flush points. \texttt{large\_window} means use new larger flush points. \texttt{random} means use random flush points defined by \texttt{flush\_base}, \texttt{flush\_seed} and \texttt{flush\_range}.\\
\hline
\texttt{flush\_base <number>} & Lowest allowed random flush point.  The default value is 512 bytes.  Only used if \texttt{flush\_behavior} is \texttt{random}. \\
\hline
\texttt{flush\_range <number>} & Space within random flush points are generated.  The default value is 1213.  Only used if \texttt{flush\_behavior} is \texttt{random}. \\
\hline
\texttt{flush\_seed <number>} & Random seed for flush points.  The default value is computed from Snort PID + time.  Only used if \texttt{flush\_behavior} is \texttt{random}. \\
\hline
\texttt{overlap\_limit <number>} & Alert when the number of overlapping data bytes reaches a threshold.\\
\hline
\texttt{ports <portlist>} & Provides reassembly for a
whitespace-separated list of ports.  By default, reassembly is performed
for ports 21, 23, 25, 42, 53, 80, 110, 111, 135, 136, 137, 139, 143, 445,
513, 1443, 1521, and 3306. To perform reassembly for all ports, use
\texttt{all} as the port list.\\
\hline
\texttt{emergency\_ports <portlist>} & Emergency ports are those which we ALWAYS do reassembly when in 'self-preservation' mode. They are used to have a lowest level when snort is under duress because of high traffic rates. The default ports are the same as for the ports option.\\
\hline
\texttt{flush\_data\_diff\_size <number>} & minumum size of a packet to zero out the empty space in a rebuilt packet. \\
\hline
\texttt{zero\_flushed\_packets} & Zero out any space that is not filled in when flushing a rebuilt packet.\\
\hline
\texttt{large\_packet\_performance} & Do not buffer and reassemble consecutive large packets (larger than twice the flush point). The chances of catching an attack that spans those large packets is small, compared to the CPU and memory utilization to copy and re-copy the large packet.\\
\hline
\end{tabular}

\subsubsection{Notes}

Just setting the \texttt{stream4} and \texttt{stream4\_reassemble} directives without
arguments in the \texttt{snort.conf} file will set them up in their default
configurations shown in Table \ref{Stream4 Defaults} and Table \ref{stream4 reassemble defaults}.

\vspace{-30pt}

%
\begin{table}[!hbpt]

\caption{Stream4 Defaults\label{Stream4 Defaults}}

\begin{center}\begin{tabular}{| l | l |}
\hline 
\textbf{Option} &
\textbf{Default}\\
\hline
\hline 
session timeout (\texttt{timeout}) & 30 seconds\\
\hline 
session memory cap (\texttt{memcap}) & 8388608 bytes\\
\hline 
stateful inspection (\texttt{noinspect}) & active (\texttt{noinspect} disabled)\\
\hline 
stream stats (\texttt{keepstats}) & inactive\\
\hline 
state problem alerts (\texttt{detect\_state\_problems}) & inactive (\texttt{detect\_state\_problems} disabled)\\
\hline
evasion alerts (\texttt{disable\_evasion\_alerts})  & inactive (\texttt{disable\_evasion\_alerts} enabled)\\
\hline
asynchronous link (\texttt{asynchronous\_link}) & inactive\\
\hline
log flushed streams (\texttt{log\_flushed\_streams}) & inactive\\
\hline
max TCP sessions (\texttt{max\_sessions}) & 8192\\
\hline
session cache purge (\texttt{cache\_clean\_sessions}) & 5\\
\hline
self preservation threshold (\texttt{self\_preservation\_threshold}) & 50 sessions/sec\\
\hline
self preservation period (\texttt{self\_preservation\_period}) & 90 seconds\\
\hline
suspend threshold (\texttt{suspend\_threshold}) & 200 sessions/sec\\
\hline
suspend period (\texttt{suspend\_period}) & 30 seconds\\
\hline
state protection (\texttt{state\_protection}) & inactive\\
\hline
server inspect limit (\texttt{server\_inspect\_limit}) & -1 (inactive)\\
\hline
UDP session tracking (\texttt{enable\_udp\_sessions}) & inactive\\
\hline
max UDP sessions (\texttt{max\_udp\_sessions}) & 8192\\
\hline
\end{tabular}
\end{center}
\end{table}

%
\begin{table}[!hbpt]

\caption{stream4\_reassemble Defaults\label{stream4 reassemble defaults}}

\begin{center}\begin{tabular}{| l | p{3in} |}
\hline 
\textbf{Option} &
\textbf{Default}\\
\hline
\hline 
reassemble client (\texttt{clientonly}) & active\\
\hline 
reassemble server (\texttt{serveronly}) & inactive\\
\hline 
reassemble both (\texttt{both}) & inactive\\
\hline
reassemble ports (\texttt{ports}) & 21 23 25 42 53 80 110 111 135 136 137 139 143 445 513 1433 1521 3306\\
\hline
emergency reassemble ports (\texttt{ports}) & 21 23 25 42 53 80 110 111 135 136 137 139 143 445 513 1433 1521 3306\\
\hline 
reassembly alerts (\texttt{noalerts}) & active (\texttt{noalerts} disabled)\\
\hline
favor old packet (\texttt{favor\_old}) & active\\
\hline
favor new packet (\texttt{favor\_new}) & inactive\\
\hline
flush on alert (\texttt{flush\_on\_alert}) & inactive\\
\hline
overlap limit (\texttt{overlap\_limit}) & -1 (inactive)\\
\hline
large packet performance (\texttt{large\_packet\_performance}) & inactive\\
\hline
\end{tabular}
\end{center}
\end{table}

\clearpage

\subsection{Flow\label{sub:flow}}

The Flow tracking module is meant to start unifying the state keeping
mechanisms of Snort into a single place. As of Snort 2.1.0, only a portscan
detector is implemented, but in the long term,  many of the stateful subsystems
of Snort will be migrated over to becoming flow plugins. With the introduction
of flow, this effectively makes the conversation preprocessor obsolete.

An IPv4 flow is unique when the IP protocol (\texttt{ip\_proto}), source IP (\texttt{sip}),
source port (\texttt{sport}), destination IP (\texttt{dip}), and destination port (\texttt{dport}) are the
same.  The \texttt{dport} and \texttt{sport} are 0 unless the protocol is TCP or UDP.

\subsubsection{Format}
\begin{verbatim}
preprocessor flow: [memcap <bytes>], [rows <count>], \
                   [stats_interval <seconds>], [hash <1|2>]
\end{verbatim}

\begin{table}[hbpt]{}
\caption{Flow Options}
\begin{minipage}[hbpt]{6in}
\begin{center}\begin{tabular}{| l | l |}
\hline 
\textbf{Option} & \textbf{Description}\\
\hline
\hline
\texttt{memcap} &
Number of bytes to allocate.\\
\hline 
\texttt{rows} & Number of rows for the flow hash table. \footnote[1]{This number can be increased, at the cost of using more memory, to enhance performance. Increasing rows provides a larger hash table.}\\
\hline 
\texttt{stats\_interval} &
Interval (in seconds) to dump statistics to STDOUT. Set this to 0 to disable.\\
\hline 
\texttt{hash} & Hashing method to use.\footnote[2]{1 - hash by byte, 2 - hash by integer (faster, not as much of a chance to become diverse).  The hash table has a pseudo-random salt picked to make algorithmic complexity attacks much more difficult.}   \\
\hline
\end{tabular}
\end{center}
\end{minipage}
\end{table}

\subsubsection{Example Configuration}

\begin{verbatim}
preprocessor flow: stats_interval 0 hash 2
\end{verbatim}

\subsection{Portscan}

\begin{note}
The "Portscan" preprocessor was deprecated in Snort 2.2, in favor of Flow
Portscan, which was deprecated in Snort 2.3, in favor of sfPortscan.
\end{note}

%The Snort Portscan preprocessor is developed by Patrick Mullen.
%
%\subsubsection{What the Snort Portscan Preprocessor Does}
%
%\begin{itemize}
%\item Logs the start and end of portscans from a single source IP to the
%standard logging facility.
%\item If a log file is specified, it logs the destination IPs and ports scanned,
%as well as the type of scan.
%\end{itemize}
%A portscan is defined as TCP connection attempts to more than {\em p} ports
%in {\em t} seconds or udp packets sent to more than {\em p} ports in {\em t} seconds.
%Ports can be spread across any number of destination IP addresses,
%and may all be the same port if spread across multiple IPs. This version of the Portscan
%preprocessor
%does single $\rightarrow$ single and single $\rightarrow$ many portscans. The next full release
%will do distributed portscans (multiple $\rightarrow$ single or multiple $\rightarrow$ multiple).
%A portscan is also defined as a single stealth scan
%packet, such as NULL, FIN, SYN-FIN, XMAS, etc. This means that from
%scan-lib in the standard distribution of Snort, you should comment
%out the section for stealth scan packets. The benefit is that, with the
%portscan module, these alerts would only show once per scan, rather
%than once for each packet. If you use the external logging feature,
%you can view the portscan technique and type in the log file.
%
%The arguments to this module are:
% 
%\begin{tabular}{| l | p{5in} |}
%\hline
%{\bf Option} & {\bf Description}\\
%\hline
%\hline
%monitored network & The network/CIDR block to monitor for portscans.\\
%\hline
%number of ports & The number of ports accessed during the detection period.\\
%\hline
%detection period & The number of seconds to count that the port access threshold
%is considered for. \\
%\hline
%logdir/filename & The directory/filename to place alerts in. Alerts
%are also written to the standard alert file.\\
%\hline
%\end{tabular}
%
%\subsubsection{Format}
%
%\begin{verbatim}
%portscan: <monitored network> <number of ports> <detection period> <logdir/filename>
%\end{verbatim}
%%
%\begin{figure}[!hbpt]
%\begin{verbatim}
%preprocessor portscan: 192.168.1.0/24 5 7 /var/log/portscan.log
%\end{verbatim}
%
%\caption{\label{Portscan Processor Config}Portscan Preprocessor Configuration
%Example}
%\end{figure}
%
%
%
%\subsection{Portscan Ignorehosts}
%
%Portscan Ignorehosts is another module from Patrick Mullen that modifies the 
%portscan detection system's operation. If you have servers that tend to trip the
%portscan detector (such as NTP, NFS, and DNS servers), you can tell
%portscan to ignore TCP Syn and UDP portscans from certain hosts. The
%arguments to this module are a list of IPs/CIDR blocks to be ignored.
%
%
%\subsubsection{Format}
%
%\begin{verbatim}
%portscan-ignorehosts: <host list>
%\end{verbatim}
%%
%\begin{figure}[!hbpt]
%\begin{verbatim}
%preprocessor portscan-ignorehosts: 192.168.1.5/32 192.168.3.0/24
%\end{verbatim}
%
%\caption{\label{Portscan Ignore Hosts Example}Portscan Ignorehosts Module
%Configuration Example}
%\end{figure}


\subsection{Flow-Portscan\label{sub:flow-portscan}}

\begin{note}
The Flow-Portscan preprocessor was deprecated in Snort 2.3, in
favor of sfPortscan.
\end{note}

%This module is designed to detect portscans based on flow creation in the
%flow preprocessors.  The goal is to catch one$\rightarrow$many hosts and one$\rightarrow$many ports
%scans.
%
%The Flow preprocessor to portscan recognizer is taken from experience with
%spp\_conversation/portscan2 by Jason Larsen \& Jed Haile and IPAudit by Jon
%Rifkin.
%
%This subsystem became a bit more complicated than originally intended, but it
%does a good job of mitigating false positives from devices such as Squid
%proxies.  The new design is also a lot more memory-consistent than Portscan1 or
%2.  It also ignores single port SYN floods as they are a DOS, not a portscan.
%
%Memory requirements should be way down from Portscan2 architecture though, but
%there's slightly less information saved off.  The new architecture operates
%similarly to a ring buffer---when a scanner has not been active in a long time,
%it's only reclaimed when there is no more memory to use.
%
%All of the prior methods for portscan detection in Snort are deprecated and
%will be removed in the near future.  If you have custom code against
%Conversation or one of the Portscan preprocessors, consider making it a module
%in Flow or Portscan.
%
%The Flow preprocessor must first be enabled for Flow-Portscan to
%function properly.
%
%The basic components of Flow-Portscan are:
%\begin{slist}
%\item \textbf{Scoreboards}
%
%Scoreboards contain information about timescales for a single IP address.  There are two scoreboards, one for talkers (nodes that are active on your network) and one for scanners (nodes that have talked to a previously unknown port in your server-watch-net).
% 
%\item \textbf{Uniqueness Tracker}
%
%The uniqueness tracker determines whether this connection should count as something "new" for a particular IP.  It verifies that a connection is a new type of connection for a source IP by disregarding the source port.  Any change in \texttt{sip}, \texttt{dip}, \texttt{ip\_proto}, and \texttt{dport} indicates a new unique connection and will be processed further for the server statistics table and scoring.  This keeps things like a web page with 15 images from rapidly increasing point scores with lots of accesses to the same web server.
%\item \textbf{Server Statistics Tracker}
%
%The server statistics tracker tracks flows destined to the "server-watchnet" and keeps "hitcounts" on the number of times a particular service has been requested with unique requests since Snort has started.  This hitcount is tracked by \texttt{dip}, \texttt{dport}, and \texttt{protocol}.
%\end{slist}
%
%If a service is very popular, connections can be ignored for scoring by
%comparing the hitcount to the ``server-ignore-limit.'' If there are more requests
%to this service than the server-ignore-limit, then flow-portscan will
%completely ignore this service.  Similarly, the ``server-scanner-limit'' controls
%if a request to a service counts as scanner points or as talker points.
%
%If a request to a service is not in the server-watchnet, it will count as
%talker points. If no server-watchnet is defined, all alerts will be talker
%alerts.
%
%
%\paragraph{Execution Path of Flow-Portscan}
%
%
%\begin{slist}
%\item Flow-Portscan receives a new flow message from the flow module.
%\item The uniqueness tracker determines if the message is a new type of flow by
%looking for changes in \texttt{sip}, \texttt{dip}, \texttt{ip\_proto}, and \texttt{dport}.  
%If this is not unique,
%and the tcp flags are normal, Flow-Portscan exits.
%\item If this connection is to a destination IP in the server-watchnet:
%\begin{itemize}
%	\item During the ``server-learning-time,'' it increments the hitcounts for service
%popularity. 
%
%	\item If it's not during the ``server-learning-time,'' it just obtains the stored hitcount.  If the hitcount is
%      greater than the server-ignore-limit, Flow-Portscan exits.  If the hitcount is less than the
%      server-scanner-limit, it marks the incremented points as scanner points.
%\end{itemize}
%\item A connection is marked as either a talker or a scanner by step 3.
%
%There are 4 time scales; 2 each for the IP scanner and IP talker.
%
%The fixed timescales detect \emph{n} events in \emph{m} seconds.  This is the typical type of
%portscan alert.
%
%The sliding timescales adjust the "score reset point" on each event after the
%first.  This adjusts the side of the window we're detecting portscan events in
%by taking
%
%\begin{verbatim} 
%end = end + ((end - start) * sliding-scale-factor)
%\end{verbatim}
%
%Each time scale has its own point tally that is incremented per new flow.
%Each set of points only touches either the talker-fixed-score and talker-sliding-score or the scanner-fixed-score and scanner-sliding-score
%
%\item Evaluate the score against individual thresholds, either talker or
%scanner. 
%
%\begin{verbatim}
%if(fixed_limit <= fixed_score)
%generate_alert()
%\end{verbatim}
%\end{slist}
%
%\subsubsection{Format}
%\begin{verbatim}
%preprocessor flow-portscan: [scoreboard-memcap-talker <bytes>] \
%                            [scoreboard-rows-talker <count>] \ 
%                            [scoreboard-rows-scanner <count>] \
%                            [scoreboard-memcap-scanner <bytes>] \
%                            [scanner-fixed-threshold <integer>] \
%                            [scanner-sliding-threshold <integer>] \
%                            [scanner-fixed-window <integer>] \
%                            [scanner-sliding-window <integer>] \
%                            [scanner-sliding-scale-factor <float>] \
%                            [talker-fixed-threshold <integer>] \
%                            [talker-sliding-threshold <integer>] \
%                            [talker-fixed-window <integer>] \
%                            [talker-sliding-window <integer>] \
%                            [talker-sliding-scale-factor <float>] \
%                            [unique-memcap <bytes>] \
%                            [unique-rows <integer>] \
%                            [server-memcap <bytes>] \
%                            [server-rows <integer>] \
%                            [server-watchnet <ip list in Snort notation>] \
%                            [src-ignore-net <ip list in Snort notation>] \
%                            [dst-ignore-net <ip list in Snort notation>] \
%                            [tcp-penalties <on|off>] \
%                            [server-learning-time <seconds>] \
%                            [server-ignore-limit <hit count>] \
%                            [server-scanner-limit <hit count>] \
%                            [alert-mode <once|all>] \
%                            [output-mode <msg|pktkludge>] \
%                            [base-score <integer>] \
%                            [dumpall <1>]    
%
%\end{verbatim}
%
%
%\begin{slist}
%\item \texttt{scoreboard-rows-talker} (Default value: 100000)
%
%Number of rows to use for the talker table. 
%
%\item \texttt{scoreboard-rows-scanner} (Default value: 250000)
%
%Number of rows to use for the scanner table. 
%
%\item \texttt{unique-rows} (Default value: 1000000)
%
%Number of rows to allocate for the uniqueness tracker.   
%
%\item \texttt{server-rows} (Default value: 65536)
%
%Number of rows to allocate for server learning. 
%
%A general note about rows: higher row counts will take more memory away
%from the memory caps for a specific subsystem.  In Snort output,
%this is referred to as ``overhead bytes'' and the percentage of overhead
%encountered will be shown.  Higher row counts provide a larger hash
%table to minimize collisions, with a faster overall processing time
%at the expense of memory.  The hash tables themselves use a pseudorandom
%hardening salt that is picked at initialization time.
%
%\item \texttt{scoreboard-memcap-talker} (Default value: 25165824)
%
%Number of bytes to use for the talker table. 
% 
%\item \texttt{scoreboard-memcap-scanner} (Default value: 6291456)
%
%Number of bytes to use for the scanner table. 
%
%\item \texttt{unique-memcap} (Default value: 25165824)
%
%Number of bytes to allocate to the uniqueness tracker. The more memory given,
%the less connections to a busy server will appear as a scan target on a
%popular service. 
%
%\item \texttt{server-memcap} (Default value: 2097152)
%
%Number of bytes to allocate for server learning. 
%
%\item \texttt{scanner-fixed-threshold} (Default value: 15)
%
%Number of points that a scanner must accumulate in the scanner-fixed-window
%time range.  Set to 0 to disable this type of alert. 
%
%\item \texttt{talker-fixed-threshold} (Default value: 15)
%
%Number of points that a scanner must accumulate in talker-fixed-window time
%range. Set to 0 to disable this type of alert. 
%
%\item \texttt{scanner-sliding-threshold} (Default Value 40)
%
%Number of points that a scanner must accumulate in scanner-sliding-window time
%range. set to 0 to disable this type of alert.
%
%\item \texttt{talker-sliding-threshold} (Default Value: 30)
%
%Number of points that a scanner must accumulate in talker-sliding-window time
%range. Set to 0 to disable this type of alert. 
%
%\item \texttt{scanner-fixed-window} (Default Value: 15)
%
%Number of seconds Flow-Portscan runs before resetting the fixed scanner score. 
%
%\item \texttt{talker-fixed-window} (Default Value: 30)
%
%Number of seconds Flow-Portscan runs before resetting the fixed talker score. 
%
%\item \texttt{scanner-sliding-window} (Default Value: 20)
%
%Number of seconds Flow-Portscan runs before resetting the sliding scanner score. 
%
%\item \texttt{talker-sliding-window} (Default Value: 30)
%
%Number of seconds Flow-Portscan runs before resetting the sliding talker score. 
%
%\item \texttt{scanner-sliding-scale-factor} (Default Value: 0.5)
%
%How much to increase the sliding window by each time we get a new sliding
%scanner entry.  Its current size + ($<$scale factor$>$ * current\_size). 
%
%\item \texttt{talker-sliding-scale-factor} (Default Value: 0.5)
%
%How much to increase the sliding window by each time we get a new sliding
%talker entry.  Its current size + ($<$scale factor$>$ * current\_size).  
%
%\item \texttt{src-ignore-net}
%
%The IP list of which source IPs to ignore.
%
%\item \texttt{dst-ignore-net}  
%
%The IP list of which destination IPs to ignore.
%
%\item \texttt{tcp-penalties} (Default Value: on)
%
%If this is enabled, when a new tcp flow enters the portscan detection set,
%Flow-Portscan checks the TCP flags for non-standard session initiators and assigns penalty
%points for odd combinations such as SYN+FIN. 
%
%\item \texttt{Flag Mapping}
%
%\begin{table}[!hbpt]
%\caption{Flag Mapping}
%\begin{center}\begin{tabular}{|c|c|}
%\hline 
%SYN or SYN+ECN bits &
%base\_score (defaults to 1 point) \\
%\hline 
%SYN+FIN+TH\_ACK and anything else & 5 points \\
%\hline 
%SYN+FIN and anything else without ACK & 3 points \\
%\hline 
%anything else & 2 points \\
%\hline
%\end{tabular}\end{center}
%\end{table}
%
%
%\item \texttt{server-watchnet} 
%
%The IP list of which machines to learn services on.  Busy servers should be
%placed here to help the portscan detector learn what services are requested on
%the network.
%
%\item \texttt{server-learning-time} (Default Value: 28800)
%
%Number of seconds Flow-Portscan should keep increment hitcounts of services on IPs in the
%server-watchnet.  
%
%This does not validate that the service is connected correctly. It is
%possible that, while learning, someone floods the table with unique connections,
%causing something to become a service that you do not wish to be a service.
%It's generally assumed that the learning time will occur at a time where
%traffic is ``typical.'' Future versions of Snort should allow this state to be
%saved and modifiable.  If this caveat is a concern in your environment, do not
%set a server watchnet and rely only on talker scores.
%
%\item \texttt{server-ignore-limit} (Default Value: 500)
%
%Number of requests a port on an IP in the server-watchnet must see
%before it is ignored for the purposes of portscans. 
%
%\item \texttt{server-scanner-limit} (Default Value: 500)
%
%Number of requests a port on an IP in the server-watchnet must see before it is
%is treated as a talker rather than a scanner.  This is the minimum number of
%requests that must be seen during the server-learning-time for the flow to be
%treated as a talker connection rather than as a scanner connection.  
%
%\item \texttt{alert-mode}
%
%\begin{table}[!hbpt]
%\caption{Alert Modes}
%\begin{center}\begin{tabular}{|c|p{5in}|}
%\hline 
%\texttt{once} & 
%Alert only on the first time Flow-Portscan sees a scan entry hit.  This dramatically reduces clutter because the scan alert in the first place tells one to look for other event types. Default Value: once.
%\\
%\hline 
%\texttt{all} & Alert each time the score increases beyond a threshold. \\
%\hline
%\end{tabular}\end{center}
%\end{table}
%
%\item \texttt{output-mode} (Default Value: msg)
%
%\begin{table}[!hbpt]
%\caption{Output Modes}
%\begin{center}\begin{tabular}{|c|c|}
%\hline 
%\texttt{msg} & Outputs a variable text message with the scores included.  \\
%\hline
%\texttt{pktkludge} & Generates a fake packet and uses the logging output system. \\
%\hline
%\end{tabular}\end{center}
%\end{table}
%
%\item \texttt{dumpall}
%When Snort is exiting, dump the entire contents of the server table,
%the uniqueness tracker table, and the scoreboard entries.  This is
%useful if you suspect an underlying bug in the algorithms used or if
%you would just like to see what it has learned. Set this to "1" to
%enable.
%            
%\item \texttt{base-score} (Default Value: 1)
%Default score for a new connection. This is probably only useful for
%debugging.
%
%\end{slist}
%
%\subsubsection{Example Configuration}
%
%\begin{verbatim}
%preprocessor flow-portscan: server-watchnet [10.0.0.0/8] \
%                            unique-memcap 5000000 \
%                            unique-rows 50000 \
%                            tcp-penalties on \
%                            server-scanner-limit 50 \
%                            alert-mode all \
%                            output-mode msg \
%                            server-learning-time 3600
%\end{verbatim}
%


\subsection{sfPortscan\label{sfportscan section}}

The sfPortscan module, developed by Sourcefire, is designed to detect the 
first phase in a network attack: Reconnaissance. In the Reconnaissance phase, 
an attacker determines
what types of network protocols or services a host supports. This is
the traditional place where a portscan takes place. This phase assumes
the attacking host has no prior knowledge of what protocols or
services are supported by the target; otherwise, this phase would not
be necessary.

As the attacker has no beforehand knowledge of its intended target,
most queries sent by the attacker will be negative (meaning that the
service ports are closed). In the nature of legitimate network
communications, negative responses from hosts are rare, and rarer
still are multiple negative responses within a given amount of time.
Our primary objective in detecting portscans is to detect and track
these negative responses.

One of the most common portscanning tools in use today is Nmap. Nmap
encompasses many, if not all, of the current portscanning techniques.
sfPortscan was designed to be able to detect the different types of
scans Nmap can produce.

sfPortscan will currently alert for the following types of Nmap scans:
\begin{itemize}
\item TCP Portscan
\item UDP Portscan
\item IP Portscan
\end{itemize}

These alerts are for one$\rightarrow$one portscans, which are the traditional
types of scans; one host scans multiple ports on another host. Most of
the port queries will be negative, since most hosts have relatively
few services available.

sfPortscan also alerts for the following types of decoy portscans:
\begin{itemize}
\item TCP Decoy Portscan
\item UDP Decoy Portscan
\item IP Decoy Portscan
\end{itemize}

Decoy portscans are much like the Nmap portscans described above, only the attacker has a spoofed
source address inter-mixed with the real scanning address. This tactic
helps hide the true identity of the attacker.

sfPortscan alerts for the following types of distributed portscans:
\begin{itemize}
\item TCP Distributed Portscan
\item UDP Distributed Portscan
\item IP Distributed Portscan
\end{itemize}

These are many$\rightarrow$one portscans. Distributed portscans occur when
multiple hosts query one host for open services. This is used to evade
an IDS and obfuscate command and control hosts.

\begin{note}
Negative queries will be distributed among scanning hosts, so
we track this type of scan through the scanned host.
\end{note}

sfPortscan alerts for the following types of portsweeps:
\begin{itemize}
\item TCP Portsweep
\item UDP Portsweep
\item IP Portsweep
\item ICMP Portsweep
\end{itemize}

These alerts are for one$\rightarrow$many portsweeps. One host scans a single port
on multiple hosts. This usually occurs when a new exploit comes out and the
attacker is looking for a specific service. 

\begin{note}
The characteristics of a portsweep scan may not result in many
negative responses. For example, if an attacker portsweeps a web farm
for port 80, we will most likely not see many negative responses.
\end{note}

sfPortscan alerts on the following filtered portscans and portsweeps:

\begin{itemize}
\item TCP Filtered Portscan
\item UDP Filtered Portscan
\item IP Filtered Portscan

\item TCP Filtered Decoy Portscan
\item UDP Filtered Decoy Portscan
\item IP Filtered Decoy Portscan

\item TCP Filtered Portsweep
\item UDP Filtered Portsweep
\item IP Filtered Portsweep
\item ICMP Filtered Portsweep

\item TCP Filtered Distributed Portscan
\item UDP Filtered Distributed Portscan
\item IP Filtered Distributed Portscan
\end{itemize}

``Filtered'' alerts indicate that there were no network errors (ICMP
unreachables or TCP RSTs) or responses on closed ports have been
suppressed. It's also a good indicator of whether the alert is just a
very active legitimate host. Active hosts, such as NATs, can trigger
these alerts because they can send out many connection attempts within
a very small amount of time. A filtered alert may go off before
responses from the remote hosts are received.

sfPortscan only generates one alert for each host pair in question during
the time window (more on windows below). On TCP scan alerts, sfPortscan
will also display any open ports that were scanned. On TCP sweep alerts
however, sfPortscan will only track open ports after the alert has been
triggered. Open port events are not individual alerts, but tags based
on the orginal scan alert.

\subsubsection{sfPortscan Configuration\label{sfportscan configuration}}

You may want to use the following line in your \texttt{snort.conf} to disable evasion alerts 
within stream4 because some
scan packets can cause these alerts to be generated:

\begin{verbatim}
  preprocessor stream4: disable_evasion_alerts
\end{verbatim}

Use of the Flow preprocessor is required for sfPortscan. Flow gives
portscan direction in the case of connectionless protocols like ICMP
and UDP. You should enable the Flow preprocessor in your \texttt{snort.conf} by 
using the following:

\begin{verbatim}
  preprocessor flow: stats_interval 0 hash 2
\end{verbatim}

The parameters you can use to configure the portscan module are:

\begin{slist}
\item \textbf{proto $<$protocol$>$}

  Available options:
  \begin{itemize}
    \item \texttt{TCP}
	\item \texttt{UDP}
	\item \texttt{IGMP}
	\item \texttt{ip\_proto}
	\item \texttt{all}
   \end{itemize}

\item \textbf{scan\_type $<$scan\_type$>$}

  Available options: 
   \begin{itemize}
	\item \texttt{portscan} 
	\item \texttt{portsweep} 
	\item \texttt{decoy\_portscan}
	\item \texttt{distributed\_portscan}
	\item \texttt{all}
	\end{itemize}

\item \textbf{sense\_level $<$level$>$}

  Available options:
  \begin{itemize}
	\item \texttt{low} - ``Low'' alerts are only generated on error packets sent from the
  target host, and because of the nature of error responses, this
  setting should see very few false postives. However, this setting
  will never trigger a Filtered Scan alert because of a lack of error
  responses. This setting is based on a static time window of 60
  seconds, afterwhich this window is reset.
	\item \texttt{medium} - ``Medium'' alerts track connection counts, and so will generate
  filtered scan alerts. This setting may false positive on active
  hosts (NATs, proxies, DNS caches, etc), so the user may need to
  deploy the use of Ignore directives to properly tune this directive.
	\item \texttt{high} - ``High'' alerts continuously track hosts on a network using a time
  window to evaluate portscan statistics for that host. A "High"
  setting will catch some slow scans because of the continuous
  monitoring, but is very sensitive to active hosts. This most
  definitely will require the user to tune sfPortscan.
  \end{itemize}

\item \textbf{watch\_ip $<$ip1$|$ip2/cidr[:[port$|$port2-port3]]$>$ }

  Defines which IPs, networks, and specific ports on those hosts to watch.
  The list is a comma seperated list of IP addresses, IP address using CIDR
  notation.  Optionally, ports are specified after the IP address/CIDR using
  a colon and can be either a single port or a range denoted by a dash.
  IPs or networks not falling into this range are ignored if this option
  is used.

\item \textbf{ignore\_scanners $<$ip\_list$>$ }

  Ignores the source of scan alerts.  \texttt{ip\_list} can be a comma
  seperated list of IP addresses or IP addresses using CIDR notation.

\item \textbf{ignore\_scanned $<$ip\_list$>$ }

  Ignores the destination of scan alerts. \texttt{ip\_list} can be a comma
  seperated list of IP addresses or IP addresses using CIDR notation.

\item \textbf{logfile $<$file$>$ } 

  This option will output portscan events to the file specified. If
  \texttt{file} does not contain a leading slash, this file will be placed in
  the Snort config dir.
\end{slist}

\subsubsection{Format}

\begin{verbatim}
preprocessor sfportscan: proto <protocols> \
scan_type <portscan|portsweep|decoy_portscan|distributed_portscan|all>\
sense_level <low|medium|high> watch_ip <IP or IP/CIDR> ignore_scanners <IP list>\
ignore_scanned <IP list> logfile <path and filename>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
	preprocessor flow: stats_interval 0 hash 2
	preprocessor sfportscan: proto { all } \
    scan_type { all } \
    sense_level { low }
\end{verbatim}
\caption{sfPortscan Preprocessor Configuration \label{sfPortscan Example}}
\end{figure}


\subsubsection{sfPortscan Alert Output\label{sfportscan alert output}}

\paragraph{Unified Output}


In order to get all the portscan information logged with the alert, snort
generates a pseudo-packet and uses the payload portion to store the additional
portscan information of priority count, connection count, IP count, port count,
IP range, and port range.  The characteristics of the packet are:

\begin{verbatim}
Src/Dst MAC Addr == MACDAD
IP Protocol == 255
IP TTL == 0
\end{verbatim}

Other than that, the packet looks like the IP portion of the packet that caused
the portscan alert to be generated.  This includes any IP options, etc.  The
payload and payload size of the packet are equal to the length of the additional
portscan information that is logged.  The size tends to be around 100 - 200
bytes.

Open port alerts differ from the other portscan alerts, because open port alerts
utilize the tagged packet output system.  This means that if an output system
that doesn't print tagged packets is used, then the user won't see open port
alerts.  The open port information is stored in the IP payload and
contains the port that is open.

The sfPortscan alert output was designed to work with unified packet logging, so
it is possible to extend favorite Snort GUIs to display portscan alerts and the
additional information in the IP payload using the above packet characteristics.

\paragraph{Log File Output}

Log file output is displayed in the following format, and explained further
below:

\begin{verbatim}
	Time: 09/08-15:07:31.603880
	event_id: 2
	192.168.169.3 -> 192.168.169.5 (portscan) TCP Filtered Portscan
	Priority Count: 0
	Connection Count: 200
	IP Count: 2
	Scanner IP Range: 192.168.169.3:192.168.169.4
	Port/Proto Count: 200
	Port/Proto Range: 20:47557
\end{verbatim}

If there are open ports on the target, one or more additional tagged packet(s)
will be appended:

\begin{verbatim}
	Time: 09/08-15:07:31.603881
	event_ref: 2
	192.168.169.3 -> 192.168.169.5 (portscan) Open Port
	Open Port: 38458
\end{verbatim}

\begin{slist}
  \item \textbf{Event\_id/Event\_ref}

     These fields are used to link an alert with the corresponding 
     \texttt{Open Port} tagged packet

  \item \textbf{Priority Count}

     \texttt{Priority Count} keeps track of bad responses (resets,
     unreachables). The higher the priority count, the more bad
     responses have been received.

  \item \textbf{Connection Count}
     
     \texttt{Connection Count} lists how many connections are active on the
     hosts (src or dst). This is accurate for connection-based
     protocols, and is more of an estimate for others. Whether or not a
     portscan was filtered is determined here. High connection count and
     low priority count would indicate filtered (no response received
     from target).

  \item \textbf{IP Count}

     IP Count keeps track of the last IP to contact a host, and
     increments the count if the next IP is different. For one-to-one
     scans, this is a low number. For active hosts this number will
     be high regardless, and one-to-one scans may appear as a
     distributed scan.

  \item \textbf{Scanned/Scanner IP Range}

     This field changes depending on the type of alert. Portsweep
     (one-to-many) scans display the scanned IP range; Portscans
     (one-to-one) display the scanner IP. 

 \item \textbf{Port Count}

     Port Count keeps track of the last port contacted and increments
     this number when that changes. We use this count (along with IP
     Count) to determine the difference between one-to-one portscans
     and one-to-one decoys.
\end{slist}

\subsubsection{Tuning sfPortscan\label{tuning sfportscan}}

The most important aspect in detecting portscans is tuning the detection engine
for your network(s).  Here are some tuning tips:

\begin{slist}

\item \textbf{Use the watch\_ip, ignore\_scanners, and ignore\_scanned options.}
  
     It's important to correctly set these options.  The \texttt{watch\_ip} option is easy
     to understand.  The analyst should set this option to the list of Cidr 
     blocks and IPs that they want to watch.  If no \texttt{watch\_ip} is defined, 
     sfPortscan will watch all network traffic.
     
     The \texttt{ignore\_scanners} and \texttt{ignore\_scanned} options come into play in weeding
     out legitimate hosts that are very active on your network.  Some of the
     most common examples are NAT IPs, DNS cache servers, syslog servers, and
     nfs servers.  sfPortscan may not generate false positives for these types
     of hosts, but be aware when first tuning sfPortscan for these IPs. 
     Depending on the type of alert that the host generates, the analyst will
     know which to ignore it as.  If the host is generating portsweep events,
     then add it to the \texttt{ignore\_scanners} option.  If the host is generating
     portscan alerts (and is the host that is being scanned), add it to the
     \texttt{ignore\_scanned} option.
  
\item \textbf{Filtered scan alerts are much more prone to false positives.}
  
     When determining false positives, the alert type is very important.  Most of
     the false positives that sfPortscan may generate are of the filtered scan
     alert type.  So be much more suspicious of filtered portscans.  Many times
     this just indicates that a host was very active during the time period in
     question.  If the host continually generates these types of alerts, add it
     to the \texttt{ignore\_scanners} list or use a lower sensitivity level.
     
\item \textbf{Make use of the Priority Count, Connection Count, IP Count, Port Count, IP Range, and Port Range to determine false positives.}
     
     The portscan alert details are vital in determining the scope of a portscan
     and also the confidence of the portscan.  In the future, we hope to
     automate much of this analysis in assigning a scope level and confidence
     level, but for now the user must manually do this.  The easiest way to
     determine false positives is through simple ratio estimations.  The
     following is a list of ratios to estimate and the associated values that
     indicate a legimite scan and not a false positive.
     
     \textbf{Connection Count / IP Count:}  This ratio indicates an estimated average of
     connections per IP.  For portscans, this ratio should be high, the higher
     the better.  For portsweeps, this ratio should be low.
     
     \textbf{Port Count / IP Count:}  This ratio indicates an estimated average of ports
     connected to per IP.  For portscans, this ratio should be high and
     indicates that the scanned host's ports were connected to by fewer IPs. 
     For portsweeps, this ratio should be low, indicating that the scanning host
     connected to few ports but on many hosts.
     
     \textbf{Connection Count / Port Count:}  This ratio indicates an estimated average
     of connections per port.  For portscans, this ratio should be low.  This
     indicates that each connection was to a different port.  For portsweeps,
     this ratio should be high.  This indicates that there were many connections
     to the same port.
     
     The reason that \texttt{Priority Count} is not included, is because the priority
     count is included in the connection count and the above comparisons take
     that into consideration.  The Priority Count play an important role in
     tuning because the higher the priority count the more likely it is a real
     portscan or portsweep (unless the host is firewalled).
     
\item \textbf{If all else fails, lower the sensitivity level.}
     
     If none of these other tuning techniques work or the analyst doesn't have
     the time for tuning, lower the sensitivity level.  You get the best
     protection the higher the sensitivity level, but it's also important that
     the portscan detection engine generate alerts that the analyst will find
     informative.  The low sensitivity level only generates alerts based on
     error responses.  These responses indicate a portscan and the alerts
     generated by the low sensitivity level are highly accurate and require the
     least tuning.  The low sensitivity level does not catch filtered scans;
     since these are more prone to false positives.
\end{slist}

\subsection{Telnet Decode\label{sub:telnet-decode}}

The \texttt{telnet\_decode} preprocessor allows Snort to normalize Telnet control
protocol characters from the session data. In Snort 1.9.0 and above,
it accepts a list of ports to run on as arguments. Also in 1.9.0,
it normalizes into a separate data buffer from the packet itself so
that the raw data may be logged or examined with the \texttt{rawbytes} content
modifier.  See section \ref{sub:rawbytes}.

By default, \texttt{telnet\_decode} runs against traffic on ports 21, 23, 25, and 119.

\subsubsection{Format}

\begin{verbatim}
preprocessor telnet_decode: <ports> 
\end{verbatim}

\begin{note}
The \texttt{telnet\_decode} preprocessor is being deprecated in the next
release in favor of the FTP/Telnet preprocessor.  See section \ref{sub:ftptelnet}.
\end{note}

\subsection{RPC Decode\label{sub:rpc-decoder}}

The rpc\_decode preprocessor normalizes RPC multiple fragmented
records into a single un-fragmented record.  It does this by
normalizing the packet into the packet buffer.  If stream4 is
enabled, it will only process client-side traffic.  By default, it runs against
traffic on ports 111 and 32771.

\begin{table}[!hbpt]

\caption{RPC Decoder Options\label{rpc options}}

\begin{center}\begin{tabular}{| l | l |}
\hline 
\textbf{Option}&
\textbf{Description}\\
\hline
\hline 
\texttt{alert\_fragments}&
Alert on any fragmented RPC record.\\
\hline 
\texttt{no\_alert\_multiple\_requests}&
Don't alert when there are multiple records in one packet.\\
\hline 
\texttt{no\_alert\_large\_fragments}&
Don't alert when the sum of fragmented records exceeds one packet.\\
\hline 
\texttt{no\_alert\_incomplete}&
Don't alert when a single fragment record exceeds the size of one
packet.\\
\hline
\end{tabular}\end{center}
\end{table}

\subsubsection{Format}

\begin{verbatim}
preprocessor rpc_decode: <ports> [ alert_fragments ] \
   [no_alert_multiple_requests] [no_alert_large_fragments] \
   [no_alert_incomplete]
\end{verbatim}

\subsection{Performance Monitor\label{sub:perfmonitor}}

This preprocessor measures Snort's real-time and theoretical maximum
performance.  Whenever this preprocessor is turned on, it should have an output
mode enabled, either ``console'' which prints statistics to the console window or
``file'' with a file name, where statistics get printed to the specified file
name. By default, Snort's real-time statistics are processed. This includes:

\begin{itemize}
\item Time Stamp
\item Drop Rate
\item Mbits/Sec (wire) [duplicated below for easy comparison with other rates]
\item Alerts/Sec 
\item K-Pkts/Sec (wire) [duplicated below for easy comparison with other rates]
\item Avg Bytes/Pkt (wire) [duplicated below for easy comparison with other rates]
\item Pat-Matched [percent of data received that Snort processes in pattern matching]
\item Syns/Sec
\item SynAcks/Sec
\item New Sessions Cached/Sec
\item Sessions Del fr Cache/Sec
\item Current Cached Sessions
\item Max Cached Sessions
\item Stream Flushes/Sec
\item Stream Session Cache Faults
\item Stream Session Cache Timeouts
\item New Frag Trackers/Sec
\item Frag-Completes/Sec
\item Frag-Inserts/Sec
\item Frag-Deletes/Sec
\item Frag-Auto Deletes/Sec [memory DoS protection]
\item Frag-Flushes/Sec
\item Frag-Current [number of current Frag Trackers]
\item Frag-Max [max number of Frag Trackers at any time]
\item Frag-Timeouts
\item Frag-Faults
\item Number of CPUs [*** Only if compiled with LINUX\_SMP ***, the next three appear for each CPU]
\item CPU usage (user)
\item CPU usage (sys)
\item CPU usage (Idle)
\item Mbits/Sec (wire) [average mbits of total traffic]
\item Mbits/Sec (ipfrag) [average mbits of IP fragmented traffic]
\item Mbits/Sec (ipreass) [average mbits Snort injects after IP reassembly]
\item Mbits/Sec (tcprebuilt) [average mbits Snort injects after stream4 reassembly]
\item Mbits/Sec (applayer) [average mbits seen by rules and protocol decoders]
\item Avg Bytes/Pkt (wire)
\item Avg Bytes/Pkt (ipfrag)
\item Avg Bytes/Pkt (ipreass)
\item Avg Bytes/Pkt (tcprebuilt)
\item Avg Bytes/Pkt (applayer)
\item K-Pkts/Sec (wire)
\item K-Pkts/Sec (ipfrag)
\item K-Pkts/Sec (ipreass)
\item K-Pkts/Sec (tcprebuilt)
\item K-Pkts/Sec (applayer)
\item Total Packets Received
\item Total Packets Dropped (not processed)
\item Total Packets Blocked (inline)
\end{itemize}

The following options can be used with the performance monitor:

\begin{itemize}
\item \texttt{flow} - Prints out statistics about the type
of traffic and protocol distributions that Snort is seeing. This option can
produce large amounts of output.

\item \texttt{events} - Turns on event reporting.  This prints out statistics as
to the number of signatures that were matched by the setwise pattern matcher 
(\textit{non-qualified events}) and the number of those matches that were 
verified with the signature flags (\textit{qualified events}).
This shows the user if there
is a problem with the rule set that they are running.

\item \texttt{max} - Turns on the theoretical maximum performance that Snort
calculates given the processor speed and current performance.  This is only
valid for uniprocessor machines, since many operating systems don't keep
accurate kernel statistics for multiple CPUs.  

\item \texttt{console} - Prints statistics at the console.  This is enabled by default.  

\item \texttt{file} - Prints statistics in a comma-delimited format to the file
that is specified.  Not all statistics are output to this file.  You may
also use \texttt{snortfile} which will output into your defined Snort log
directory.  Both of these directives can be overridden on the command
line with the \texttt{-Z} or \texttt{--perfmon-file} options.

\item \texttt{pktcnt} - Adjusts the number of packets to process before checking for
the time sample.  This boosts performance, since checking the time sample
reduces Snort's performance.  By default, this is 10000.  

\item \texttt{time} - Represents the number of seconds between intervals.

\item \texttt{accumulate} or \texttt{reset} - Defines which type of drop statistics
are kept by the operating system. By default, \texttt{accumulate} is used.

\item \texttt{atexitonly} - Dump stats for entire life of Snort.

\end{itemize}
\subsubsection{Examples}

\begin{verbatim}
preprocessor perfmonitor: time 30 events flow file stats.profile max \
    console pktcnt 10000 
preprocessor perfmonitor: time 300 file /var/tmp/snortstat pktcnt 10000
\end{verbatim}

\subsection{HTTP Inspect \label{sub:http-inspect}}

HTTP Inspect is a generic HTTP decoder for user applications.  Given a data
buffer, HTTP Inspect will decode the buffer, find HTTP fields, and normalize the
fields.  HTTP Inspect works on both client requests and server responses.

The current version of HTTP Inspect only handles stateless processing.  This
means that HTTP Inspect looks for HTTP fields on a packet-by-packet basis, and
will be fooled if packets are not reassembled.  This works fine when there is
another module handling the reassembly, but there are limitations in analyzing
the protocol.  Future versions will have a stateful processing mode which will
hook into various reassembly modules.

HTTP Inspect has a very ``rich'' user configuration.  Users can configure
individual HTTP servers with a variety of options, which should allow the user
to emulate any type of web server. Within HTTP Inspect, there are two areas of
configuration: global and server.

\subsubsection{Global Configuration}

The global configuration deals with configuration options that determine the
global functioning of HTTP Inspect.  The following example gives the generic
global configuration format:

\subsubsection{Format}
\begin{verbatim}
preprocessor http_inspect: global \
                           iis_unicode_map <map_filename> \
                           codemap <integer> \
                           [detect_anomalous_servers] \
                           [proxy_alert]
\end{verbatim}

You can only have a single global configuration, you'll get an error if you try
otherwise.

\paragraph{Configuration}
\begin{slist}
\item \texttt{iis\_unicode\_map $<$map\_filename$>$ [codemap $<$integer$>$]}

This is the global \texttt{iis\_unicode\_map} file.  The \texttt{iis\_unicode\_map} is a required
configuration parameter.  The map file can reside in the same directory as
\texttt{snort.conf} or be specified via a fully-qualified path to the map file.

The \texttt{iis\_unicode\_map} file is a Unicode codepoint map which tells HTTP Inspect
which codepage to use when decoding Unicode characters.  For US servers, the
codemap is usually 1252.

A Microsoft US Unicode codepoint map is provided in the Snort source \texttt{etc}
directory by default.  It is called \texttt{unicode.map} and should be used if no
other codepoint map is available.  A tool is supplied with Snort to generate
custom Unicode \texttt{maps--ms\_unicode\_generator.c}, which is available at
\url{http://www.snort.org/dl/contrib/}.

\begin{note}
Remember that this configuration is for the global IIS Unicode map, individual
servers can reference their own IIS Unicode map.
\end{note}

\item \texttt{detect\_anomalous\_servers}

This global configuration option enables generic HTTP server traffic
inspection on non-HTTP configured ports, and alerts if HTTP traffic is seen.
Don't turn this on if you don't have a default server configuration that
encompasses all of the HTTP server ports that your users might access.  In the
future, we want to limit this to specific networks so it's more useful, but
for right now, this inspects all network traffic.

\item \texttt{proxy\_alert}

This enables global alerting on HTTP server proxy usage.  By configuring
HTTP Inspect servers and enabling \texttt{allow\_proxy\_use}, you will only receive proxy
use alerts for web users that aren't using the configured proxies or are using
a rogue proxy server.

Please note that if users aren't required to configure web proxy use, then
you may get a lot of proxy alerts.  So, please only use this feature with
traditional proxy environments. Blind firewall proxies don't count.

\end{slist}
\subsubsection{Example Global Configuration}

\begin{verbatim}
preprocessor http_inspect: global iis_unicode_map unicode.map 1252
\end{verbatim}

\subsubsection{Server Configuration}
There are two types of server configurations: default and by IP address.

\paragraph{Default}

This configuration supplies the default server configuration for any server
that is not individually configured.  Most of your web servers will most likely
end up using the default configuration.

\subsubsection{Example Default Configuration}
\begin{verbatim}
preprocessor http_inspect_server: server default profile all ports { 80 }
\end{verbatim}

\paragraph{Configuration by IP Address}
This format is very similar to ``default'', the only difference being that
specific IPs can be configured.

\subsubsection{Example IP Configuration}
\begin{verbatim}
preprocessor http_inspect_server: server 10.1.1.1 profile all ports { 80 }
\end{verbatim}

\subsubsection{Server Configuration Options}

Important: Some configuration options have an argument of `yes' or `no'.  This
argument specifies whether the user wants the configuration option to generate
an HTTP Inspect alert or not.  The `yes/no' argument does not specify whether
the configuration option itself is on or off, only the alerting functionality.
In other words, whether set to `yes' or 'no', HTTP normalization will still
occur, and rules based on HTTP traffic will still trigger.

\begin{slist}
\item \texttt{profile $<$all$|$apache$|$iis$>$}

Users can configure HTTP Inspect by using pre-defined HTTP server profiles.
Profiles allow the user to easily configure the preprocessor for a certain
type of server, but are not required for proper operation. 

There are three profiles available: all, apache, and iis.

\begin{subslist}

\item \texttt{all}

The \texttt{all} profile is meant to normalize the URI using most of the common tricks
available.  We alert on the more serious forms of evasions.  This is a great
profile for detecting all types of attacks, regardless of the HTTP server.
\texttt{profile all} sets the configuration options described in Table \ref{profile_all_options}.

\begin{table}[!bthp]
\caption{Options for the ``all'' Profile\label{profile_all_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Setting} \\
\hline
\hline
flow\_depth & 300 \\
\hline
chunk encoding & alert on chunks larger than 500000 bytes \\
\hline
iis\_unicode\_map & codepoint map in the global configuration \\
\hline
ascii decoding & on, alert off \\
\hline
%looking for null bytes in url & on, alert on \\
%\hline
multiple slash & on, alert off \\
\hline
directory normalization & on, alert off \\
\hline
apache whitespace & on, alert off \\
\hline
double decoding & on, alert on \\
\hline
\%u decoding & on, alert on \\
\hline
bare byte decoding & on, alert on \\
\hline
iis unicode codepoints & on, alert on \\
\hline
iis backslash & on, alert off \\
\hline
iis delimiter & on, alert off \\
\hline
webroot & on, alert on\\
\hline
non\_strict URL parsing & on\\
\hline
tab\_uri\_delimiter & is set\\
\hline
\end{tabular}\end{center}
\end{table}


\item \texttt{apache} 

The \texttt{apache} profile is used for Apache web servers.  This differs from the
\texttt{iis} profile by only accepting UTF-8 standard Unicode encoding and not
accepting backslashes as legitimate slashes, like IIS does.  Apache also
accepts tabs as whitespace.  \texttt{profile apache} sets the configuration
options described in Table \ref{profile_apache_options}.

\begin{table}[!hbpt]
\caption{Options for the \texttt{apache} Profile\label{profile_apache_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Setting}\\
\hline
\hline
flow\_depth & 300 \\
\hline
chunk encoding & alert on chunks larger than 500000 bytes \\
\hline
ascii decoding & on, alert off \\
%\hline
%looking for null bytes in url & on, alert on \\
\hline
multiple slash & on, alert off \\
\hline
directory normalization & on, alert off \\
\hline
webroot & on, alert on\\
\hline
apache whitespace & on, alert on \\
\hline
utf\_8 encoding & on, alert off \\
\hline
non\_strict url parsing & on \\
\hline
tab\_uri\_delimiter & is set\\
\hline
\end{tabular}\end{center}
\end{table}

\item \texttt{iis}

The \texttt{iis} profile mimics IIS servers.  So that means we use IIS Unicode
codemaps for each server, \%u encoding, bare-byte encoding, double decoding,
backslashes, etc. \texttt{profile iis} sets the configuration options described in
Table \ref{profile_iis_options}.

\begin{table}[!hbpt]
\caption{Options for the \texttt{iis} Profile\label{profile_iis_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Setting}\\
\hline
\hline
flow\_depth & 300 \\
\hline
chunk encoding & alert on chunks larger than 500000 bytes\\
\hline
iis\_unicode\_map & codepoint map in the global configuration \\
\hline
ascii decoding & on, alert off \\
\hline
multiple slash & on, alert off \\
\hline
directory normalization & on, alert off \\
\hline
webroot & on, alert on\\
\hline
double decoding & on, alert on \\
\hline
\%u decoding & on, alert on \\
\hline
bare byte decoding & on, alert on \\
\hline
iis unicode codepoints & on, alert on \\
\hline
iis backslash & on, alert off \\
\hline
iis delimiter & on, alert on \\
\hline
apache whitespace & on, alert on \\
\hline
non\_strict URL parsing & on\\
\hline
\end{tabular}\end{center}
\end{table}

The default options used by HTTP Inspect do not use a profile and are described 
in Table \ref{default_HTTP_Inspect_options}.

\begin{table}[!hbpt]
\caption{Default HTTP Inspect Options\label{default_HTTP_Inspect_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Setting}\\
\hline
\hline
port & 80\\
\hline
flow\_depth & 300 \\
\hline
chunk encoding & alert on chunks larger than 500000 bytes\\
\hline
ascii decoding & on, alert off \\
\hline
utf\_8 encoding & on, alert off\\
\hline
multiple slash & on, alert off \\
\hline
directory normalization & on, alert off \\
\hline
webroot & on, alert on\\
\hline
iis backslash & on, alert off \\
\hline
apache whitespace & on, alert off \\
\hline
iis delimiter & on, alert off \\
\hline
non\_strict URL parsing & on\\
\hline
\end{tabular}\end{center}
\end{table}
\clearpage
Profiles must be specified as the first server option and cannot be combined
with any other options except:
\begin{itemize}
\item \texttt{ports}
\item \texttt{iis\_unicode\_map}
\item \texttt{allow\_proxy\_use}
\item \texttt{flow\_depth}
\item \texttt{no\_alerts}
\item \texttt{inspect\_uri\_only}
\item \texttt{oversize\_dir\_length} 
\end{itemize}
These options must be specified after the \texttt{profile} option.
\end{subslist}

\subsubsection{Example}
\begin{verbatim}
preprocessor http_inspect_server: server 1.1.1.1 profile all ports { 80 3128 }
\end{verbatim}
                             
\item \texttt{ports $\{ <$port$> [<$port$> <...>] \}$}

This is how the user configures which ports to decode on the HTTP server.
Encrypted traffic (SSL) cannot be decoded, so adding port 443 will only
yield encoding false positives.

\item \texttt{iis\_unicode\_map $<$map\_filename$>$ codemap $<$integer$>$}

The IIS Unicode map is generated by the program ms\_unicode\_generator.c.  This
program is located on the Snort.org web site at \url{http://www.snort.org/dl/contrib/}
directory.  Executing this program
generates a Unicode map for the system that it was run on.  So, to get the
specific Unicode mappings for an IIS web server, you run this program on that
server and use that Unicode map in this configuration.

When using this option, the user needs to specify the file that contains the
IIS Unicode map and also specify the Unicode map to use.  For US servers, this
is usually 1252.  But the ms\_unicode\_generator program tells you which codemap
to use for you server; it's the ANSI code page.  You can select the correct code
page by looking at the available code pages that the ms\_unicode\_generator
outputs.

\item \texttt{flow\_depth $<$integer$>$}

This specifies the amount of server response payload to inspect.  This option
significantly increases IDS performance because we are ignoring a large part of
the network traffic (HTTP server response payloads).  A small percentage of
Snort rules are targeted at this traffic and a small flow\_depth value may
cause false negatives in some of these rules.  Most of these rules target
either the HTTP header, or the content that is likely to be in the first
hundred or so bytes of non-header data.  Headers are usually under 300 bytes
long, but your mileage may vary.

This value can be set from -1 to 1460. A value of -1 causes Snort to
ignore all server side traffic for ports defined in \texttt{ports}.
Inversely, a value of 0 causes Snort to inspect all HTTP server payloads
defined in \texttt{ports} (note that this will likely slow down IDS
performance).  Values above 0 tell Snort the number of bytes to inspect
in the first packet of the server response.

\item \texttt{ascii $<$yes$|$no$>$}

The \texttt{ascii} decode option tells us whether to decode encoded ASCII chars, a.k.a
\%2f = /, \%2e = ., etc.  It is normal to see ASCII encoding usage in URLs, so it
is recommended that you disable HTTP Inspect alerting for this option.

\item \texttt{utf\_8 $<$yes$|$no$>$}

The \texttt{utf-8} decode option tells HTTP Inspect to decode standard UTF-8 Unicode
sequences that are in the URI.  This abides by the Unicode standard and only
uses \% encoding.  Apache uses this standard, so for any Apache servers, make
sure you have this option turned on.  As for alerting, you may be interested in
knowing when you have a UTF-8 encoded URI, but this will be prone to false
positives as legitimate web clients use this type of encoding.  When \texttt{utf\_8} is
enabled, ASCII decoding is also enabled to enforce correct functioning.  

\item \texttt{u\_encode $<$yes$|$no$>$}

This option emulates the IIS \%u encoding scheme.  How the \%u encoding scheme
works is as follows:  the encoding scheme is started by a \%u followed by 4
characters, like \%uxxxx.  The xxxx is a hex-encoded value that correlates to an IIS
Unicode codepoint.  This value can most definitely be ASCII.  An ASCII character is
encoded like \%u002f = /, \%u002e = ., etc.  If no iis\_unicode\_map is specified
before or after this option, the default codemap is used.

You should alert on \%u encodings, because we are not aware of any legitimate
clients that use this encoding.  So it is most likely someone trying to be
covert.

\item \texttt{bare\_byte $<$yes$|$no$>$}

Bare byte encoding is an IIS trick that uses non-ASCII characters as valid values when
decoding UTF-8 values.  This is not in the HTTP standard, as all non-ASCII
values have to be encoded with a \%.  Bare byte encoding allows the user to
emulate an IIS server and interpret non-standard encodings correctly.

The alert on this decoding should be enabled, because there are no legitimate
clients that encode UTF-8 this way since it is non-standard.

\item \texttt{base36 $<$yes$|$no$>$}

This is an option to decode base36 encoded chars.  This option is based on of
info from 
\url{http://www.yk.rim.or.jp/~shikap/patch/spp\_http\_decode.patch}.

If \%u encoding is enabled, this option will not work.  You have to use the
\texttt{base36} option with the \texttt{utf\_8} option.  Don't use the \%u option, because base36
won't work.  When \texttt{base36} is enabled, ASCII encoding is also enabled to enforce correct
behavior.

\item \texttt{iis\_unicode $<$yes$|$no$>$}

The \texttt{iis\_unicode} option turns on the Unicode codepoint mapping.  If there is no
iis\_unicode\_map option specified with the server config, \texttt{iis\_unicode} uses the
default codemap.  The \texttt{iis\_unicode} option handles the mapping of non-ASCII
codepoints that the IIS server accepts and decodes normal UTF-8 requests.

You should alert on the \texttt{iis\_unicode option}, because it is seen mainly in
attacks and evasion attempts.  When \texttt{iis\_unicode} is enabled, ASCII and
UTF-8 decoding are also enabled to enforce correct decoding.  To alert on UTF-8 decoding, you
 must enable also enable \texttt{utf\_8 yes}. 

\item \texttt{double\_decode $<$yes$|$no$>$}
The \texttt{double\_decode} option is once again IIS-specific and emulates IIS
functionality.  How this works is that IIS does two passes through the request
URI, doing decodes in each one.  In the first pass, it seems that all types of
iis encoding is done: utf-8 unicode, ascii, bare byte, and \%u.  In the second
pass, the following encodings are done:  ascii, bare byte, and \%u.  We leave out
utf-8 because I think how this works is that the \% encoded utf-8 is decoded to
the Unicode byte in the first pass, and then UTF-8 is decoded in the second stage.
Anyway, this is really complex and adds tons of different encodings for one
character.  When \texttt{double\_decode} is enabled, so ASCII is also enabled to enforce correct decoding.

\item \texttt{non\_rfc\_char $\{ <$byte$> [<$byte ...$>] \}$}

This option lets users receive an alert if certain non-RFC chars are used in a
request URI.  For instance, a user may not want to see null bytes in the
request URI and we can alert on that.  Please use this option with
care, because you could configure it to say, alert on all `/' or something like
that.  It's flexible, so be careful.

\item \texttt{multi\_slash $<$yes$|$no$>$}

This option normalizes multiple slashes in a row, so something like:
``foo/////////bar'' get normalized to ``foo/bar.''

If you want an alert when multiple slashes are seen, then configure with a \texttt{yes}; otherwise, use \texttt{no}.

\item \texttt{iis\_backslash $<$yes$|$no$>$}

Normalizes backslashes to slashes.  This is again an IIS emulation.  So a
request URI of ``/foo$\backslash$bar'' gets normalized to ``/foo/bar.''

\item \texttt{directory $<$yes$|$no$>$}

This option normalizes directory traversals and self-referential directories.

The directory:
\begin{verbatim} /foo/fake\_dir/../bar \end{verbatim}
gets normalized to:
\begin{verbatim} /foo/bar \end{verbatim}

The directory:
\begin{verbatim} /foo/./bar \end{verbatim}
gets normalized to:
\begin{verbatim} /foo/bar \end{verbatim}

If you want to configure an alert, specify \texttt{yes}, otherwise, specify \texttt{no}.  This alert may give false positives, since some web sites refer to files using directory traversals.

\item \texttt{apache\_whitespace $<$yes$|$no$>$}

This option deals with the non-RFC standard of using tab for a space delimiter.  Apache
uses this, so if the emulated web server is Apache, enable this
option.  Alerts on this option may be interesting, but may also be false
positive prone.

\item \texttt{iis\_delimiter $<$yes$|$no$>$}

This started out being IIS-specific, but Apache takes this non-standard
delimiter was well.  Since this is common, we always take this as standard
since the most popular web servers accept it.  But you can still get an alert
on this option.

\item \texttt{chunk\_length $<$non-zero positive integer$>$}

This option is an anomaly detector for abnormally large chunk sizes.  This
picks up the Apache chunk encoding exploits, and may also alert on HTTP
tunneling that uses chunk encoding.

\item \texttt{no\_pipeline\_req}

This option turns HTTP pipeline decoding off, and is a performance enhancement
if needed.  By default, pipeline requests are inspected for attacks, but when
this option is enabled, pipeline requests are not decoded and analyzed per
HTTP protocol field.  It is only inspected with the generic pattern
matching.

\item \texttt{non\_strict}

This option turns on non-strict URI parsing for the broken way in which Apache
servers will decode a URI.  Only use this option on servers that will accept
URIs like this: "get /index.html alsjdfk alsj lj aj  la jsj s$\backslash$n".  The
non\_strict option assumes the URI is between the first and second space even if
there is no valid HTTP identifier after the second space.

\item \texttt{allow\_proxy\_use}

By specifying this keyword, the user is allowing proxy use on this server.
This means that no alert will be generated if the \texttt{proxy\_alert} global keyword
has been used.  If the proxy\_alert keyword is not enabled, then this option
does nothing.  The \texttt{allow\_proxy\_use} keyword is just a way to suppress
unauthorized proxy use for an authorized server.  

\item \texttt{no\_alerts}

This option turns off all alerts that are generated by the HTTP Inspect
preprocessor module.  This has no effect on HTTP rules in the rule set.  No
argument is specified.

\item \texttt{oversize\_dir\_length $<$non-zero positive integer$>$}

This option takes a non-zero positive integer as an argument.  The argument
specifies the max char directory length for URL directory.  If a url directory
is larger than this argument size, an alert is generated. A good argument
value is 300 characters.  This should limit the alerts to IDS evasion type attacks,
like whisker -i 4.

\item \texttt{inspect\_uri\_only}

This is a performance optimization.  When enabled, only the URI portion of HTTP
requests will be inspected for attacks.  As this field usually contains 90-95\%
of the web attacks, you'll catch most of the attacks.  So if you need extra
performance, enable this optimization.  It's important to note that if
this option is used without any \texttt{uricontent} rules, then no inspection will take
place.  This is obvious since the URI is only inspected with \texttt{uricontent} rules,
and if there are none available, then there is nothing to inspect.

For example, if we have the following rule set:

\begin{verbatim}
alert tcp any any -> any 80 ( msg:"content"; content: "foo"; )
\end{verbatim}

and the we inspect the following URI:
\begin{verbatim}
get /foo.htm http/1.0\r\n\r\n
\end{verbatim}

No alert will be generated when \texttt{inspect\_uri\_only} is enabled.  The
\texttt{inspect\_uri\_only} configuration turns off all forms of detection except
\texttt{uricontent} inspection.

\item \texttt{webroot $<$yes$|$no$>$}

This option generates an alert when a directory traversal traverses past
the web server root directory.  This generates much fewer false positives than
the directory option, because it doesn't alert on directory traversals that
stay within the web server directory structure.  It only alerts when the
directory traversals go past the web server root directory, which
is associated with certain web attacks.

\item \texttt{tab\_uri\_delimiter}

This option turns on the use of the tab character (0x09) as a delimiter for
a URI.  Apache accepts tab as a delimiter; IIS does not.  For IIS, a tab in
the URI should be treated as any other character.  Whether this option is on
or not, a tab is treated as whitespace if a space character (0x20) precedes it.
No argument is specified.

\end{slist}

\subsubsection{Examples}

\begin{verbatim}
preprocessor http_inspect_server: server 10.1.1.1 \
                        ports { 80 3128 8080 } \
                        flow_depth 0 \
                        ascii no \
                        double_decode yes \
                        non_rfc_char { 0x00 } \
                        chunk_length 500000 \
                        non_strict \
                        no_alerts

preprocessor http_inspect_server: server default \ 
                        ports  { 80 3128 }  \
                        non_strict \
                        non_rfc_char  { 0x00 }  \
                        flow_depth 300  \
                        apache_whitespace yes \
                        directory no \
                        iis_backslash no \
                        u_encode yes \
                        ascii no \
                        chunk_length 500000 \
                        bare_byte yes \
                        double_decode yes \
                        iis_unicode yes \ 
                        iis_delimiter yes \
                        multi_slash no

preprocessor http_inspect_server: server default \
                        profile all \
                        ports { 80 8080 }
\end{verbatim}

\subsection{SMTP Preprocessor\label{SMTP}}

The SMTP preprocessor is an SMTP decoder for user applications.  Given a data buffer,
SMTP will decode the buffer and find SMTP commands and responses.
It will also mark the command, data header data body sections, and TLS data.

SMTP handles stateless and stateful processing.  It saves state
between individual packets.  However maintaining correct state is
dependent on the reassembly of the client side of the stream (ie, a
loss of coherent stream data results in a loss of state).

\subsubsection{Configuration}

SMTP has the usual configuration items, such as \texttt{port} and \texttt{inspection\_type}.
Also, SMTP command lines can be normalized to remove extraneous spaces.
TLS-encrypted traffic can be ignored, which improves performance.  In addition,
regular mail data can be ignored for an additional performance boost.  Since
so few (none in the current snort rule set) exploits are against mail data,
this is relatively safe to do and can improve the performance of data
inspection.

The configuration options are described below:

\begin{slist}

\item \texttt{ports \{ <port> [<port>] ... \}}

This specifies on what ports to check for SMTP data.  Typically, this will
include 25 and possibly 465, for encrypted SMTP.

\item \texttt{inspection\_type <stateful | stateless>}

Indicate whether to operate in stateful or stateless mode.

\item \texttt{normalize <all | none | cmds>}

This turns on normalization.  Normalization checks for more than one space
character after a command.  Space characters are defined as space (ASCII 0x20)
or tab (ASCII 0x09).

\texttt{all} checks all commands

\texttt{none} turns off normalization for all commands.

\texttt{cmds} just checks commands listed with the \texttt{normalize\_cmds} parameter.

\item \texttt{ignore\_data}

Ignore data section of mail (except for mail headers) when processing rules.

\item \texttt{ignore\_tls\_data}

Ignore TLS-encrypted data when processing rules.

\item \texttt{max\_command\_line\_len <int>}

Alert if an SMTP command line is longer than this value.  Absence of this
option or a "0" means never alert on command line length.
RFC 2821 recommends 512 as a maximum command line length.

\item \texttt{max\_header\_line\_len <int>}

Alert if an SMTP DATA header line is longer than this value.  Absence of this
option or a "0" means never alert on data header line length.
RFC 2821 recommends 1024 as a maximum data header line length.

\item \texttt{max\_response\_line\_len <int>}

Alert if an SMTP response line is longer than this value.  Absence of this
option or a "0" means never alert on response line length.
RFC 2821 recommends 512 as a maximum response line length.

\item \texttt{alt\_max\_command\_line\_len <int> \{ <cmd> [<cmd>] \}}

Overrides \texttt{max\_command\_line\_len} for specific commands.

\item \texttt{no\_alerts}

Turn off all alerts for this preprocessor.

\item \texttt{invalid\_cmds \{ <Space-delimited list of commands> \}}

Alert if this command is sent from client side.
Default is an empty list.

\item \texttt{valid\_cmds \{ <Space-delimited list of commands> \}}

List of valid commands.  We do not alert on commands in this list.
Default is an empty list, but preprocessor has this list hard-coded:
\{ ATRN AUTH BDAT DATA DEBUG EHLO EMAL ESAM ESND ESOM ETRN EVFY EXPN \}
\{ HELO HELP IDENT MAIL NOOP QUIT RCPT RSET SAML SOML SEND ONEX QUEU \}
\{ STARTTLS TICK TIME TURN TURNME VERB VRFY X-EXPS X-LINK2STATE \}
\{ XADR XAUTH XCIR XEXCH50 XGEN XLICENSE XQUE XSTA XTRN XUSR  \}

\item \texttt{alert\_unknown\_cmds}

Alert if we don't recognize command.  Default is off.

\item \texttt{normalize\_cmds \{ <Space-delimited list of commands> \}}

Normalize this list of commands Default is \{ RCPT VRFY EXPN \}.

\item \texttt{xlink2state \{ enable | disable [drop] \}}

Enable/disable xlink2state alert.  Drop if alerted.  Default is \texttt{enable}.

\item \texttt{print\_cmds}

List all commands understood by the preprocessor.  This not normally
printed out with the configuration because it can print so much data.

\end{slist}

\subsubsection{Example}

\begin{verbatim}
preprocessor SMTP: \
  ports { 25 } \
  inspection_type stateful \
  normalize cmds \
  normalize_cmds { EXPN VRFY RCPT } \
  ignore_data \
  ignore_tls_data \
  max_command_line_len  512 \
  max_header_line_len   1024 \
  max_response_line_len 512 \
  no_alerts \
  alt_max_command_line_len 300 { RCPT } \
  invalid_cmds { } \
  valid_cmds { } \
  xlink2state { disable } \
  print_cmds
\end{verbatim}

\subsubsection{Default}

\begin{verbatim}
preprocessor SMTP: \
  ports { 25 } \
  inspection_type stateful \
  normalize cmds \
  normalize_cmds { EXPN VRFY RCPT } \
  alt_max_command_line_len 260 { MAIL } \
  alt_max_command_line_len 300 { RCPT } \
  alt_max_command_line_len 500 { HELP HELO ETRN } \
  alt_max_command_line_len 255 { EXPN VRFY }
\end{verbatim}

\subsubsection{Note}
\texttt{RCPT TO:} and \texttt{MAIL FROM:} are SMTP commands.  For the preprocessor
configuration, they are referred to as RCPT and MAIL, respectively.
Within the code, the preprocessor actually maps RCPT and MAIL to the
correct command name.

\subsection{FTP/Telnet Preprocessor\label{sub:ftptelnet}}

FTP/Telnet is an improvement to the Telnet decoder and provides
stateful inspection capability for both FTP and Telnet data
streams.  FTP/Telnet will decode the stream, identifying FTP
commands and responses and Telnet escape sequences and
normalize the fields.  FTP/Telnet works on both client requests
and server responses.

FTP/Telnet has the capability to handle stateless processing, meaning
it only looks for information on a packet-by-packet basis.  

The default is to run FTP/Telent in stateful inspection mode, meaning
it looks for information and handles reassembled data correctly.

FTP/Telnet has a very ``rich'' user configuration, similar to that of
HTTP Inspect (See \ref{sub:http-inspect}).  Users can configure
individual FTP servers and clients with a variety of options, which
should allow the user to emulate any type of FTP server or FTP Client.
Within FTP/Telnet, there are four areas of configuration: Global,
Telnet, FTP Client, and FTP Server.

\begin{note}
Some configuration options have an argument of \texttt{yes} or \texttt{no}.
This argument specifies whether the user wants the configuration option to
generate a ftptelnet alert or not.  The presence of the option indicates
the option itself is on, while the \texttt{yes/no} argument applies to the
alerting functionality associated with that option.
\end{note}

\subsubsection{Global Configuration}

The global configuration deals with configuration options that determine the
global functioning of FTP/Telnet.  The following example gives the generic
global configuration format:

\subsubsection{Format}
\begin{verbatim}
preprocessor ftptelnet: global \
                        inspection_type stateful \
                        encrypted_traffic yes \
                        check_encrypted
\end{verbatim}

You can only have a single global configuration, you'll get an error if
you try otherwise.  The FTP/Telnet global configuration must appear
before the other three areas of configuration.

\paragraph{Configuration}
\begin{slist}
\item \texttt{inspection\_type}

This indicates whether to operate in stateful or stateless mode.

\item \texttt{encrypted\_traffic $<$yes|no$>$}

This option enables detection and alerting on encrypted Telnet and
FTP command channels.

\begin{note}
When \texttt{inspection\_type} is in stateless mode, checks for encrypted
traffic will occur on every packet, whereas in stateful mode, a particular
session will be noted as encrypted and not inspected any further.
\end{note}

\item \texttt{check\_encrypted}

Instructs the the preprocessor to continue to check an encrypted session
for a subsequent command to cease encryption.

\end{slist}

\subsubsection{Example Global Configuration}

\begin{verbatim}
preprocessor ftptelnet: global inspection_type stateful encrypted_traffic no
\end{verbatim}

\subsubsection{Telnet Configuration}

The telnet configuration deals with configuration options that determine the
functioning of the Telnet portion of the preprocessor.  The following
example gives the generic telnet configuration format:

\subsubsection{Format}
\begin{verbatim}
preprocessor ftptelnet: telnet \
                        ports { 23 } \
                        normalize \
                        ayt_attack_thresh 6 \
                        detect_anomalies

\end{verbatim}

There should  only be a single telnet configuration, and subsequent instances
will override previously set values.

\paragraph{Configuration}
\begin{slist}
\item \texttt{ports $\{ <$port$> [<$port$> <...>] \}$}

This is how the user configures which ports to decode as telnet traffic.
SSH tunnels cannot be decoded, so adding port 22 will only yield false
positives.  Typically port 23 will be included.

\item \texttt{normalize}

This option tells the preprocessor to normalize the telnet traffic
by eliminating the telnet escape sequences.  It functions similarly
to its predecessor, the telnet\_decode preprocessor.  Rules written
with 'raw' content options will ignore the normailzed buffer that
is created when this option is in use.

\item \texttt{ayt\_attach\_thresh $<$ number $>$}

This option causes the preprocessor to alert when the number of consecutive
telnet Are You There (AYT) commands reaches the number specified.  It
is only applicable when the mode is stateful.

\item \texttt{detect\_anomalies}

In order to support certain options, Telnet supports subnegotiation. Per the
Telnet RFC, subnegotiation begins with SB (subnegotiation begin) and must
end with an SE (subnegotiation end). However, certain implementations of
Telnet servers will ignore the SB without a cooresponding SE. This is
anomalous behavior which could be an evasion case. Being that FTP uses the
Telnet protocol on the control connection, it is also susceptible to this
behavior. The \texttt{detect\_anomalies} option enables alerting on Telnet SB without
the corresponding SE.

\end{slist}

\subsubsection{Example Telnet Configuration}
\begin{verbatim}
preprocessor ftptelnet: telnet ports { 23 } normalize ayt_attack_thresh 6
\end{verbatim}

\subsubsection{FTP Server Configuration}

There are two types of FTP server configurations: default and by IP address.

\paragraph{Default}

This configuration supplies the default server configuration for any FTP server
that is not individually configured.  Most of your FTP servers will most
likely end up using the default configuration.

\subsubsection{Example Default FTP Server Configuration}
\begin{verbatim}
preprocessor ftp_inspect_server: ftp server default ports { 21 } 
\end{verbatim}

\paragraph{Configuration by IP Address}
This format is very similar to ``default'', the only difference being that
specific IPs can be configured.

\subsubsection{Example IP specific FTP Server Configuration}
\begin{verbatim}
preprocessor ftptelnet: ftp server 10.1.1.1 ports { 21 } ftp_cmds { XPWD XCWD }
\end{verbatim}

\subsubsection{FTP Server Configuration Options}

\begin{slist}
\item \texttt{ports $\{ <$port$> [<$port$> <...>] \}$}

This is how the user configures which ports to decode as FTP command
channel traffic.  Typically port 21 will be included.

\item \texttt{print\_cmds}

During initialization, this option causes the preprocessor to print the
configuration for each of the FTP commands for this server.  

\item \texttt{ftp\_cmds $\{ cmd [cmd] \}$ }

The preprocessor is configured to alert when it sees an FTP command
that is not allowed by the server.

This option specifies a list of additional commands allowed by this server,
outside of the default FTP command set as specified in RFC 959.  This
may be used to allow the use of the 'X' commands identified in RFC 775,
as well as any additional commands as needed.

For example:

\begin{verbatim}
ftp_cmds { XPWD XCWD XCUP XMKD XRMD }
\end{verbatim}

\item \texttt{def\_max\_param\_len $<$number$>$}

This specifies the default maximum allowed parameter length for an
FTP command.  It can be used as a basic buffer overflow detection.

\item \texttt{alt\_max\_param\_len $<$number$>$ $\{ cmd [cmd] \}$}

This specifies the maximum allowed parameter length for the specified
FTP command(s).  It can be used as a more specific buffer overflow
detection.  For example the USER command -- usernames may be no longer
than 16 bytes, so the appropriate configuration would be:

\begin{verbatim}
alt_max_param_len 16 { USER }
\end{verbatim}

\item \texttt{chk\_str\_fmt $\{ cmd [cmd] \}$}

This option causes a check for string format attacks in the specified
commands. 

\item \texttt{cmd\_validity cmd $<$ fmt $>$}

This option specifies the valid format for parameters of a
givven command.

fmt must be enclosed in $<>$'s and may contain the following:

\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Value} & \textbf{Description} \\
\hline
\hline
int & Parameter must be an integer \\
\hline
number & Parameter must be an integer between 1 and 255 \\
\hline
char \_chars & Parameter must be a single character, one of \_chars \\
\hline
date \_datefmt & Parameter follows format specified, where: \\
\begin{tabular}{| l | p{2.0in} |}
\# & Number \\
C & Character \\
$[]$ & optional format enclosed \\
$|$ & OR \\
$\{\}$ & choice of options \\
other & literal (ie, . + -) \\
\end{tabular} \\
\hline
string & Parameter is a string (effectively unrestricted) \\
\hline
host\_port & Parameter must be a host/port specified, per RFC 959 \\
\hline
${}$, $|$ & One of choices enclosed within, separated by $|$ \\
\hline
$[]$ & Optional value enclosed within \\
\hline
\end{tabular}
\end{center}

Examples of the cmd\_validity option are shown below.  These examples are
the default checks, per RFC 959 and others performed by the preprocessor.

\begin{verbatim}
cmd_validity MODE <char SBC>
cmd_validity STRU <char FRP>
cmd_validity ALLO < int [ char R int ] >
cmd_validity TYPE < { char AE [ char NTC ] | char I | char L [ number ] } >
cmd_validity PORT < host_port >
\end{verbatim}

A cmd\_validity line can be used to override these defaults and/or add
a check for other commands.

\begin{verbatim}
# This allows additional modes, including mode Z which allows for
# zip-style compression.
cmd_validity MODE < char ASBCZ >

# Allow for a date in the MDTM command.
cmd_validity MDTM < [ date nnnnnnnnnnnnnn[.n[n[n]]] ] string >
\end{verbatim}

MDTM is an off case that is worth discussing.

While not part of an established standard, certain FTP servers accept
MDTM commands that set the modification time on a file.  The most common
among servers that do, accept a format using YYYYMMDDHHmmss[.uuu].  Some
others accept a format using YYYYMMDDHHmmss[+|-]TZ format.  The example
above is for the first case (time format as specified in
http://www.ietf.org/internet-drafts/draft-ietf-ftpext-mlst-16.txt)

To check validity for a server that uses the TZ format, use the following:

\begin{verbatim}
cmd_validity MDTM < [ date nnnnnnnnnnnnnn[{+|-}n[n]] ] string >
\end{verbatim}

\item \texttt{telnet\_cmds $<$yes$|$no$>$}

This option turns on detection and alerting when telnet escape sequences are
seen on the FTP command channel.  Injection of telnet escape sequences
could be used as an evasion attempt on an FTP command channel.

\item \texttt{data\_chan}

This option causes the rest of snort (rules, other preprocessors) to
ignore FTP data channel connections.  Using this option means that
\textbf{NO INSPECTION} other than TCP state will be performed on FTP
data transfers.  It can be used to improve performance, especially with
large file transfers from a trusted source.   If your rule set includes
virus-type rules, it is recommended that this option not be used.

\end{slist}

\subsubsection{FTP Client Configuration}

Similar to the FTP Server configuration, the FTP client configurations
has two types: default, and by IP address.

\paragraph{Default}

This configuration supplies the default client configuration for any FTP
client that is not individually configured.  Most of your FTP clients will
most likely end up using the default configuration.

\subsubsection{Example Default FTP Client Configuration}
\begin{verbatim}
preprocessor ftptelnet: ftp client default bounce no max_resp_len 200
\end{verbatim}

\paragraph{Configuration by IP Address}

This format is very similar to ``default'', the only difference being that
specific IPs can be configured.

\subsubsection{Example IP specific FTP Client Configuration}
\begin{verbatim}
preprocessor ftptelnet: ftp client 10.1.1.1 bounce yes max_resp_len 500
\end{verbatim}

\subsubsection{FTP Client Configuration Options}

\begin{slist}
\item \texttt{max\_resp\_len $<$number$>$}

This specifies the maximum allowed response length to an FTP command
accepted by the client.  It can be used as a basic buffer overflow
detection.

\item \texttt{bounce $<$yes|no$>$}

This option turns on detection and alerting of FTP bounce attacks.
An FTP bounce attack occurs when the FTP PORT command is issued and the
specified host does not match the host of the client.

\item \texttt{bounce\_to $<$ CIDR,[port$|$portlow,porthi] $>$}

When the bounce option is turned on, this allows the PORT command to use
the IP address (in CIDR format) and port (or inclusive port range)
without generating an alert.  It can be used to deal with proxied
FTP connections where the FTP data channel is different from the client.

A few examples:

\begin{itemize}
\item Allow bounces to 192.162.1.1 port 20020 -- ie, the use of
\texttt{PORT 192,168,1,1,78,52}.

\begin{verbatim}
bounce_to { 192.168.1.1,20020 }
\end{verbatim}

\item Allow bounces to 192.162.1.1 ports 20020 through 20040 -- ie,
the use of \texttt{PORT 192,168,1,1,78,xx}, where xx is 52 through 72
inclusive.

\begin{verbatim}
bounce_to { 192.168.1.1,20020,20040 }
\end{verbatim}

\item Allow bounces to 192.162.1.1 port 20020 and 192.168.1.2 port 20030.

\begin{verbatim}
bounce_to { 192.168.1.1,20020 192.168.1.2,20030}
\end{verbatim}

\end{itemize}

\item \texttt{telnet\_cmds $<$yes|no$>$}

This option turns on detection and alerting when telnet escape sequences are
seen on the FTP command channel.  Injection of telnet escape sequences
could be used as an evasion attempt on an FTP command channel.

\end{slist}

\subsubsection{Examples/Default Configuration from snort.conf}

\begin{verbatim}
preprocessor ftp_telnet: global \
            encrypted_traffic yes \
            inspection_type stateful

preprocessor ftp_telnet_protocol: telnet \
            normalize \
            ayt_attack_thresh 200

# This is consistent with the FTP rules as of 18 Sept 2004.
# Set CWD to allow parameter length of 200
# MODE has an additional mode of Z (compressed)
# Check for string formats in USER & PASS commands
# Check MDTM commands that set modification time on the file.
preprocessor ftp_telnet_protocol: ftp server default \
            def_max_param_len 100 \
            alt_max_param_len 200 { CWD } \
            cmd_validity MODE < char ASBCZ > \
            cmd_validity MDTM < [ date nnnnnnnnnnnnnn[.n[n[n]]] ] string > \
            chk_str_fmt { USER PASS RNFR RNTO SITE MKD } \
            telnet_cmds yes \
            data_chan

preprocessor ftp_telnet_protocol: ftp client default \
            max_resp_len 256 \
            bounce yes \
            telnet_cmds yes
\end{verbatim}

\subsection{SSH\label{sub:ssh}}

The SSH preprocessor detects the following exploits: Gobbles, CRC 32, Secure
CRT, and the Protocol Mismatch exploit.

Both Gobbles and CRC 32 attacks occur after the key exchange, and are therefore
encrypted.  Both attacks involve sending a large payload (20kb+) to the server
immediately after the authentication challenge.  To detect the attacks, the SSH
preprocessor counts the number of bytes transmitted to the server.  If those
bytes exceed a pre-defined limit within a pre-define number of packets, an
alert is generated.  Since Gobbles only effects SSHv2 and CRC 32 only effects
SSHv1, the SSH version string exchange is used to distinguish the attacks.

The Secure CRT and protocol mismatch exploits are observable before the key
exchange.

\subsubsection{Configuration}

By default, all alerts are enabled and the preprocessor checks traffic on port
22.

The available configuration options are described below.

\begin{slist}

\item \texttt{server\_ports $\{ <$port$> [<$port$> <...>] \}$}

This option specifies which ports the SSH preprocessor should inspect traffic
to.

\item \texttt{max\_encrypted\_packets $<$ number $>$}

Specifies the number of unanswered packets to allow before alerting on Gobbles
or CRC 32.  In Gobbles or CRC 32, several large packets will be transmitted
immediately after the authentication challenge.  max\_encrypted\_packets should
be used in combination with max\_client\_bytes.

\item \texttt{max\_client\_bytes $<$ number $>$}

The maximum number of bytes allowed to be transferred across
max\_encrypted\_packets packets before alerting on Gobbles or CRC 32.

\item \texttt{autodetect}

Attempt to automatically detect SSH.

\item \texttt{disable\_gobbles}

Disables checking for the Gobbles exploit.

\item \texttt{disable\_ssh1crc32}

Disables checking for the CRC 32 exploit.

\item \texttt{disable\_srvoverflow}

Disables checking for the Secure CRT exploit.

\item \texttt{disable\_protomismatch}

Disables checking for the Protocol Mismatch exploit.

\item \texttt{disable\_badmsgdir}

Disable alerts for traffic flowing the wrong direction. For instance, if the
presumed server generates client traffic, or if a client generates server
traffic.

\item \texttt{disable\_paysize}

Disables alerts for invalid payload sizes.

\item \texttt{disable\_recognition}

Disable alerts for non-SSH traffic on SSH ports.

\end{slist}

The SSH preprocessor should work by default.  After max\_client\_packets is
reached, the preprocessor will stop processing traffic for a given session.
If Gobbles or CRC 32 false positive, try increasing the number of required
client bytes with max\_client\_bytes.

\subsubsection{Examples/Default Configuration from snort.conf}

Looks for attacks on SSH server port 22.  Alerts at 19600 bytes
within 20 encrypted packets for the Gobbles/CRC32 exploits.

\begin{verbatim}
preprocessor ssh: server_ports { 22 } \
                  max_client_bytes 19600 \
                  max_encrypted_packets 20
\end{verbatim}

\subsection{DCE/RPC\label{sub:dcerpc}}

The dcerpc preprocessor detects and decodes SMB and DCE/RPC traffic.
It is primarily interested in DCE/RPC data, and only decodes SMB
to get at the DCE/RPC data carried by the SMB layer.

Currently, the preprocessor only handles reassembly of fragmentation
at both the SMB and DCE/RPC layer.  Snort rules can be evaded by
using both types of fragmentation; with the preprocessor enabled
the rules are given a buffer with a reassembled SMB or DCE/RPC
packet to examine.

At the SMB layer, only fragmentation using WriteAndX is currently
reassembled.  Other methods will be handled in future versions of
the preprocessor.

Autodetection of SMB is done by looking for "\verb!\xFFSMB!" at the
start of the SMB data, as well as checking the NetBIOS header (which
is always present for SMB) for the type "SMB Session".

Autodetection of DCE/RPC is not as reliable.  Currently, two bytes are
checked in the packet.  Assuming that the data is a DCE/RPC header,
one byte is checked for DCE/RPC version (5) and another for the type
"DCE/RPC Request".  If both match, the preprocessor proceeds with that
assumption that it is looking at DCE/RPC data.  If subsequent checks
are nonsensical, it ends processing.

\subsubsection{Configuration}

The proprocessor has several configuration options.  They are described
below:

The configuration options are described below:

\begin{slist}

\item \texttt{autodetect}
Ignore configured ports - examine all packets in attempt to determine
SMB or DCE/RPC traffic.  Default is on

\item \texttt{ports smb \{ $<$port$>$ [<$port$> <...>] \} dcerpc \{ $<$port$>$ [<$port$> <...>] \} }
Ports that the preprocessor monitors for SMB and DCE/RPC traffic.
Default is not configured (although default values would be 139
and 445 for SMB and 35 for DCE/RPC).

\item \texttt{disable\_smb\_frag}
Do not attempt to reassemble SMB fragmentation.   Default is off
(not configured).

\item \texttt{disable\_dcerpc\_frag}
Do not attempt to reassemble DCE/RPC fragmentation.   Default is off
(not configured).

\item \texttt{max\_frag\_size $<$number$>$}
Maximum reassembled fragment size, in bytes.  Default 3000 bytes.

\item \texttt{memcap $<$number$>$}
Maximum amount of memory available to the DCE/RPC preprocessor, in
kilobytes.  Default 100000.

\end{slist}

\subsubsection{Alerts}
There is currently only one alert, which is triggered when the preprocessor
has reached the \texttt{memcap} limit for memory allocation.  The
alert is gid 130, sid 1.

\subsubsection{Summary}
At the current time, there is not much to do with the dcerpc preprocessor
other than turn it on and let it reassemble fragmented DCE/RPC packets.

\subsubsection{Configuration Examples}

Do not reassemble SMB fragmentation.

\begin{verbatim}
preprocessor dcerpc: \
        autodetect \
        disable_smb_frag \
        max_frag_size 4000
\end{verbatim}

Specify specific ports, no autodetect.  Do not reassemble SMB fragmentation.

\begin{verbatim}
preprocessor dcerpc: \
        ports smb { 139 445 } dcerpc { 135 } \
        disable_dcerpc_frag \
        memcap 50000
\end{verbatim}

\subsubsection{Default Configuration from snort.conf}

Autodetect SMB and DCE/RPC traffic.  Reassembly of SMB and DCE/RPC
fragmentation.

\begin{verbatim}
preprocessor dcerpc: \
        autodetect \
        max_frag_size 3000 \
        memcap 100000
\end{verbatim}

\subsection{DNS\label{sub:dns}}

The DNS preprocessor decodes DNS Responses and can detect the
following exploits: DNS Client RData Overflow, Obsolete Record
Types, and Experimental Record Types.

DNS looks are DNS Response traffic over UDP and TCP and it requires
Stream preprocessor to be enabled for TCP decoding.

\subsubsection{Configuration}

By default, all alerts are disabled and the preprocessor checks traffic
on port 53.

The available configuration options are described below.

\begin{slist}

\item \texttt{ports $\{ <$port$> [<$port$> <...>] \}$}

This option specifies the source ports that the DNS preprocessor should
inspect traffic.

\item \texttt{enable\_obsolete\_types}

Alert on Obsolete (per RFC 1035) Record Types

\item \texttt{enable\_experimental\_types}

Alert on Experimental (per RFC 1035) Record Types

\item \texttt{enable\_rdata\_overflow}

Check for DNS Client RData TXT Overflow

\end{slist}

The DNS preprocessor does nothing if none of the 3 vulnerabilities
it checks for are enabled.  It will not operate on TCP sessions
picked up midstream, and it will cease operation on a session if it
loses state because of missing data (dropped packets).

\subsubsection{Examples/Default Configuration from snort.conf}

Looks for traffic on DNS server port 53.  Check for the DNS Client RData
overflow vulnerability.  Do not alert on obsolete or experimental RData
record types.

\begin{verbatim}
preprocessor dns: server_ports { 53 } \
                  enable_rdata_overflow
\end{verbatim}

\subsection{ASN.1 Detection\label{asn1}}

The asn.1 detection plugin decodes a packet or a portion of a packet, and looks
for various malicious encodings.

The general configuration of the asn.1 rule option is as follows:

\begin{verbatim}
asn1: [keyword [argument]], . . . 
\end{verbatim}

Multiple keywords can be used in an 'asn1' option and the implied logic is
boolean OR.  So if any of the arguments evaluate as true, the whole option
evaluates as true.

\subsubsection{ASN.1 Keywords\label{asn1 keywords}}


The ASN.1 keywords provide programmatic detection capabilities as well as some
more dynamic type detection.  Most of the keywords don't have arguments as the
detection is looking for non-configurable information.  If a keyword does have
an argument, the keyword is followed by a comma and the argument is the next
word.  If a keyword has multiple arguments, then a comman separates each.

\begin{slist}

\item \texttt{bitstring\_overflow}


The \texttt{bitstring\_overflow} option detects invalid bitstring encodings that are known to be
remotely exploitable.

\item \texttt{double\_overflow}


The double\_overflow detects a double ASCII encoding that is larger than a
standard buffer.  This is known to be an exploitable function in Microsoft, but
it is unknown at this time which services may be exploitable.

\item \texttt{oversize\_length}


This detection keyword compares ASN.1 type lengths with the supplied argument.
The syntax looks like, ``oversize\_length 500''.  This means that if an ASN.1
type is greater than 500, then this keyword is evaluated as true.  This
keyword must have one argument which specifies the length to compare against.

\item \texttt{absolute\_offset}


This is the absolute offset from the beginning of the packet.  For example, if
you wanted to decode snmp packets, you would say ``absolute\_offset, 0''.  
\texttt{absolute\_offset} has one argument---the offset value.  Offset may be
positive or negative.

\item \texttt{relative\_offset}


This is the relative offset from the last content match or byte\_test/jump. 
\texttt{relative\_offset} has one argument---the offset number.  So if you 
wanted to start decoding and ASN.1 sequence right after the content ``foo'', 
you would specify \verb!'content:"foo"; asn1: bitstring_overflow, relative_offset, 0'!.  Offset values may be positive or negative.

\end{slist}

\subsubsection{ASN.1 Examples}

The following rules use ASN.1 decoding options:

\begin{verbatim}
alert udp any any -> any 161 (msg:"Oversize SNMP Length"; \
    asn1: oversize_length, 10000, absolute_offset, 0;)
    
alert tcp any any -> any 80 (msg:"ASN1 Relative Foo"; content:"foo"; \
    asn1: bitstring_overflow, print, relative_offset, 0;)
\end{verbatim}

\section{Event Thresholding}
You can use event thresholding to reduce the number of logged alerts for noisy
rules.  This can be tuned to significantly reduce false alarms, and it can also
be used to write a newer breed of rules. Thresholding commands limit the number
of times a particular event is logged during a specified time interval. See Section \ref{Event Thresholding} for more information.

\section{Output Modules \label{output config}}

Output modules are new as of version 1.6. They allow Snort to be much
more flexible in the formatting and presentation of output to its
users. The output modules are run when the alert or logging subsystems
of Snort are called, after the preprocessors and detection engine.
The format of the directives in the rules file is very similar to
that of the preprocessors.

Multiple output plugins may be specified in the Snort configuration
file. When multiple plugins of the same type (log, alert) are specified,
they are stacked and called in sequence when an
event occurs. As with the standard logging and alerting systems, output
plugins send their data to /var/log/snort by default or to a user
directed directory (using the -l command line
switch).

Output modules are loaded at runtime by specifying the output keyword
in the rules file:

\begin{verbatim}
output <name>: <options>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
output alert_syslog: log_auth log_alert
\end{verbatim}

\caption{\label{output config example}Output Module Configuration Example}
\end{figure}

\subsection{alert\_syslog \label{alert syslog lable}}

This module sends alerts to the syslog facility (much like the -s
command line switch). This module also allows the user to specify
the logging facility and priority within the Snort rules file, giving
users greater flexibility in logging alerts.

\subsubsection{Available Keywords}


\paragraph{Facilities}

\begin{itemize}
\item \texttt{log\_auth} 
\item \texttt{log\_authpriv} 
\item \texttt{log\_daemon}
\item \texttt{log\_local0} 
\item \texttt{log\_local1}
\item \texttt{log\_local2}
\item \texttt{log\_local3}
\item \texttt{log\_local4}
\item \texttt{log\_local5}
\item \texttt{log\_local6}
\item \texttt{log\_local7}
\item \texttt{log\_user}
\end{itemize}

\paragraph{Priorities}

\begin{itemize}
\item \texttt{log\_emerg} 
\item \texttt{log\_alert}
\item \texttt{log\_crit}
\item \texttt{log\_err}
\item \texttt{log\_warning} 
\item \texttt{log\_notice}
\item \texttt{log\_info}
\item \texttt{log\_debug}
\end{itemize}

\paragraph{Options}

\begin{itemize}
\item \texttt{log\_cons} 
\item \texttt{log\_ndelay}
\item \texttt{log\_perror}
\item \texttt{log\_pid}
\end{itemize}

\subsubsection{Format}

\begin{verbatim}
alert_syslog: <facility> <priority> <options>
\end{verbatim}


\begin{note}
As WIN32 does not run syslog servers locally by default, a hostname and port
can be passed as options.  The default host is 127.0.0.1.  The default port is
514.
\end{note}

\begin{verbatim}
output alert_syslog: [host=<hostname[:<port>],] <facility> <priority> <options>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
output alert_syslog: 10.1.1.1:514, <facility> <priority> <options>
\end{verbatim}

\caption{Syslog Configuration Example\label{syslog example}}
\end{figure}

\subsection{alert\_fast}

This will print Snort alerts in a quick one-line format to a specified
output file. It is a faster alerting method than full alerts because
it doesn't need to print all of the packet headers to the output file


\subsubsection{Format}

\begin{verbatim}
alert_fast: <output filename>
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output alert_fast: alert.fast
\end{verbatim}

\caption{\label{fast alert configuration}Fast Alert Configuration}
\end{figure}



\subsection{alert\_full}

This will print Snort alert messages with full packet headers. The alerts will
be written in the default logging directory (/var/log/snort) or in
the logging directory specified at the command line.

Inside the logging directory, a directory will be created per IP.
These files will be decoded packet dumps of the packets that triggered
the alerts. The creation of these files slows Snort down considerably.
This output method is discouraged for all but the lightest traffic
situations.


\subsubsection{Format}

\begin{verbatim}
alert_full: <output filename>
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output alert_full: alert.full
\end{verbatim}

\caption{\label{full alert configuration}Full Alert Configuration}
\end{figure}


\subsection{alert\_unixsock}

Sets up a UNIX domain socket and sends alert reports to it. External
programs/processes can listen in on this socket and receive Snort
alert and packet data in real time. This is currently an experimental
interface.


\subsubsection{Format}

\begin{verbatim}
alert_unixsock
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output alert_unixsock
\end{verbatim}

\caption{\label{unixsock configuration}UNIXSock Alert Configuration}
\end{figure}



\subsection{log\_tcpdump}

The log\_tcpdump module logs packets to a tcpdump-formatted file.
This is useful for performing post-process analysis on collected
traffic with the vast number of tools that are available for examining
tcpdump-formatted files. This module only takes a single argument: the
name of the output file. Note that the file name will have the UNIX
timestamp in seconds appended the file name. This is so that data from
separate Snort runs can be kept distinct.


\subsubsection{Format}

\begin{verbatim}
log_tcpdump: <output filename>
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output log_tcpdump: snort.log
\end{verbatim}

\caption{\label{tcpdump output configuration}Tcpdump Output Module Configuration
Example}
\end{figure}

\subsection{database \label{database section}}

This module from Jed Pickel sends Snort data to a variety of SQL databases.
More information on installing and configuring this module can be
found on the {[}91{]}incident.org web page. The arguments to this
plugin are the name of the database to be logged to and a parameter
list. Parameters are specified with the format parameter = argument.
see Figure \ref{database output config} for example usage.


\subsubsection{Format}

\begin{verbatim}
database: <log | alert>, <database type>, <parameter list>
\end{verbatim}
The following parameters are available:

\begin{description}{}
\item [\texttt{host}] - Host to connect to. If a non-zero-length string is specified, TCP/IP communication is used. Without a host name, it will connect using a local UNIX domain socket.
\item [\texttt{port}] - Port number to connect to at the server host, or socket filename extension for UNIX-domain connections. 
\item [\texttt{dbname}] - Database name 
\item [\texttt{user}] - Database username for authentication
\item [\texttt{password}] - Password used if the database demands password authentication
\item [\texttt{sensor\_name}] - Specify your own name for this Snort sensor. If you do not specify a name, one will be generated automatically
\item [\texttt{encoding}] - Because the packet payload and option data is binary, there is no one simple and portable way to store it in a database. Blobs are not used because they are not portable across databases. So i leave the encoding option to you. You can choose from the following options. Each has its own advantages and disadvantages:

   \begin{description}{}
       \item [\texttt{hex}](default) - Represent binary data as a hex string. 

       \begin{description}{}
             \item [Storage~requirements]- 2x the size of the binary
             \item [Searchability]- very good 
             \item [Human~readability]- not readable unless you are a true geek, requires post processing
       \end{description}
       \item [\texttt{base64}] - Represent binary data as a base64 string. 

      \begin{description}{}
            \item [Storage~requirements]- $\sim$1.3x the size of the binary 
            \item [Searchability]- impossible without post processing 
            \item [Human~readability]- not readable requires post processing
      \end{description}

      \item [\texttt{ascii}] - Represent binary data as an ASCII string. This is
      the only option where you will actually lose data. Non-ASCII
      Data is represented as a `.'. If you choose this option, then data
      for IP and TCP options will still be represented as hex because
      it does not make any sense for that data to be ASCII.

\begin{description}{}
\item [Storage~requirements]- slightly larger than the binary because
some characters are escaped (\&,$<$,$>$)
\item [Searchability]- very good for searching for a text string impossible
if you want to search for binary 
\item [human~readability]- very good
\end{description}
\end{description}
\item [\texttt{detail}] - How much detailed data do you want to store? The options
are:

\begin{description}{}
\item [\texttt{full}](default) - Log all details of a packet that caused an alert
(including IP/TCP options and the payload)
\item [\texttt{fast}] - Log only a minimum amount of data. You severely limit the potential
of some analysis applications if you choose this option, but this
is still the best choice for some applications. The following fields
are logged: \texttt{timestamp}, \texttt{signature}, \texttt{source ip}, \texttt{destination ip}, \texttt{source
port}, \texttt{destination port}, \texttt{tcp flags}, and \texttt{protocol})
\end{description}
\end{description}
Furthermore, there is a logging method and database type that must
be defined. There are two logging types available, \texttt{log} and \texttt{alert}.
Setting the type to log attaches the database logging functionality
to the log facility within the program. If you set the type to log,
the plugin will be called on the log output chain. Setting the type
to alert attaches the plugin to the alert output chain within the
program.

There are five database types available in the current version of the plugin.
These are \texttt{mssql}, \texttt{mysql}, \texttt{postgresql}, \texttt{oracle}, and \texttt{odbc}.  
Set the type to match
the database you are using.

\begin{note}
The database output plugin does not have the ability to handle alerts that are
generated by using the \texttt{tag} keyword.  See section \ref{tag section} for more
details.
\end{note}

\begin{figure}[!hbpt]
\begin{verbatim}
output database: log, mysql, dbname=snort user=snort host=localhost password=xyz
\end{verbatim}

\caption{\label{database output config}Database Output Plugin Configuration}
\end{figure}



\subsection{csv}

The csv output plugin allows alert data to be written in a format
easily importable to a database. The plugin requires 2 arguments:
a full pathname to a file and the output formatting option. 

The list of formatting options is below. If the formatting option
is default, the output is in the order the formatting option is listed.

\begin{itemize}
\item \texttt{timestamp}
\item \texttt{sig\_generator}
\item \texttt{sig\_id}
\item \texttt{sig\_rev}
\item \texttt{msg}
\item \texttt{proto}
\item \texttt{src}
\item \texttt{srcport}
\item \texttt{dst}
\item \texttt{dstport}
\item \texttt{ethsrc}
\item \texttt{ethdst}
\item \texttt{ethlen}
\item \texttt{tcpflags}
\item \texttt{tcpseq}
\item \texttt{tcpack}
\item \texttt{tcplen}
\item \texttt{tcpwindow}
\item \texttt{ttl}
\item \texttt{tos}
\item \texttt{id}
\item \texttt{dgmlen}
\item \texttt{iplen}
\item \texttt{icmptype}
\item \texttt{icmpcode}
\item \texttt{icmpid}
\item \texttt{icmpseq}
\end{itemize}

\subsubsection{Format}

\begin{verbatim}
output alert_csv: <filename> <format>


\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output alert_csv: /var/log/alert.csv default

output alert_csv: /var/log/alert.csv timestamp, msg
\end{verbatim}

\caption{CSV Output Configuration\label{csv output configuration}}
\end{figure}

\subsection{unified}

The unified output plugin is designed to be the fastest possible method of
logging Snort events.  The unified output plugin logs events in binary format, 
allowing another programs to handle complex logging mechanisms that would
otherwise diminish the performance of Snort.

The name \emph{unified} is a misnomer, as the unified output plugin creates two
different files, an \emph{alert} file, and a \emph{log} file.   The alert file
contains the high-level details of an event (eg: IPs, protocol, port, message
id).  The log file contains the detailed packet information (a packet dump with
the associated event ID).  Both file types are written in a bimary format
described in \emph{spo\_unified.h}.

\begin{note}
Files have the file creation time (in Unix Epoch format) appended to each
file when it is created.
\end{note}

\subsubsection{Format}

\begin{verbatim}
output alert_unified: <base file name> [, <limit <file size limit in MB>]
output log_unified: <base file name> [, <limit <file size limit in MB>]
\end{verbatim}


\begin{figure}[!hbpt]
\begin{verbatim}
output alert_unified: snort.alert, limit 128
output log_unified: snort.log, limit 128
\end{verbatim}
\caption{Unified Configuration Example\label{unified example}}
\end{figure}


\subsection{alert\_prelude}

\begin{note}
support to use alert\_prelude is not built in by default.  To use alert\_prelude, snort must be built with the --enable-prelude arguement passed to ./configure.
\end{note}

The alert\_prelude output plugin is used to log to a Prelude database.  For more information on Prelude, see \url{http://www.prelude-ids.org/}.

\subsubsection{format}

\begin{verbatim}
output alert_prelude: profile <name of prelude profile> 
    [, info <priority number for info priority alerts>]
    [, low <priority number for low priority alerts>]
    [, medium <priority number for medium priority alerts>]
    [, high <priority number for high priority alerts>]
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
output alert_prelude: profile snort, info 4, low 3, medium 2, high  1
\end{verbatim}
\caption{alert\_prelude configuration example\label{prelude example}}
\end{figure}

\subsection{log null}

Sometimes it is useful to be able to create rules that will alert
to certain types of traffic but will not cause packet log entries.
In Snort 1.8.2, the log\_null plugin was introduced. This is equivalent
to using the -n command line option but it is able to work within
a ruletype.


\subsubsection{Format}

\begin{verbatim}
output log_null
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
output log_null  # like using snort -n

ruletype info {
    type alert
    output alert_fast: info.alert
    output log_null
}
\end{verbatim}
\caption{Log Null Usage Example\label{log null usage example}}
\end{figure}

\subsection{alert\_aruba\_action}

\begin{note}
Support to use alert\_aruba\_action is not built in by default.  To
use alert\_aruba\_action, snort must be built with the --enable-aruba
arguement passed to ./configure.
\end{note}

Communicates with an Aruba Networks wireless mobility controller to
change the status of authenticated users.  This allows Snort to take
action against users on the Aruba controller to control their network
privilege levels.

For more information on Aruba Networks access control, see
\url{http://www.arubanetworks.com/}.

\subsubsection{Format}

\begin{verbatim}
output alert_aruba_action: <controller address> <secrettype> <secret> <action>
\end{verbatim}
%
The following parameters are required:

\begin{description}{}
\item [\texttt{controller address}] - Aruba mobility controller address.
\item [\texttt{secrettype}] - Secret type, one of "sha1", "md5" or "cleartext".
\item [\texttt{secret}] - Authentication secret configured on the Aruba mobility controller with the "aaa xml-api client" configuration command, represented as a sha1 or md5 hash, or a cleartext password.
\item [\texttt{action}] - Action to apply to the source IP address of the traffic generating an alert.

  \begin{description}{}
      \item [\texttt{blacklist}]- Blacklist the station by disabling all radio communication.
      \item [\texttt{setrole:rolename}]- Change the user\'s role to the specified rolename.
  \end{description}
\end{description}

\begin{figure}[!hbpt]
\begin{verbatim}
output alert_aruba_action: 10.3.9.6 cleartext foobar setrole:quarantine_role
\end{verbatim}

\caption{\label{aruba_action configuration}Aruba Action Alert Configuration}
\end{figure}

\section{Dynamic Modules}

Dynamically loadable modules were introduced with Snort 2.6.  They can
be loaded via directives in \texttt{snort.conf} or via command-line options.

\begin{note}
To use dynamic modules, Snort must be configured with the
--enable-dynamicplugin flag.
\end{note}

\subsection{Format}

\begin{center}
\begin{verbatim}
<directive> <parameters>
\end{verbatim}
\end{center}

\subsection{Directives}
\begin{table}[!hbpt]
\caption{Dynamic Directives}
\begin{center}
\begin{tabular}{| l | p{2.25in} | p{2.25in} |}
\hline
{\bf Directive} & {\bf Syntax} & {\bf Description}\\
\hline
\hline
\texttt{dynamicpreprocessor} & \texttt{dynamicpreprocessor $[$ file $<$shared library path$>$ $|$ directory $<$directory of shared libraries$>$ $]$} & Tells snort to load the dynamic preprocessor shared library (if file is used) or all dynamic preprocessor shared libraries (if directory is used).  Specify 'file', followed by the full or relative path to the shared library.  Or, specify 'directory', followed by the full or relative path to a directory of preprocessor shared libraries.  (Same effect as \texttt{--dynamic-preprocessor-lib} or \texttt{--dynamic-preprocessor-lib-dir} options).  See chapter \ref{Dynamic Modules} for more information on dynamic preprocessor libraries.\\
\hline
\texttt{dynamicengine} & \texttt{dynamicengine $[$ file $<$shared library path$>$ $|$ directory $<$directory of shared libraries$>$ $]$} & Tells snort to load the dynamic engine shared library (if file is used) or all dynamic engine shared libraries (if directory is used).  Specify 'file', followed by the full or relative path to the shared library.  Or, specify 'directory', followed by the full or relative path to a directory of preprocessor shared libraries.  (Same effect as \texttt{--dynamic-engine-lib} or \texttt{--dynamic-preprocessor-lib-dir} options).  See chapter \ref{Dynamic Modules} for more information on dynamic engine libraries.\\
\hline
\texttt{dynamicdetection} & \texttt{dynamicdetection $[$ file $<$shared library path$>$ $|$ directory $<$directory of shared libraries$>$ $]$} & Tells snort to load the dynamic detection rules shared library (if file is used) or all dynamic detection rules shared libraries (if directory is used).  Specify 'file', followed by the full or relative path to the shared library.  Or, specify 'directory', followed by the full or relative path to a directory of detection rules shared libraries.  (Same effect as \texttt{--dynamic-detection-lib} or \texttt{--dynamic-detection-lib-dir} options).  See chapter \ref{Dynamic Modules} for more information on dynamic detection rules libraries.\\
\hline
\end{tabular}
\end{center}
\end{table}
%\begin{verbatim}
%\end{verbatim}

%\chapter{Using Snort as an IDS\protect \\
%How to Write Snort Rules and Keep Your Sanity\label{using snort as an IDS}}

\clearpage
\chapter{Writing Snort Rules: \protect \\
How to Write Snort Rules and Keep Your Sanity\label{Writing Snort Rules}}

\section{The Basics}

Snort uses a simple, lightweight rules description language that is flexible
and quite powerful. There are a number of simple guidelines to remember when
developing Snort rules.

Most Snort rules are written in a single line. This was required in versions
prior to 1.8. In current versions of Snort, rules may span multiple lines by
adding a backslash \textbackslash{} to the end of the line. 

Snort rules are divided into two logical sections, the rule header and the rule
options. The rule header contains the rule's action, protocol, source and
destination IP addresses and netmasks, and the source and destination ports
information. The rule option section contains alert messages and information on
which parts of the packet should be inspected to determine if the rule action
should be taken.

Figure \ref{Sample Snort Rule} illustrates a sample Snort rule.

\begin{center}
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> 192.168.1.0/24 111 (content:"|00 01 86 a5|"; msg:"mountd access";)
\end{verbatim}

\caption{Sample Snort Rule\label{Sample Snort Rule}}
\end{figure}
\end{center}

The text up to the first parenthesis is the rule header and the section
enclosed in parenthesis contains the rule options. The words before the
colons in the rule options section are called option \emph{keywords}. 

\begin{note}
Note that the rule options section is not specifically required by any
rule, they are just used for the sake of making tighter definitions
of packets to collect or alert on (or drop, for that matter). 
\end{note}

All of the elements in that make up a rule must be true for the indicated
rule action to be taken. When taken together, the elements can be
considered to form a logical \textsc{and} statement. At the same time,
the various rules in a Snort rules library file can be considered
to form a large logical \textsc{or} statement. 


\section{Rules Headers}


\subsection{Rule Actions \label{rules action section}}

The rule header contains the information that defines the who,
where, and what of a packet, as well as what to do in the
event that a packet with all the attributes indicated in the rule
should show up. The first item in a rule is the rule action. The rule
action tells Snort what to do when it finds a packet that matches
the rule criteria. There are 5 available default actions in Snort,
alert, log, pass, activate, and dynamic. In addition, if you are running
Snort in inline mode, you have additional options which include drop, reject, and sdrop. 

\begin{enumerate}
\item alert - generate an alert using the selected alert method, and then
log the packet 
\item log - log the packet 
\item pass - ignore the packet 
\item activate - alert and then turn on another dynamic rule  
\item dynamic - remain idle until activated by an activate rule , then act
as a log rule
\item drop - make iptables drop the packet and log the packet
\item reject - make iptables drop the packet, log it, and then send a 
TCP reset if the protocol is TCP or an ICMP port unreachable message if the 
protocol is UDP.
\item sdrop - make iptables drop the packet but does not log it.
\end{enumerate}
You can also define your own rule types and associate one or more
output plugins with them. You can then use the rule types as actions
in Snort rules.

This example will create a type that will log to just tcpdump:

\begin{verbatim}
ruletype suspicious
{
    type log 
    output log_tcpdump: suspicious.log
}
\end{verbatim}

This example will create a rule type that will log to syslog and a
MySQL database:

\begin{center}
\begin{verbatim}
ruletype redalert
{
      type alert 
      output alert_syslog: LOG_AUTH LOG_ALERT 
      output database: log, mysql, user=snort dbname=snort host=localhost 
}
\end{verbatim}
\end{center}

\subsection{Protocols}

The next field in a rule is the protocol. There are four protocols
that Snort currently analyzes for suspicious behavior -- TCP, UDP,
ICMP, and IP. In the future there may be more, such as ARP, IGRP,
GRE, OSPF, RIP, IPX, etc.


\subsection{IP Addresses}

The next portion of the rule header deals with the IP address and
port information for a given rule. The keyword any
may be used to define any address. Snort does not have a mechanism
to provide host name lookup for the IP address fields in the rules
file. The addresses are formed by a straight numeric IP address and
a CIDR\cite{cidrnotation} block. The CIDR block indicates the netmask
that should be applied to the rule's address and any incoming packets
that are tested against the rule. A CIDR block mask of /24 indicates
a Class C network, /16 a Class B network, and /32 indicates a specific
machine address. For example, the address/CIDR combination 192.168.1.0/24
would signify the block of addresses from 192.168.1.1 to 192.168.1.255.
Any rule that used this designation for, say, the destination address
would match on any address in that range. The CIDR designations give
us a nice short-hand way to designate large address spaces with just
a few characters.

In Figure \ref{Sample Snort Rule}, the source IP address was set
to match for any computer talking, and the destination address was
set to match on the 192.168.1.0 Class C network.

There is an operator that can be applied to IP addresses, the negation
operator. This operator tells Snort to match any IP address except
the one indicated by the listed IP address. The negation operator
is indicated with a !. For example, an easy modification
to the initial example is to make it alert on any traffic that originates
outside of the local net with the negation operator as shown in Figure
\ref{Example Negation}.

\begin{center}
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp !192.168.1.0/24 any -> 192.168.1.0/24 111 \
     (content: "|00 01 86 a5|"; msg: "external mountd access";)
\end{verbatim}

\caption{\label{Example Negation} Example IP Address Negation Rule}
\end{figure}
\end{center}


This rule's IP addresses indicate any tcp packet with a
source IP address not originating from the internal network and a
destination address on the internal network.

You may also specify lists of IP addresses. An IP list is specified
by enclosing a comma separated list of IP addresses and CIDR blocks
within square brackets. For the time being, the IP list may not include
spaces between the addresses. See Figure \ref{IP list usage} for
an example of an IP list in action.

\begin{center}
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp ![192.168.1.0/24,10.1.1.0/24] any -> \
     [192.168.1.0/24,10.1.1.0/24] 111 (content: "|00 01 86 a5|"; \
     msg: "external mountd access";)
\end{verbatim}

\caption{\label{IP list usage}IP Address Lists}
\end{figure}
\end{center}



\subsection{Port Numbers}

Port numbers may be specified in a number of ways, including any
ports, static port definitions, ranges, and by negation. Any
ports are a wildcard value, meaning literally any port. Static ports
are indicated by a single port number, such as 111 for portmapper,
23 for telnet, or 80 for http, etc. Port ranges are indicated with
the range operator :. The range operator may be
applied in a number of ways to take on different meanings, such as
in Figure \ref{port range examples}.

\begin{center}
\begin{figure}[!hbpt]
\begin{verbatim}
log udp any any -> 192.168.1.0/24 1:1024 log udp 
\end{verbatim}
traffic coming from any port and destination ports ranging from 1
to 1024

\begin{verbatim}
log tcp any any -> 192.168.1.0/24 :6000 
\end{verbatim}
log tcp traffic from any port going to ports less than or equal to
6000

\begin{verbatim}
log tcp any :1024 -> 192.168.1.0/24 500: 
\end{verbatim}
log tcp traffic from privileged ports less than or equal to 1024 going
to ports greater than or equal to 500


\caption{\label{port range examples}Port Range Examples}
\end{figure}
\end{center}

Port negation is indicated by using the negation operator !.
The negation operator may be applied against any of the other rule
types (except any, which would translate to none, how Zen...). For
example, if for some twisted reason you wanted to log everything except
the X Windows ports, you could do something like the rule in Figure
\ref{example port negation}.

%
\begin{figure}[!hbpt]
\begin{verbatim}
log tcp any any -> 192.168.1.0/24 !6000:6010
\end{verbatim}

\caption{\label{example port negation}Example of Port Negation}
\end{figure}

\clearpage

\subsection{The Direction Operator}

The direction operator -$>$ indicates the orientation,
or direction, of the traffic that the rule applies
to. The IP address and port numbers on the left side of the direction
operator is considered to be the traffic coming from the source host,
and the address and port information on the right side of the operator
is the destination host. There is also a bidirectional operator, which
is indicated with a $<>$ symbol. This tells Snort
to consider the address/port pairs in either the source or destination
orientation. This is handy for recording/analyzing both sides of a
conversation, such as telnet or POP3 sessions. An example of the bidirectional
operator being used to record both sides of a telnet session is shown
in Figure \ref{bidirectional operator}.

Also, note that there is no $<$- operator. In Snort
versions before 1.8.7, the direction operator did not have proper
error checking and many people used an invalid token. The reason the
$<$- does not exist is so that rules always read
consistently.

%
\begin{figure}[!hbpt]
\begin{verbatim}
log tcp !192.168.1.0/24 any <> 192.168.1.0/24 23
\end{verbatim}

\caption{\label{bidirectional operator}Snort rules using the Bidirectional
Operator}
\end{figure}



\subsection{Activate/Dynamic Rules}

\begin{note}
Activate and Dynamic rules are being phased out in favor of a combination 
of tagging (\ref{tag section}) and flowbits (\ref{flowbits}). 
\end{note}

Activate/dynamic rule pairs give Snort a powerful capability. You
can now have one rule activate another when it's action is performed
for a set number of packets. This is very useful if you want to set
Snort up to perform follow on recording when a specific rule goes
off. Activate rules act just like alert rules, except they
have a {*}required{*} option field: activates.
Dynamic rules act just like log rules, but they have a different option
field: activated\_by. Dynamic rules have a second
required field as well, count. 

Activate rules are just like alerts but also tell Snort to add a rule
when a specific network event occurs. Dynamic rules are just like
log rules except are dynamically enabled when the activate rule id
goes off. 

Put 'em together and they look like Figure \ref{activate/dynamic rule example}.

%
\begin{figure}[!hbpt]
\begin{verbatim}
activate tcp !$HOME_NET any -> $HOME_NET 143 (flags: PA; \
     content: "|E8C0FFFFFF|/bin"; activates: 1;  \
     msg: "IMAP buffer overflow!";)
dynamic tcp !$HOME_NET any -> $HOME_NET 143 (activated_by: 1; count: 50;)
\end{verbatim}

\caption{Activate/Dynamic Rule Example\label{activate/dynamic rule example}}
\end{figure}

These rules tell Snort to alert when it detects an IMAP buffer overflow
and collect the next 50 packets headed for port 143 coming from outside
\$HOME\_NET headed to \$HOME\_NET. If the buffer overflow happened
and was successful, there's a very good possibility that useful data
will be contained within the next 50 (or whatever) packets going to
that same service port on the network, so there's value in collecting
those packets for later analysis.

\newpage
\section{Rule Options}

Rule options form the heart of Snort's intrusion detection engine, combining
ease of use with power and flexibility. All Snort rule options are separated
from each other using the semicolon (;) character. Rule option keywords are
separated from their arguments with a colon (:) character. 

There are four major categories of rule options.  
\begin{description}
\item [meta-data] These options provide information about the rule but do not have any affect during detection 
\item [payload] These options all look for data inside the packet payload and can be inter-related
\item [non-payload] These options look for non-payload data
\item [post-detection] These options are rule specific triggers that happen after a rule has ``fired.''
\end{description}

\section{Meta-Data Rule Options}

\subsection{msg}

The msg rule option tells the logging and alerting engine the message to print
along with a packet dump or to an alert. It is a simple text string that
utilizes the \textbackslash{} as an escape character to indicate a discrete
character that might otherwise confuse Snort's rules parser (such as the
semi-colon ; character).

\subsubsection{Format}

\begin{verbatim}
msg: "<message text>";
\end{verbatim}

\subsection{reference}

The reference keyword allows rules to include references to external
attack identification systems. The plugin currently supports several
specific systems as well as unique URLs. This plugin is to be used
by output plugins to provide a link to additional information about
the alert produced.

Make sure to also take a look at \url{http://www.snort.org/pub-bin/sigs-search.cgi/}
for a system that is indexing descriptions of alerts based on of
the sid (See Section \ref{keyword sid}).
\begin{table}[!hbpt]

\caption{Supported Systems \label{references systems}}

\begin{center}\begin{tabular}{|c|c|}
\hline 
System&
URL Prefix\\
\hline
\hline 
bugtraq&
http://www.securityfocus.com/bid/\\
\hline 
cve&
http://cve.mitre.org/cgi-bin/cvename.cgi?name=\\
\hline 
nessus &
http://cgi.nessus.org/plugins/dump.php3?id=\\
\hline 
arachnids&
(currently down) http://www.whitehats.com/info/IDS\\
\hline 
mcafee&
http://vil.nai.com/vil/dispVirus.asp?virus\_k=\\
\hline 
url&
http://\\
\hline
\end{tabular}\end{center}
\end{table}


\subsubsection{Format}

\begin{verbatim}
reference: <id system>,<id>; [reference: <id system>,<id>;]
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 7070 (msg:"IDS411/dos-realaudio"; \
   flags:AP; content:"|fff4 fffd 06|"; reference:arachnids,IDS411;)

alert tcp any any -> any 21 (msg:"IDS287/ftp-wuftp260-venglin-linux"; \
   flags:AP; content:"|31c031db 31c9b046 cd80 31c031db|"; \
   reference:arachnids,IDS287; reference:bugtraq,1387; \
   reference:cve,CAN-2000-1574;)
\end{verbatim}

\caption{Reference Usage Examples\label{example reference rule}}
\end{figure}

\subsection{sid\label{keyword sid}}

The sid keyword is used to uniquely identify Snort rules. This information
allows output plugins to identify rules easily.  This option should be used
with the rev keyword.  (See section \ref{keyword rev})

\begin{itemize}
\item $<$100 Reserved for future use
\item 100-1,000,000 Rules included with the Snort distribution
\item $>$1,000,000 Used for local rules
\end{itemize}

The file sid-msg.map contains a mapping of alert messages to Snort rule IDs.
This information is useful when post-processing alert to map an ID to an alert
message.  

\subsubsection{Format}

\begin{verbatim}
sid: <snort rules id>;
\end{verbatim}

\subsubsection{Example}
This example is a rule with the Snort Rule ID of 1000983.
\begin{verbatim}
alert tcp any any -> any 80 (content:"BOB"; sid:1000983; rev:1;)
\end{verbatim}

\subsection{rev \label{keyword rev}}

The sid keyword is used to uniquely identify revisions of Snort rules.
Revisions, along with Snort rule id's, allow signatures and descriptions to be
refined and replaced with updated information.  This option should be used with
the sid keyword.  (See section \ref{keyword sid})

\subsubsection{Format}

\begin{verbatim}
rev: <revision integer>
\end{verbatim}

\subsubsection{Example}
This example is a rule with the Snort Rule Revision of 1.
\begin{verbatim}
alert tcp any any -> any 80 (content:"BOB"; sid:1000983; rev:1;)
\end{verbatim}

\subsection{classtype}

The classtype keyword categorizes alerts to be attack classes. By
using the and prioritized. The user can specify what priority each
type of rule classification has. Rules that have a classification
will have a default priority set. 

\subsubsection{Format}

\begin{verbatim}
classtype: <class name>;
\end{verbatim}
Rule classifications are defined in the \texttt{classification.config}
file. The config file uses the following syntax:

\begin{verbatim}
config classification:  <class name>,<class description>,<default priority>
\end{verbatim}
The standard classifications included with Snort are listed in Table
\ref{Snort Default Classifications}. The standard classifications
are ordered with 3 default priorities currently. A priority 1 is the
most severe priority level of the default rule set and 4 is the least
severe.


\begin{center}
\begin{longtable}{|p{2in}|p{2.5in}|c|}
\caption{Snort Default Classifications \label{Snort Default Classifications}} \\
\hline 
Classtype & Description & Priority \\
\hline
\hline 
attempted-admin&
Attempted Administrator Privilege Gain & high \\
\hline 
attempted-user&
Attempted User Privilege Gain & high\\
\hline 
shellcode-detect&
Executable code was detected & high\\
\hline 
successful-admin&
Successful Administrator Privilege Gain & high\\
\hline 
successful-user&
Successful User Privilege Gain & high\\
\hline 
trojan-activity&
A Network Trojan was detected & high\\
\hline 
unsuccessful-user&
Unsuccessful User Privilege Gain & high\\
\hline 
web-application-attack&
Web Application Attack & high\\
\hline
attempted-dos&
Attempted Denial of Service & medium\\
\hline 
attempted-recon&
Attempted Information Leak & medium\\
\hline 
bad-unknown&
Potentially Bad Traffic & medium\\
\hline 
denial-of-service&
Detection of a Denial of Service Attack & medium\\
\hline 
misc-attack&
Misc Attack & medium\\
\hline 
non-standard-protocol&
Detection of a non-standard protocol or event & medium\\
\hline 
rpc-portmap-decode&
Decode of an RPC Query & medium\\
\hline 
successful-dos&
Denial of Service & medium\\
\hline 
successful-recon-largescale&
Large Scale Information Leak & medium\\
\hline 
successful-recon-limited&
Information Leak & medium\\
\hline 
suspicious-filename-detect&
A suspicious filename was detected & medium\\
\hline 
suspicious-login&
An attempted login using a suspicious username was detected & medium\\
\hline 
system-call-detect&
A system call was detected & medium\\
\hline 
unusual-client-port-connection&
A client was using an unusual port & medium\\
\hline 
web-application-activity&
access to a potentially vulnerable web application & medium\\
\hline
icmp-event&
Generic ICMP event & low\\
\hline 
misc-activity&
Misc activity & low\\
\hline 
network-scan&
Detection of a Network Scan & low\\
\hline 
not-suspicious&
Not Suspicious Traffic & low\\
\hline 
protocol-command-decode&
Generic Protocol Command Decode & low\\
\hline 
string-detect&
A suspicious string was detected & low\\
\hline 
unknown&
Unknown Traffic & low\\
\hline
\end{longtable}
\end{center}


\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 80 (msg:"EXPLOIT ntpdx overflow"; \ 
    dsize: >128; classtype:attempted-admin; priority:10 );

alert tcp any any -> any 25 (msg:"SMTP expn root"; flags:A+; \
   content:"expn root"; nocase; classtype:attempted-recon;)
\end{verbatim}
\caption{Example Classtype Rules\label{example classification rules}}
\end{figure}

\subsubsection{Warnings}

classtype uses classifications defined by the classification config option.  The classifications used by the rules provided with Snort are defined in etc/classification.config

\subsection{Priority}

The priority tag assigns a severity level to rules. A classtype rule
assigns a default priority that may be overridden with a priority
rule. For an example in conjunction with a classification rule refer
to Figure \ref{example classification rules}. For use by itself,
see Figure \ref{example priority rule}


\subsubsection{Format}

\begin{verbatim}
priority: <priority integer>;
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
alert TCP any any -> any 80 (msg: "WEB-MISC phf attempt"; flags:A+; \
      content: "/cgi-bin/phf"; priority:10;)
\end{verbatim}

\caption{Example Priority Rule\label{example priority rule}}
\end{figure}



\section{Payload Detection Rule Options}
\subsection{content\label{sub:content}}

The content keyword is one of the more important features of Snort.
It allows the user to set rules that search for specific content in
the packet payload and trigger response based on that data. Whenever
a content option pattern match is performed, the Boyer-Moore pattern
match function is called and the (rather computationally expensive)
test is performed against the packet contents. If data exactly matching
the argument data string is contained anywhere within the packet's
payload, the test is successful and the remainder of the rule option
tests are performed. Be aware that this test is case sensitive.

The option data for the content keyword is somewhat complex; it can
contain mixed text and binary data. The binary data is generally enclosed
within the pipe ($|$) character and represented
as bytecode. Bytecode represents binary data as hexadecimal numbers
and is a good shorthand method for describing complex binary data.
Figure \ref{mixed content example} contains an example of mixed text
and binary data in a Snort rule. 

Note that multiple content rules can be specified in one rule. This
allows rules to be tailored for less false positives. 

If the rule is preceded by a \texttt{!}, the alert will be triggered
on packets that do not contain this content. This is useful when writing
rules that want to alert on packets that do not match a certain pattern

\begin{note}
Also note that the following characters must be escaped inside a content
rule:

\begin{verbatim}
: ; \ "
\end{verbatim}
\end{note}


\subsubsection{Format}

\begin{verbatim}
content: [!] "<content string>";
\end{verbatim}


\subsubsection{Example}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 139 (content:"|5c 00|P|00|I|00|P|00|E|00 5c|";)
\end{verbatim}
\caption{\label{mixed content example}Mixed Binary Bytecode and Text in a 'content' keyword}
\end{figure}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 80 (content:!"GET";)
\end{verbatim}
\caption{\label{content negation example}Negation Example}
\end{figure}

\subsubsection{Changing content behavior}

The \texttt{content} keyword has a number of modifier keywords.  The modifier
keywords change how the previously specified content works.  These modifier
keywords are:

\begin{slist}
\item nocase
\item rawbytes
\item depth
\item offset
\item distance
\item within
\item http\_client\_body
\item http\_uri
\end{slist}


\subsection{nocase}

The nocase keyword allows the rule writer to specify that the Snort should look
for the specific pattern, ignoring case.  nocase modifies the previous 'content' keyword in the rule.

\subsubsection{Format}

\begin{verbatim}
nocase;
\end{verbatim}

\subsubsection{Example}
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 21 (msg:"FTP ROOT"; content:"USER root"; nocase;)
\end{verbatim}

\caption{\label{content nocase mod example}Content rule with nocase modifier}
\end{figure}

\subsection{rawbytes \label{sub:rawbytes}}

The rawbytes keyword allows rules to look at the raw packet data, ignoring any
decoding that was done by preprocessors.  This acts as a modifier to the
previous content \ref{sub:content} option. 

\subsubsection{format}

\begin{verbatim}
rawbytes;
\end{verbatim}

\subsubsection{Example}

This example tells the content pattern matcher to look at the raw traffic,
instead of the decoded traffic provided by the Telnet decoder.
\begin{verbatim}
alert tcp any any -> any 21 (msg: "Telnet NOP"; content: "|FF F1|"; rawbytes;)
\end{verbatim}


\subsection{depth\label{sub:depth}}

The depth keyword allows the rule writer to specify how far into a packet Snort
should search for the specified pattern.  depth modifies the previous `content'
keyword in the rule.

A depth of 5 would tell Snort to only look look for the specified pattern
within the first 5 bytes of the payload.

As the depth keyword is a modifier to the previous `content' keyword, there
must be a content in the rule before `depth' is specified.

See Figure \ref{combined rule with offset and depth} for an example of a
combined content, offset, and depth search rule.

\subsubsection{Format}

\begin{verbatim}
depth: <number>;
\end{verbatim}

\subsection{offset\label{sub:offset}}

The offset keyword allows the rule writer to specify where to start searching
for a pattern within a packet.  offset modifies the previous 'content' keyword
in the rule.

An offset of 5 would tell Snort to start looking for the specified pattern
after the first 5 bytes of the payload.

As this keyword is a modifier to the previous 'content' keyword, there must be
a content in the rule before 'offset' is specified.

See Figure \ref{combined rule with offset and depth} for an example of a
combined content, offset, and depth search rule.

\subsubsection{Format}

\begin{verbatim}
offset: <number>;
\end{verbatim}


\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 80 (content: "cgi-bin/phf"; offset:4; depth:20;)
\end{verbatim}

\caption{\label{combined rule with offset and depth} Combined Content, Offset
and Depth Rule. Skip the first 4 bytes, and look for cgi-bin/phf in the next 20 bytes}
\end{figure}

\subsection{distance\label{sub:Distance}}

The distance keyword allows the rule writer to specify how far into a packet
Snort should ignore before starting to search for the specified pattern
relative to the end of the previous pattern match.  

This can be thought of as exactly the same thing as depth (See Section
\ref{sub:offset}), except it is relative to the end of the last pattern match
instead of the beginning of the packet.

\subsubsection{Format}

\begin{verbatim}
distance: <byte count>;
\end{verbatim}

\subsubsection{Example}

The rule listed in Figure \ref{fig:Distance} maps to a regular
expression of /ABCDE.\{1\}EFGH/.

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any any (content:"ABC"; content: "DEF"; distance:1;)
\end{verbatim}
\caption{distance usage example \label{fig:Distance}}
\end{figure}



\subsection{within\label{sub:Within}}

The within keyword is a content modifier that makes sure that
at most N bytes are between pattern matches using the Content ( See
Section \ref{sub:content} ).  It's designed to be used in conjunction
with the distance (Section \ref{sub:Distance}) rule option.

The rule listed in Figure \ref{fig:Within} constrains the search to not
go past 10 bytes past the ABCDE match. 

\subsubsection{Format}

\begin{verbatim}
within: <byte count>;
\end{verbatim}

\subsubsection{Examples}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any any (content:"ABC"; content: "EFG"; within:10;)
\end{verbatim}
\caption{within usage example \label{fig:Within}}
\end{figure}


\subsection{http\_client\_body\label{sub:HttpClientBody}}

The http\_client\_body keyword is a content modifier that restricts
the search to the NORMALIZED body of an HTTP client request.

The rule listed in Figure \ref{fig:HttpClientBody} constrains the
search for the pattern "EFG" to the NORMALIZED body of an HTTP client request.

As this keyword is a modifier to the previous 'content' keyword, there must be
a content in the rule before 'http\_client\_body' is specified.

\subsubsection{Format}

\begin{verbatim}
http_client_body;
\end{verbatim}

\subsubsection{Examples}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 80 (content:"ABC"; content: "EFG"; http_client_body;)
\end{verbatim}
\caption{http\_client\_body usage example \label{fig:HttpClientBody}}
\end{figure}

\begin{note}
The \texttt{http\_client\_body} modifier is not allowed to be used with
the \texttt{rawbytes} modifier for the same content.
\end{note}


\subsection{http\_uri\label{sub:HttpUri}}

The http\_uri keyword is a content modifier that restricts
the search to the NORMALIZED request \textsc{URI} field .  Using a
content rule option followed by a http\_uri modifier is the
same as using a uricontent by itself (see: \ref{sub:UriContent}).

The rule listed in Figure \ref{fig:HttpUri} constrains the
search for the pattern "EFG" to the NORMALIZED URI.

As this keyword is a modifier to the previous 'content' keyword, there must be
a content in the rule before 'http\_uri' is specified.

\subsubsection{Format}

\begin{verbatim}
http_uri;
\end{verbatim}

\subsubsection{Examples}

\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any -> any 80 (content:"ABC"; content: "EFG"; http_uri;)
\end{verbatim}
\caption{http\_uri usage example \label{fig:HttpUri}}
\end{figure}

\begin{note}
The \texttt{http\_uri} modifier is not allowed to be used with
the \texttt{rawbytes} modifier for the same content.
\end{note}

\subsection{uricontent\label{sub:UriContent}}

The \texttt{uricontent} parameter in the Snort rule language searches the
NORMALIZED request \textsc{URI} field.  This means that if you are writing
rules that include things that are normalized, such as \%2f or directory
traversals, these rules will not alert.  The reason is that the things you
are looking for are normalized out of the URI buffer.  

For example, the URI: 
\begin{verbatim}/scripts/..%c0%af../winnt/system32/cmd.exe?/c+ver\end{verbatim}
will get normalized into:
\begin{verbatim}/winnt/system32/cmd.exe?/c+ver

Another example, the URI:
\begin{verbatim} /cgi-bin/aaaaaaaaaaaaaaaaaaaaaaaaaa/..%252fp%68f? \end{verbatim}
will get normalized into:
\begin{verbatim}/cgi-bin/phf?\end{verbatim}

When writing a \texttt{uricontent} rule, write the content that you want to
find in the context that the URI will be normalized.  For example, if Snort
normalizes directory traversals, do not include directory traversals.  

You can write rules that look for the non-normalized content by using the
content option.  (See Section \ref{sub:content})

For a description of the parameters to this function, see the content rule
options in Section \ref{sub:content}. 

This option works in conjunction with the HTTP Inspect preprocessor specified
in Section \ref{sub:http-inspect}.

\subsubsection{Format}

\begin{verbatim}
uricontent:[!]<content string>;
\end{verbatim}

\begin{note}
\texttt{uricontent} cannot be modified by a \texttt{rawbytes} modifier.
\end{note}

\subsection{isdataat}

Verify that the payload has data at a specified location, optionally looking for data relative to the end of the previous content match.

\subsubsection{Format}

\begin{verbatim}
isdataat:<int>[,relative] [,rawbytes];
\end{verbatim}

\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\hline
\texttt{relative} & Use an offset relative to last pattern match\\
\hline
\texttt{rawbytes} & Do not use the decoded buffers \\
\hline
\end{tabular}


\subsubsection{Example}
\begin{verbatim}
alert tcp any any -> any 111 (content:"PASS"; isdataat:50,relative; \ 
   content:!"|0a|"; distance:0;)
\end{verbatim}
This rule looks for the string PASS exists in the packet, then verifies there
is at least 50 bytes after the end of the string PASS, then verifies that there
is not a newline character within 50 bytes of the end of the PASS string.

\subsection{pcre \label{pcre}}
The pcre keyword allows rules to be written using perl compatible regular expressions.   
For more detail on what can be done via a pcre regular expression, check out the PCRE web site \url{http://www.pcre.org}

\subsubsection{Format}
\begin{verbatim}
pcre:[!]"(/<regex>/|m<delim><regex><delim>)[ismxAEGRUB]";
\end{verbatim}
The post-re modifiers set compile time flags for the regular expression.

\begin{longtable}{|c|p{3.5in}|}
\caption{Perl compatible modifiers} \\
\hline
i & case insensitive \\
\hline
s & include newlines in the dot metacharacter \\
\hline
m & By default, the string is treated as one big line of characters.  \^\ and \$ match at the beginning and ending of the string. When m is set, \^\ and \$  match immediately following or immediately before any newline in the buffer, as well as the very start and very end of the buffer. \\
\hline
x & whitespace  data characters in the pattern are ignored except when escaped or inside a character class \\
\hline
\end{longtable}

\begin{longtable}{|c|p{3.5in}|}
\caption{PCRE compatible modifiers} \\
\hline
A & the pattern must match only at the start of the buffer (same as \^\ ) \\
\hline
E & Set \$ to match only at the end of the subject string.  Without E, \$ also matches immediately before the final character if it is a newline (but not before any other newlines). \\
\hline
G & Inverts the "greediness" of the quantifiers so that they are not greedy by default, but become greedy if followed by "?". \\
\hline
\end{longtable}

\begin{longtable}{|c|p{3.5in}|}
\caption{Snort specific modifiers} \\
\hline
R & Match relative to the end of the last pattern match.  (Similar to distance:0;) \\
\hline
U & Match the decoded URI buffers (Similar to \texttt{uricontent}) \\
\hline
B & Do not use the decoded buffers (Similar to rawbytes) \\
\hline
\end{longtable}

The modifiers R and B should not be used together.

\subsubsection{Example}

This example performs a case-insensitive search for the string BLAH in the payload.

\begin{verbatim}
alert ip any any -> any any (pcre:"/BLAH/i";)
\end{verbatim}

\begin{note}
Snort's handling of multiple URIs with PCRE does not work as expected.  PCRE when used without a \texttt{uricontent} only evaluates the first URI.  In order to use pcre to inspect all URIs, you must use either a content or a uricontent.
\end{note}

\subsection{byte\_test\label{sub:byte_test}}

Test a byte field against a specific value (with operator).  Capable
 of testing binary values or converting representative byte strings to
their binary equivalent and testing them.

For a more detailed explanation, please read Section \ref{testing numerical values}.

\subsubsection{Format}

\begin{verbatim}
byte_test: <bytes to convert>, [!]<operator>, <value>, <offset>  \
    [,relative] [,<endian>] [,<number type>, string];
\end{verbatim}
			
	
\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{bytes\_to\_convert} & Number of bytes to pick up from the packet\\
\hline
\texttt{operator} & Operation to perform to test the value:
\begin{itemize}
\item $<$ - less than
\item $>$ - greater than
\item = - equal
\item ! - not
\item \& - bitwise AND
\item \^ - bitwise OR
\end{itemize}\\
\hline
\texttt{value} & Value to test the converted value against\\
\hline
\texttt{offset} & Number of bytes into the payload to start processing\\
\hline
\texttt{relative} & Use an offset relative to last pattern match\\
\hline
\texttt{endian} & Endian type of the number being read: 
\begin{itemize}
\item \texttt{big} - Process data as big endian (default)
\item \texttt{little} - Process data as little endian
\end{itemize}\\
\hline
\texttt{string} & Data is stored in string format in packet\\
\hline
\texttt{number type} & Type of number being read:
\begin{itemize}
\item \texttt{hex} - Converted string data is represented in hexadecimal
\item \texttt{dec} - Converted string data is represented in decimal
\item \texttt{oct} - Converted string data is represented in octal
\end{itemize}\\
\hline
\end{tabular}

Any of the operators can also include \emph{!} to check if the operator is not true.  
If \emph{!} is specified without an operator, then the operator is set to \emph{=}.

\begin{note}
Snort uses the C operators for each of these operators.  If the \emph{\&} operator is used, 
then it would be the same as using \emph{if (data \& value) \{ do\_something();\} }
\end{note}

\begin{figure}[!hbpt]
\begin{verbatim}
alert udp $EXTERNAL_NET any -> $HOME_NET any \
       (msg:"AMD procedure 7 plog overflow "; \
       content: "|00 04 93 F3|"; \
       content: "|00 00 00 07|"; distance: 4; within: 4; \
       byte_test: 4,>, 1000, 20, relative;)

alert tcp $EXTERNAL_NET any -> $HOME_NET any \
     (msg:"AMD procedure 7 plog overflow "; \
     content: "|00 04 93 F3|"; \
     content: "|00 00 00 07|"; distance: 4; within: 4; \
     byte_test: 4, >,1000, 20, relative;)

alert udp any any -> any 1234 \
     (byte_test: 4, =, 1234, 0, string, dec; \
     msg: "got 1234!";)

alert udp any any -> any 1235 \
     (byte_test: 3, =, 123, 0, string, dec; \
     msg: "got 123!";)

alert udp any any -> any 1236 \
     (byte_test: 2, =, 12, 0, string, dec; \
     msg: "got 12!";)

alert udp any any -> any 1237 \
     (byte_test: 10, =, 1234567890, 0, string, dec; \
     msg: "got 1234567890!";)

alert udp any any -> any 1238 \
     (byte_test: 8, =, 0xdeadbeef, 0, string, hex; \
     msg: "got DEADBEEF!";)
\end{verbatim}
\caption{Byte Test Usage Example \label{fig:byte_test}}
\end{figure}

\subsection{byte\_jump\label{sub:byte_jump}}

The \texttt{byte\_jump} option allows rules to be written for length encoded protocols 
trivially. By having an option that reads the length of a portion of data,
then skips that far forward in the packet, rules can be written that skip
over specific portions of length-encoded protocols and perform detection in very specific locations.

The \texttt{byte\_jump} option does this by reading some number of bytes, convert them
to their numeric representation, move that many bytes forward and set a pointer
for later detection.  This pointer is known as the detect offset end pointer, or doe\_ptr.

For a more detailed explanation, please read Section \ref{testing numerical values}.

\subsubsection{Format}

\begin{verbatim}
byte_jump: <bytes_to_convert>, <offset> \
        [,relative] [,multiplier <multiplier value>] [,big] [,little][,string]\
        [,hex] [,dec] [,oct] [,align] [,from_beginning];
\end{verbatim}

\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{bytes\_to\_convert} & Number of bytes to pick up from the packet\\
\hline
\texttt{offset} & Number of bytes into the payload to start processing\\
\hline
\texttt{relative} & Use an offset relative to last pattern match\\
\hline
\texttt{multiplier $<$value$>$} & Multiply the number of calculated bytes by
\texttt{$<$value$>$} and skip forward that number of bytes.\\
\hline
\texttt{big} & Process data as big endian (default)\\
\hline
\texttt{little} & Process data as little endian\\
\hline
\texttt{string} & Data is stored in string format in packet\\
\hline
\texttt{hex} & Converted string data is represented in hexadecimal\\
\hline
\texttt{dec} & Converted string data is represented in decimal\\
\hline
\texttt{oct} & Converted string data is represented in octal\\
\hline
\texttt{align} & Round the number of converted bytes up to the next 32-bit boundary\\
\hline
\texttt{from\_beginning} & Skip forward from the beginning of the packet payload instead of from the
current position in the packet.\\
\hline
\end{tabular}

\begin{figure}[!hbpt]
\begin{verbatim}
alert udp any any -> any 32770:34000 (content: "|00 01 86 B8|"; \
              content: "|00 00 00 01|"; distance: 4; within: 4; \
              byte_jump: 4, 12, relative, align; \
              byte_test: 4, >, 900, 20, relative; \
              msg: "statd format string buffer overflow";)
\end{verbatim}
\caption{byte jump Usage Example \label{fig:byte_jump}}
\end{figure}

\subsection{ftpbounce}

The ftpbounce keyword detects FTP bounce attacks.

\subsubsection{Format}
                                                                                
\begin{verbatim}
	ftpbounce;
\end{verbatim}

\subsubsection{Example}
\begin{verbatim}
alert tcp $EXTERNAL_NET any -> $HOME_NET 21 (msg:"FTP PORT bounce attempt"; \
flow:to_server,established; content:"PORT"; nocase; ftpbounce; pcre:"/^PORT/smi";\
classtype:misc-attack; sid:3441; rev:1;)
\end{verbatim}

\subsection{regex}

The regex keyword has been superceded by PCRE.  See Section \ref{pcre}.

\subsection{content-list}

The content-list keyword is broken and should not be used.

%The content-list keyword allows multiple content strings to be specified
%in the place of a single content option. The patterns to be searched
%for must each be on a single line of content-list file as shown in
%Figure \ref{content-list example}, but they are treated otherwise
%identically to content strings specified as an argument to a standard
%content directive. This option is the basis for the react keyword.
%
%%
%\begin{figure}[!hbpt]
%\begin{verbatim}
%# adult sites 
%"porn"
%"porn"
%"adults"
%"hard core"
%"www.pornsite.com"
%\end{verbatim}
%\caption{\label{content-list example}Content-list adults
%file example}
%\end{figure}
%
%
%\subsubsection{Format}
%
%\begin{verbatim}
%content-list: <file_name>;
%\end{verbatim}


\section{Non-Payload Detection Rule Options}
\subsection{fragoffset \label{fragoffset section}}

The fragoffset keyword allows one to compare the IP fragment offset
field against a decimal value. To catch all the first fragments of
an IP session, you could use the fragbits keyword and look for the
More fragments option in conjunction with a fragoffset of 0.


\subsubsection{Format}

\begin{verbatim}
fragoffset:[<|>]<number>
\end{verbatim}

\begin{figure}[!hbpt]
\begin{verbatim}
alert ip any any -> any any \
      (msg: "First Fragment"; fragbits: M; fragoffset: 0;)
\end{verbatim}
\caption{Fragoffset Usage Example \label{fragoffset usage example}}
\end{figure}


\subsection{ttl}

The ttl keyword is used to check the IP time-to-live value.  This option
keyword was intended for use in the detection of traceroute attempts.

\subsubsection{Format}

\begin{verbatim}
ttl:[[<number>-]><=]<number>;
\end{verbatim}

\subsubsection{Example}

This example checks for a time-to-live value that is less than 3.
\begin{verbatim}
ttl:<3;
\end{verbatim}

This example checks for a time-to-live value that between 3 and 5.
\begin{verbatim}
ttl:3-5;
\end{verbatim}

\subsection{tos}

The tos keyword is used to check the IP TOS field for a specific value. 

\subsubsection{Format}

\begin{verbatim}
tos:[!]<number>;
\end{verbatim}

\subsubsection{Example}

This example looks for a tos value that is not 4
\begin{verbatim}
tos:!4;
\end{verbatim}

\subsection{id}

The id keyword is used to check the IP ID field for a specific value.  Some
tools (exploits, scanners and other odd programs) set this field specifically
for various purposes, for example, the value 31337 is very popular with some
hackers. 

\subsubsection{Format}

\begin{verbatim}
id:<number>;
\end{verbatim}

\subsubsection{Example}

This example looks for the IP ID of 31337.
\begin{verbatim}
id:31337;
\end{verbatim}

\subsection{ipopts}

The ipopts keyword is used to check if a specific IP option is present.

The following options may be checked:
\begin{description}
\item [rr] - Record route 
\item [eol] - End of list 
\item [nop] - No op 
\item [ts] - Time Stamp 
\item [sec] - IP security option 
\item [lsrr] - Loose source routing 
\item [ssrr] - Strict source routing 
\item [satid] - Stream identifier
\item [any] - any IP options are set
\end{description}

The most frequently watched for IP options are strict and loose source
routing which aren't used in any widespread internet applications.


\subsubsection{Format}

\begin{verbatim}
ipopts:<rr|eol|nop|ts|sec|lsrr|ssrr|satid|any>;
\end{verbatim}

\subsubsection{Example}
This example looks for the IP Option of Loose Source Routing.
\begin{verbatim}
ipopts:lsrr;
\end{verbatim}

\subsubsection{Warning}
Only a single ipopts keyword may be specified per rule.

\subsection{fragbits}

The \texttt{fragbits} keyword is used to check if fragmentation and reserved bits are set in the IP header.

The following bits may be checked:
\begin{description}
\item [M] - More Fragments
\item [D] - Don't Fragment
\item [R] - Reserved Bit
\end{description}

The following modifiers can be set to change the match criteria:
\begin{description}
\item [+] match on the specified bits, plus any others
\item [*] match if any of the specified bits are set
\item [!] match if the specified bits are not set
\end{description}

\subsubsection{Format}

\begin{verbatim}
fragbits:[+*!]<[MDR]>
\end{verbatim}

\subsubsection{Example}

This example checks if the More Fragments bit and the Do not Fragment bit are
set.
\begin{verbatim}
fragbits:MD+;
\end{verbatim}

\subsection{dsize}

The dsize keyword is used to test the packet payload size.  This may be used to check for abnormally sized packets.  In many cases, it is useful for detecting buffer overflows.

\subsubsection{Format}
\begin{verbatim}
dsize: [<>]<number>[<><number>];
\end{verbatim}

\subsubsection{Example}
This example looks for a dsize that is between 300 and 400 bytes.
\begin{verbatim}
dsize:300<>400;
\end{verbatim}

\subsubsection{Warning}
dsize will fail on stream rebuilt packets, regardless of the size of the
payload.

\subsection{flags}

The flags keyword is used to check if specific TCP flag bits are present.

The following bits may be checked:
\begin{description}
\item [F] - FIN (LSB in TCP Flags byte)
\item [S] - SYN 
\item [R] - RST 
\item [P] - PSH 
\item [A] - ACK 
\item [U] - URG 
\item [1] - Reserved bit 1 (MSB in TCP Flags byte)
\item [2] - Reserved bit 2 
\item [0] - No TCP Flags Set
\end{description}

The following modifiers can be set to change the match criteria:
\begin{description}
\item [+] - match on the specified bits, plus any others
\item [*] - match if any of the specified bits are set
\item [!] - match if the specified bits are not set
\end{description}

To handle writing rules for session initiation packets such as ECN where a SYN
packet is sent with the previously reserved bits 1 and 2 set, an option mask
may be specified. A rule could check for a flags value of S,12 if one wishes to
find packets with just the syn bit, regardless of the values of the reserved
bits.

\subsubsection{Format}

\begin{verbatim}
flags:[!|*|+]<FSRPAU120>[,<FSRPAU120>];
\end{verbatim}

\subsubsection{Example}

This example checks if just the SYN and the FIN bits are set, ignoring reserved
bit 1 and reserved bit 2.
\begin{verbatim}
alert tcp any any -> any any (flags:SF,12;)
\end{verbatim}

\subsection{flow\label{flow section}}

The flow rule option is used in conjunction with TCP stream reassembly
(see Section \ref{stream 4 section}). It allows rules to only apply
to certain directions of the traffic flow. 

This allows rules to only apply to clients or servers. This allows
packets related to \$HOME\_NET clients viewing web pages to be distinguished
from servers running the \$HOME\_NET.

The established keyword will replace the \texttt{flags: A+} used in
many places to show established TCP connections.

\subsubsection*{Options}

\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{to\_client} & Trigger on server responses from A to B\\
\hline
\texttt{to\_server} & Trigger on client requests from A to B\\
\hline
\texttt{from\_client} & Trigger on client requests from A to B\\
\hline
\texttt{from\_server} & Trigger on server responses from A to B\\
\hline
\texttt{established} & Trigger only on established TCP connections\\
\hline
\texttt{stateless} & Trigger regardless of the state of the stream processor
(useful for packets that are designed to cause machines to crash)\\
\hline
\texttt{no\_stream} & Do not trigger on rebuilt stream packets (useful 
for dsize and stream4)\\
\hline
\texttt{only\_stream} & Only trigger on rebuilt stream
packets\\
\hline
\end{tabular}

\subsubsection{Format}

\begin{verbatim}
flow: [(established|stateless)] 
      [,(to_client|to_server|from_client|from_server)]
      [,(no_stream|only_stream)]
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp !$HOME_NET any -> $HOME_NET 21 (msg:"cd incoming detected"; \
    flow:from_client; content:"CWD incoming"; nocase;)

alert tcp !$HOME_NET 0 -> $HOME_NET 0 (msg: "Port 0 TCP traffic"; \
    flow:stateless;)
\end{verbatim}

\caption{Flow usage examples\label{flow usage examples}}
\end{figure}

\subsection{flowbits\label{flowbits}}

The \texttt{flowbits} rule option is used in conjunction with conversation
tracking from the Flow preprocessor (see Section\ref{sub:flow}).  It allows
rules to track states across transport protocol sessions.  The flowbits option
is most useful for TCP sessions, as it allows rules to generically track the
state of an application protocol.

There are seven keywords associated with flowbits. Most of the options need a
user-defined name for the specific state that is being checked.  This string
should be limited to any alphanumeric string including periods, dashes, and
underscores.

\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{set} & Sets the specified state for the current flow.\\
\hline
\texttt{unset} & Unsets the specified state for the current flow.\\
\hline
\texttt{toggle} & Sets the specified state if the state is unset, otherwise unsets the 
state if the state is set.\\
\hline
\texttt{isset} & Checks if the specified state is set.\\
\hline
\texttt{isnotset} & Checks if the specified state is not set.\\
\hline
\texttt{noalert} & Cause the rule to not generate an alert, regardless of the rest of the detection options.\\
\hline
\end{tabular}

\subsubsection{Format}

\begin{verbatim}
flowbits: [set|unset|toggle|isset,reset,noalert][,<STATE_NAME>];
\end{verbatim}




\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any 143 -> any any (msg:"IMAP login"; 
  content:"OK LOGIN"; flowbits:set,logged_in; 
  flowbits:noalert;)
  
alert tcp any any -> any 143 (msg:"IMAP LIST"; content:"LIST"; 
  flowbits:isset,logged_in;)
\end{verbatim}

\caption{Flowbits Usage Examples\label{flowbits usage examples}}
\end{figure}

\subsection{seq}

The seq keyword is used to check for a specific TCP sequence number.

\subsubsection{Format}
\begin{verbatim}
seq:<number>;
\end{verbatim}

\subsubsection{Example}
This example looks for a TCP sequence number of 0.

\begin{verbatim}
seq:0;
\end{verbatim}


\subsection{ack}

The ack keyword is used to check for a specific TCP acknowledge number.

\subsubsection{Format}
\begin{verbatim}
ack: <number>;
\end{verbatim}

\subsubsection{Example}
This example looks for a TCP acknowledge number of 0.
\begin{verbatim}
ack:0;
\end{verbatim}

\subsection{window}

The window keyword is used to check for a specific TCP window size.

\subsubsection{Format}

\begin{verbatim}
window:[!]<number>;
\end{verbatim}

\subsubsection{Example}
This example looks for a TCP window size of 55808.
\begin{verbatim}
window:55808;
\end{verbatim}

\subsection{itype}

The itype keyword is used to check for a specific ICMP type value.

\subsubsection{Format}

\begin{verbatim}
itype:[<|>]<number>[<><number>];
\end{verbatim}

\subsubsection{Example}

This example looks for an ICMP type greater than 30.
\begin{verbatim}
itype:>30;
\end{verbatim}

\subsection{icode}

The itype keyword is used to check for a specific ICMP code value.

\subsubsection{Format}
\begin{verbatim}
icode: [<|>]<number>[<><number>];
\end{verbatim}

\subsubsection{Example}
This example looks for an ICMP code greater than 30.
\begin{verbatim}
code:>30;
\end{verbatim}

\subsection{icmp\_id}

The itype keyword is used to check for a specific ICMP ID value.

This is useful because some covert channel programs use static ICMP fields when
they communicate.  This particular plugin was developed to detect the
stacheldraht DDoS agent.

\subsubsection{Format}

\begin{verbatim}
icmp_id:<number>;
\end{verbatim}

\subsubsection{Example}

This example looks for an ICMP ID of 0.
\begin{verbatim}
icmp_id:0;
\end{verbatim}

\subsection{icmp\_seq}

The itype keyword is used to check for a specific ICMP sequence value.

This is useful because some covert channel programs use static ICMP fields when
they communicate.  This particular plugin was developed to detect the
stacheldraht DDoS agent.

\subsubsection{Format}

\begin{verbatim}
icmp_seq: <number>;
\end{verbatim}

\subsubsection{Example}

This example looks for an ICMP Sequence of 0.
\begin{verbatim}
icmp_seq:0;
\end{verbatim}

\subsection{rpc}

The rpc keyword is used to check for a RPC application, version, and procedure numbers in SUNRPC CALL requests.

Wildcards are valid for both version and procedure numbers by using '*';

\subsubsection{Format}

\begin{verbatim}
rpc: <application number>, [<version number>|*], [<procedure number>|*]>;
\end{verbatim}

\subsubsection{Example}

The following example looks for an RPC portmap GETPORT request.

\begin{verbatim}
alert tcp any any -> any 111 (rpc: 100000,*,3;);
\end{verbatim}

\subsubsection{Warning}

Because of the fast pattern matching engine, the RPC keyword is slower than looking for the RPC values by using normal content matching.

\subsection{ip\_proto}

The ip\_proto keyword allows checks against the IP protocol header.  For a list
of protocols that may be specified by name, see /etc/protocols. 

\subsubsection{Format}

\begin{verbatim}
ip_proto:[!><] <name or number>;
\end{verbatim}

\subsubsection{Example}
This example looks for IGMP traffic.

\begin{verbatim}
alert ip any any -> any any (ip_proto:igmp;)
\end{verbatim}

\subsection{sameip}

The sameip keyword allows rules to check if the source ip is the same as the destination IP.

\subsubsection{Format}

\begin{verbatim}
sameip;
\end{verbatim}

\subsubsection{Example}

This example looks for any traffic where the Source IP and the Destination IP is the same.

\begin{verbatim}
alert ip any any -> any any (sampeip;)
\end{verbatim}


\section{Post-Detection Rule Options}
\subsection{logto}

The logto option tells Snort to log all packets that trigger this rule to a
special output log file. This is especially handy for combining data from
things like NMAP activity, HTTP CGI scans, etc. It should be noted that this
option does not work when Snort is in binary logging mode.

\subsubsection{Format}

\begin{verbatim}
logto:"filename";
\end{verbatim}

\subsection{session}

The session keyword is built to extract user data from TCP Sessions.  There are
many cases where seeing what users are typing in telnet, rlogin, ftp, or even
web sessions is very useful. 

There are two available argument keywords for the session rule option,
printable or all. The printable keyword only prints out data that the user
would normally see or be able to type. 

The all keyword substitutes non-printable characters with their hexadecimal
equivalents. 

\subsubsection{Format}

\begin{verbatim}
session: [printable|all];
\end{verbatim}

\subsubsection{Example}
The following example logs all printable strings in a telnet packet.
\begin{verbatim}
log tcp any any <> any 23 (session:printable;)
\end{verbatim}

\subsubsection{Warnings}
Using the session keyword can slow Snort down considerably, so it should not be
used in heavy load situations. The session keyword is best suited for
post-processing binary (pcap) log files. 

\subsection{resp}

The resp keyword is used attempt to close sessions when an alert is triggered.  In Snort, this is called flexible response.

Flexible Response supports the following mechanisms for attempting to close
sessions:

\begin{tabular}{| l | p{5in} |}
\hline
{\bf Option} & {\bf Description}\\
\hline
\hline
\texttt{rst\_snd} &  Send TCP-RST packets to the sending socket\\
\hline 
\texttt{rst\_rcv} & Send TCP-RST packets to the receiving socket\\
\hline 
\texttt{rst\_all} & Send TCP\_RST packets in both directions\\
\hline 
\texttt{icmp\_net} & Send a ICMP\_NET\_UNREACH to the sender\\
\hline 
\texttt{icmp\_host} & Send a ICMP\_HOST\_UNREACH to the sender\\
\hline 
\texttt{icmp\_port} & Send a ICMP\_PORT\_UNREACH to the sender\\
\hline 
\texttt{icmp\_all} & Send all above ICMP packets to the sender\\
\hline
\end{tabular}

These options can be combined to send multiple responses to the target host.

\subsubsection{Format}

\begin{verbatim}
resp: <resp_mechanism>[,<resp_mechanism>[,<resp_mechanism>]];
\end{verbatim}

\subsubsection{Warnings}

This functionality is not built in by default.  Use the -- --enable-flexresp flag
to configure when building Snort to enable this functionality.

Be very careful when using Flexible Response. It is quite easy to get Snort
into an infinite loop by defining a rule such as:

\begin{verbatim}
alert tcp any any -> any any (resp:rst_all;)
\end{verbatim}

It is easy to be fooled into interfering with normal network traffic as well.

\subsubsection{Example}

The following example attempts to reset any TCP connection to port 1524.
\begin{verbatim}
alert tcp any any -> any 1524 (flags:S; resp:rst_all;)
\end{verbatim}


\subsection{react}

This keyword implements an ability for users to react to traffic that
matches a Snort rule. The basic reaction is blocking interesting sites
users want to access: New York Times, slashdot, or something really
important - napster and porn sites. The React code allows Snort to
actively close offending connections and/or send a visible notice to the
browser. The notice may include your own comment. The following arguments
(basic modifiers) are valid for this option:

\begin{itemize}
\item block - close connection and send the visible notice 
\item warn - send the visible, warning notice (will be available soon) 
\end{itemize}
The basic argument may be combined with the following arguments (additional
modifiers): 

\begin{itemize}
\item msg - include the msg option text into the blocking visible notice 
\item proxy: $<$port\_nr$>$ - use the proxy port to send the visible notice
(will be available soon)
\end{itemize}
Multiple additional arguments are separated by a comma. The react
keyword should be placed as the last one in the option list.


\subsubsection{Format}

\begin{verbatim}
react: <react_basic_modifier[, react_additional_modifier]>;
\end{verbatim}
%
\begin{figure}[!hbpt]
\begin{verbatim}
alert tcp any any <> 192.168.1.0/24 80 (content: "bad.htm"; \
    msg: "Not for children!"; react: block, msg;) 
\end{verbatim}
\caption{\label{react examples}React Usage Example}
\end{figure}

\subsubsection{Warnings}

React functionality is not built in by default.  This code is currently bundled
under Flexible Response, so enabling Flexible Response (--enable-flexresp)
will also enable React.  

Be very careful when using react.  Causing a network traffic generation
loop is very easy to do with this functionality.


\subsection{tag \label{tag section}}

The tag keyword allow rules to log more than just the single packet that
triggered the rule. Once a rule is triggered, additional traffic involving the
source and/or destination host is \emph{tagged}. Tagged traffic is logged to
allow analysis of response codes and post-attack traffic.  \emph{tagged} alerts
will be sent to the same output plugins as the original alert, but it is the
responsibility of the output plugin to properly handle these special alerts.
Currently, the database output plugin, described in Section \ref{database 
section}, does not properly handle \emph{tagged} alerts.


\subsubsection{Format}

\begin{verbatim}
tag: <type>, <count>, <metric>, [direction]
\end{verbatim}

\begin{description}{}
  \item [\texttt{type}]~
     \begin{itemize}{}
     \item \texttt{session} - Log packets in the session that set off the rule 
     \item \texttt{host} - Log packets from the host that caused the tag to activate (uses {[}direction{]} modifier)
     \end{itemize}
  \item [\texttt{count}] - Count is specified as a number of units. Units are specified in the $<$metric$>$ field.
  \item [\texttt{metric}]~
  \begin{itemize}{}
      \item \texttt{packets} - Tag the host/session for $<$count$>$ packets 
      \item \texttt{seconds} - Tag the host/session for $<$count$>$ seconds
   \end{itemize}
\end{description}

Note, any packets that generate an alert will not be tagged.  For example, it may seem that the following rule will tag the first 600 seconds of any packet involving 10.1.1.1.
\begin{verbatim}
alert tcp any any <> any 10.1.1.1 (tag:host,600,seconds,src;)
\end{verbatim}

However, since the rule will fire on every packet involving 10.1.1.1, no packets will get tagged.  The \emph{flowbits} option would be useful here.

\begin{verbatim}
alert tcp any any <> any 10.1.1.1 (flowbits:isnotset,tagged; 
    flowbits:set,tagged; tag:host,600,seconds,src;)
\end{verbatim}

\subsubsection{Example}

This example logs the first 10 seconds of any telnet session.
\begin{verbatim}
alert tcp any any -> any 23 (flags:s,12; tag:session,10,seconds;)
\end{verbatim}


\section{Event Thresholding\label{Event Thresholding}}

Event thresholding can be used to reduce the number of logged alerts for noisy
rules.  This can be tuned to significantly reduce false alarms, and it can also
be used to write a newer breed of rules. Thresholding commands limit the number
of times a particular event is logged during a specified time interval. 

There are 3 types of thresholding:

\begin{itemize} 

\item \texttt{limit} 

Alerts on the 1st \textit{m} events during the time interval, then ignores events for the
rest of the time interval.

\item \texttt{threshold} 

Alerts every \textit{m} times we see this event during the time interval.

\item \texttt{both} 

Alerts once per time interval after seeing \textit{m} occurrences of the event, then
ignores any additional events during the time interval.
\end{itemize}


Thresholding commands can be included as part of a rule, or you can use
standalone threshold commands that reference the generator and SID they are
applied to. There is no functional difference between adding a threshold to a
rule, or using a separate threshold command applied to the same rule.   There
is a logical difference.  Some rules may only make sense with a threshold.
These should incorporate the threshold command into the rule.  For instance, a
rule for detecting a too many login password attempts may require more than 5
attempts.  This can be done using the `limit' type of threshold command.  It
makes sense that the threshold feature is an integral part of this rule.

In order for rule thresholds to apply properly, these rules must contain a
SID.

Only one threshold may be applied to any given generator and SID pair.  If more
than one threshold is applied to a generator and SID pair, Snort will terminate
with an error while reading the configuration information. 
                 
\subsection{Standalone Options}

This format supports 6 threshold options as described in Table \ref{standalone_options}---all are required.

\begin{table}[!htbp]
\caption{Standalone Options\label{standalone_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Arguments}\\
\hline
\hline
\texttt{gen\_id} & $<$generator ID$>$\\
\hline
\texttt{sig\_id} & $<$Snort signature ID$>$ \\
\hline
\texttt{type} & \texttt{limit}, \texttt{threshold}, or \texttt{both} \\
\hline
\texttt{track} & \texttt{by\_src} or \texttt{by\_dst} \\
\hline
\texttt{count} & $<$number of events$>$ \\
\hline
\texttt{seconds} & $<$time period over which count is accrued$>$ \\
\hline
\end{tabular}\end{center}
\end{table}

\subsection{Standalone Format}
\begin{verbatim}
threshold gen_id <gen-id>, sig_id <sig-id>, \
    type <limit|threshold|both>, \
    track <by_src|by_dst>, count <s>, seconds <m>  
\end{verbatim}


\subsection{Rule Keyword Format}

This format supports 4 threshold options as described in Table \ref{rule_keyword_options}---all are required.

\begin{table}[!hbpt]
\caption{Rule Keyword Options\label{rule_keyword_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} |}
\hline
\textbf{Option} & \textbf{Arguments}\\
\hline
\hline
\texttt{type} & \texttt{limit}, \texttt{threshold}, or \texttt{both} \\
\hline
\texttt{track} & \texttt{by\_src} or \texttt{by\_dst} \\
\hline
\texttt{count} & $<$number of events$>$ \\
\hline
\texttt{seconds} & $<$time period over which count is accrued$>$ \\
\hline
\end{tabular}\end{center}
\end{table}

\subsection{Rule Keyword Format}
\begin{verbatim}
threshold: type <limit|threshold|both>, track <by_src|by_dst>, \
     count <n>, seconds <m>;
\end{verbatim}

For either standalone or rule format, all tracking is by src or by dst ip,
ports or anything else are not tracked.

Thresholding can also be used globally, this allows you to specify a threshold
for every rule.  Standard thresholding tests are applied first to an event, if
they do not block a rule from being logged, and then the global thresholding
test is applied---thresholds in a rule will override a global threshold. Global 
thresholds do not override what's in a signature or a more specific stand-alone 
threshold.


The global threshold options are the same as the standard threshold options
with the exception of the `\texttt{sig\_id}' field.  The \texttt{sig\_id} field must be set to 0 to
indicate that this threshold command applies to all \texttt{sig\_id} values with the specified
\texttt{gen\_id}. To apply the same threshold to all \texttt{gen\_id}'s at the same time, and with
just one command specify a value of \texttt{gen\_id=0}.

The format for global threshold commands is as such:

\begin{verbatim}
threshold gen_id <gen-id>, sig_id 0, \
    type <limit|threshold|both>, \
    track <by_src|by_dst>, \
    count <n>, \
    seconds <m>  
\end{verbatim}

This applies a threshold to every event from $<$gen-id$>$.

or 

\begin{verbatim}
threshold gen_id 0 , sig_id 0, \
    type <limit|threshold|both>, \
    track <by_src|by_dst>, \
    count <n>, \
    seconds <m>
\end{verbatim}

This applies a threshold to every event from every gen-id. 

\subsection{Examples}
\subsubsection{Standalone Thresholds}

Limit logging to 1 event per 60 seconds:
\begin{verbatim}
threshold gen_id 1, sig_id 1851, \
    type limit, track by_src,  \
    count 1, seconds 60
\end{verbatim}

Limit logging to every 3rd event:
\begin{verbatim}
threshold gen_id 1, sig_id 1852,  \
    type threshold, track by_src, \
    count 3, seconds 60
\end{verbatim}

Limit logging to just 1 event per 60 seconds, but only if we exceed 30 events in 60 seconds:
\begin{verbatim}
threshold gen_id 1, sig_id 1853, \
    type both, track by_src, \
    count 30, seconds 60
\end{verbatim}

\subsubsection{Rule Thresholds}

This rule logs the first event of this SID every 60 seconds.

\begin{verbatim}
alert tcp $external_net any -> $http_servers $http_ports \
    (msg:"web-misc robots.txt access"; flow:to_server, established; \
    uricontent:"/robots.txt"; nocase; reference:nessus,10302; \
    classtype:web-application-activity; threshold: type limit, track \
    by_src, count 1 , seconds 60 ; sid:1000852; rev:1;)
\end{verbatim}
                 

This rule logs every 10th event on this SID during a 60 second interval. So if
less than 10 events occur in 60 seconds, nothing gets logged.  Once an event is
logged, a new time period starts for type=threshold.

\begin{verbatim}
alert tcp $external_net any -> $http_servers $http_ports \
    (msg:"web-misc robots.txt access"; flow:to_server, established; \
    uricontent:"/robots.txt"; nocase; reference:nessus,10302; \
    classtype:web-application-activity; threshold: type threshold, \
    track by_dst, count 10 , seconds 60 ; sid:1000852; rev:1;)
\end{verbatim}


This rule logs at most one event every 60 seconds if at least 10 events on this SID are fired.

\begin{verbatim}
alert tcp $external_net any -> $http_servers $http_ports \
    (msg:"web-misc robots.txt access"; flow:to_server, established; \
    uricontent:"/robots.txt"; nocase; reference:nessus,10302; \
    classtype:web-application-activity; threshold: type both , track \
    by_dst, count 10 , seconds 60 ; sid:1000852; rev:1;)
\end{verbatim}

\subsubsection{Global Thresholds}

Limit to logging 1 event per 60 seconds per IP triggering each rule (rule gen\_id is 1):
\begin{verbatim}
threshold gen_id 1, sig_id 0, type limit, track by_src, count 1, seconds 60
\end{verbatim}

Limit to logging 1 event per 60 seconds per IP, triggering each rule for each event generator:
\begin{verbatim}
threshold gen_id 0, sig_id 0, type limit, track by_src, count 1, seconds 60
\end{verbatim}

Events in Snort are generated in the usual way, thresholding is handled as part
of the output system. Read gen-msg.map for details on gen ids.

Users can also configure a memcap for threshold with a ``config:'' option:

\begin{verbatim}
config threshold: memcap <bytes>
\end{verbatim}

\clearpage
\section{Event Suppression}
Event suppression stops specified events from firing without removing the rule
from the rule base. Suppression uses a CIDR block notation to select specific
networks and users for suppression.  Suppression tests are performed prior to
either standard or global thresholding tests.

Suppression commands are standalone commands that reference generators, SIDs,
and IP addresses via a CIDR block. This allows a rule to be completely
suppressed, or suppressed when the causative traffic is going to or coming
from a specific IP or group of IP addresses.

You may apply multiple suppression commands to a SID.  You may also combine one
threshold command and several suppression commands to the same SID.  

\subsection{Format}

The suppress command supports either 2 or 4 options, as described in Table \ref{suppression_options}. 

\begin{table}[!hbpt]
\caption{Suppression Options\label{suppression_options}}
\begin{center}\begin{tabular}{| l | p{3.5in} | l |}
\hline
\textbf{Option} & \textbf{Argument} & \textbf{Required?}\\
\hline
\hline
\texttt{gen\_id} & $<$generator id$>$ & required\\
\hline
\texttt{sig\_id} & $<$Snort signature id$>$  & required\\
\hline
\texttt{track} & \texttt{by\_src} or \texttt{by\_dst}  & optional, requires ip\\
\hline
\texttt{ip} & ip[/mask] & optional, requires track \\
\hline
\end{tabular}\end{center}
\end{table}

\begin{verbatim}
suppress gen_id <gen-id>, sig_id <sig-id>, \
    track <by_src|by_dst>, ip <ip|mask-bits>
\end{verbatim}

\subsection{Examples}
Suppress this event completely:
\begin{verbatim}
suppress gen_id 1, sig_id 1852:
\end{verbatim}

Suppress this event from this IP:
\begin{verbatim}
suppress gen_id 1, sig_id 1852, track by_src, ip 10.1.1.54
\end{verbatim}

Suppress this event to this CIDR block:
\begin{verbatim}
suppress gen_id 1, sig_id 1852, track by_dst, ip 10.1.1.0/24
\end{verbatim}

\clearpage
\section{Snort Multi-Event Logging (Event Queue)\label{eventqueue}}

Snort supports logging multiple events per packet/stream that are prioritized
with different insertion methods, such as max content length or event
ordering using the event queue.

The general configuration of the event queue is as follows:

\begin{verbatim}
config event_queue: [max_queue [size]] [log [size]] [order_events [TYPE]]
\end{verbatim}

\subsection{Event Queue Configuration Options}

There are three configuration options to the configuration parameter
'event\_queue'.

\begin{slist}
\item \texttt{max\_queue}

This determines the maximum size of the event queue.  For example, if the
event queue has a max size of 8, only 8 events will be stored for a single
packet or stream.

The default value is 8.

\item \texttt{log}

This determines the number of events to log for a given packet or stream.
You can't log more than the max\_event number that was specified.

The default value is 3.

\item \texttt{order\_events}

This argument determines the way that the incoming events are ordered.  We
currently have two different methods:

\begin{itemize}
  \item \texttt{priority} - The highest priority (1 being the highest) events are ordered
    first.

  \item \texttt{content\_length} - Rules are ordered before decode or preprocessor alerts,
    and rules that have a longer content are ordered before rules with
    shorter contents.
\end{itemize}

The method in which events are ordered does not affect rule types such as
pass, alert, log, etc.

The default value is content\_length.
\end{slist}
\subsection{Event Queue Configuration Examples}

The default configuration:
\begin{verbatim}
config event_queue: max_queue 8 log 3 order_events content_length
\end{verbatim}

Example of a reconfigured event queue:
\begin{verbatim}
config event_queue: max_queue 10 log 3 order_events content_length
\end{verbatim}

Use the default event queue values, but change event order:
\begin{verbatim}
config event_queue: order_events priority
\end{verbatim}

Use the default event queue values but change the number of logged events:
\begin{verbatim}
config event_queue: log 2
\end{verbatim}




\newpage
\section{Writing Good Rules}

There are some general concepts to keep in mind when developing Snort
rules to maximize efficiency and speed.

\subsection{Content Matching}
The 2.0 detection engine changes the way Snort works slightly by having the
first phase be a setwise pattern match.  The longer a content option is, the
more \emph{exact} the match.  Rules without \emph{content} (or
\emph{uricontent}) slow the entire system down.

While some detection options, such as \emph{pcre} and \emph{byte\_test},
perform detection in the payload section of the packet, they do not use the
setwise pattern matching engine.  If at all possible, try and have at least one
\emph{content} option if at all possible.

\subsection{Catch the Vulnerability, Not the Exploit}

Try to write rules that target the vulnerability, instead of a specific exploit.

For example, look for a the vulnerable command with an argument that is too
large, instead of shellcode that binds a shell.

By writing rules for the vulnerability, the rule is less vulnerable to evasion
when an attacker changes the exploit slightly.

\subsection{Catch the Oddities of the Protocol in the Rule}

Many services typically send the commands in upper case letters.  FTP is a good example.  In FTP, to send the username, the client sends:

\begin{verbatim}
user username_here
\end{verbatim}

A simple rule to look for FTP root login attempts could be:

\begin{verbatim}
alert tcp any any -> any any 21 (content:"user root";)
\end{verbatim}

While it may \emph{seem} trivial to write a rule that looks for the username
root, a good rule will handle all of the odd things that the protocol might
handle when accepting the user command.

For example, each of the following are accepted by most FTP servers:

\begin{verbatim}
user root
user root
user root
user     root
user<tab>root
\end{verbatim}

To handle all of the cases that the FTP server might handle, the rule needs
more smarts than a simple string match.

A good rule that looks for root login on ftp would be:

\begin{verbatim}
alert tcp any any -> any 21 (flow:to_server,established; content:"root";
   pcre:"/user\s+root/i";)
\end{verbatim}

There are a few important things to note in this rule:
\begin{itemize}
\item The rule has a \emph{flow} option, verifying this is traffic going to the server on an enstablished session.
\item The rule has a \emph{content} option, looking for \emph{root}, which is
the longest, most unique string in the attack.  This option is added to allow
Snort's setwise pattern match detection engine to give Snort a boost in speed.
\item The rule has a \emph{pcre} option, looking for user, followed at least one space character (which includes tab), followed by root, ignoring case.
\end{itemize}

% optomizing :)
\subsection{Optimizing Rules}

The content matching portion of the detection engine has recursion to handle a
few evasion cases.  Rules that are not properly written can cause Snort to
waste time duplicating checks.

The way the recursion works now is if a pattern matches, and if any of the
detection options after that pattern fail, then look for the pattern again
after where it was found the previous time.  Repeat until the pattern is not
found again or the opt functions all succeed.

On first read, that may not sound like a smart idea, but it is needed.  For example, take the following rule:

\begin{verbatim}
alert ip any any -> any any (content:"a"; content:"b"; within:1;)
\end{verbatim}

This rule would look for ``a'', immediately followed by ``b''.  Without recursion,
the payload ``aab'' would fail, even though it is obvious that the payload ``aab''
has ``a'' immediately followed by ``b'', because the first "a" is not
immediately followed by ``b''.

While recursion is important for detection, the recursion implementation is not
very smart.

For example, the following rule options are not optimized:
\begin{verbatim}
content:"|13|"; dsize:1;
\end{verbatim}

By looking at this rule snippit, it is obvious the rule looks for a packet with
a single byte of 0x13.  However, because of recursion, a packet with 1024 bytes
of 0x13 could cause 1023 too many pattern match attempts and 1023 too many
dsize checks.  Why?  The content 0x13 would be found in the first byte, then
the dsize option would fail, and because of recursion, the content 0x13 would
be found again starting after where the previous 0x13 was found, once it is
found, then check the dsize again, repeating until 0x13 is not found in the
payload again.

Reordering the rule options so that discrete checks (such as dsize) are moved to the begining of the rule speed up Snort.  

The optimized rule snipping would be:
\begin{verbatim}
dsize:1; content:"|13|";
\end{verbatim}

A packet of 1024 bytes of 0x13 would fail immediately, as the dsize check is
the first option checked and dsize is a discrete check without recursion.

The following rule options are discrete and should generally be placed at the
begining of any rule:

\begin{itemize}
\item \texttt{dsize}
\item \texttt{flags}
\item \texttt{flow}
\item \texttt{fragbits}
\item \texttt{icmp\_id}
\item \texttt{icmp\_seq} 
\item \texttt{icode} 
\item \texttt{id}
\item \texttt{ipopts}
\item \texttt{ip\_proto} 
\item \texttt{itype} 
\item \texttt{seq}
\item \texttt{session} 
\item \texttt{tos}
\item \texttt{ttl}
\item \texttt{ack}
\item \texttt{window}
\item \texttt{resp} 
\item \texttt{sameip}
\end{itemize}

\subsection{Testing Numerical Values \label{testing numerical values}}
The rule options \emph{byte\_test} and \emph{byte\_jump} were written to
support writing rules for protocols that have length encoded data.  RPC was the 
protocol that spawned the requirement for these two rule options, as RPC uses simple 
length based encoding for passing data.

In order to understand \emph{why} byte\_test and byte\_jump are useful, let's go
through an exploit attempt against the sadmind service.

This is the payload of the exploit:

\begin{verbatim}
89 09 9c e2 00 00 00 00 00 00 00 02 00 01 87 88  ................
00 00 00 0a 00 00 00 01 00 00 00 01 00 00 00 20  ...............
40 28 3a 10 00 00 00 0a 4d 45 54 41 53 50 4c 4f  @(:.....metasplo
49 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00  it..............
00 00 00 00 00 00 00 00 40 28 3a 14 00 07 45 df  ........@(:...e.
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 06 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 04 00 00 00 00 00 00 00 04  ................
7f 00 00 01 00 01 87 88 00 00 00 0a 00 00 00 04  ................
7f 00 00 01 00 01 87 88 00 00 00 0a 00 00 00 11  ................
00 00 00 1e 00 00 00 00 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 3b 4d 45 54 41 53 50 4c 4f  .......;metasplo
49 54 00 00 00 00 00 00 00 00 00 00 00 00 00 00  it..............
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
00 00 00 00 00 00 00 06 73 79 73 74 65 6d 00 00  ........system..
00 00 00 15 2e 2e 2f 2e 2e 2f 2e 2e 2f 2e 2e 2f  ....../../../../
2e 2e 2f 62 69 6e 2f 73 68 00 00 00 00 00 04 1e  ../bin/sh.......
<snip>
\end{verbatim}

Let's break this up, describe each of the fields, and figure out
how to write a rule to catch this exploit.  


There are a few things to note with RPC:
\begin{itemize}
\item Numbers are written as uint32s, taking four bytes.  The number 26 would show up as 0x0000001a.
\item Strings are written as a uint32 specifying the length of the string, the string, and then null bytes to pad the length of the string to end on a 4 byte boundary.  The string ``bob'' would show up as 0x00000003626f6200.
\end{itemize}

\begin{verbatim}
89 09 9c e2     - the request id, a random uint32, unique to each request
00 00 00 00     - rpc type (call = 0, response = 1)
00 00 00 02     - rpc version (2)
00 01 87 88     - rpc program (0x00018788 = 100232 = sadmind)
00 00 00 0a     - rpc program version (0x0000000a = 10)
00 00 00 01     - rpc procedure (0x00000001 = 1)
00 00 00 01     - credential flavor (1 = auth\_unix)
00 00 00 20     - length of auth\_unix data (0x20 = 32

## the next 32 bytes are the auth\_unix data
40 28 3a 10 - unix timestamp (0x40283a10 = 1076378128 = feb 10 01:55:28 2004 gmt)
00 00 00 0a - length of the client machine name (0x0a = 10)
4d 45 54 41 53 50 4c 4f 49 54 00 00  - metasploit

00 00 00 00 - uid of requesting user (0)
00 00 00 00 - gid of requesting user (0)
00 00 00 00 - extra group ids (0)

00 00 00 00     - verifier flavor (0 = auth\_null, aka none)
00 00 00 00     - length of verifier (0, aka none)
\end{verbatim}

The rest of the packet is the request that gets passed to procedure 1 of sadmind.

However, we know the vulnerability is that sadmind trusts the uid coming from the client.  sadmind runs any request where the client's uid is 0 as root.  As such, we have decoded enough of the request to write our rule.  


First, we need to make sure that our packet is an RPC call.
    
\begin{verbatim}
    content:"|00 00 00 00|"; offset:4; depth:4;
\end{verbatim}

Then, we need to make sure that our packet is a call to sadmind.
    
\begin{verbatim}
    content:"|00 01 87 88|"; offset:12; depth:4;
\end{verbatim}

Then, we need to make sure that our packet is a call to the procedure 1, the vulnerable procedure.  
   
\begin{verbatim}
    content:"|00 00 00 01|"; offset:16; depth:4;
\end{verbatim}

Then, we need to make sure that our packet has auth\_unix credentials.  
    
\begin{verbatim}
    content:"|00 00 00 01|"; offset:20; depth:4;
\end{verbatim}

We don't care about the hostname, but we want to skip over it and check a
number value after the hostname.  This is where byte\_test is useful.  Starting
at the length of the hostname, the data we have is:

\begin{verbatim}
00 00 00 0a 4d 45 54 41 53 50 4c 4f 49 54 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00
\end{verbatim}

We want to read 4 bytes, turn it into a number, and jump that many bytes
forward, making sure to account for the padding that RPC requires on strings.
If we do that, we are now at:

\begin{verbatim}
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 
\end{verbatim}

which happens to be the exact location of the uid, the value we want to check.

In english, we want to read 4 bytes, 36 bytes from the beginning of the packet, and turn those 4 bytes into an integer and jump that many bytes forward, aligning on the 4 byte boundary.  To do that in a Snort rule, we use:

\begin{verbatim}
    byte_jump:4,36,align;
\end{verbatim}

then we want to look for the uid of 0.

\begin{verbatim}
    content:"|00 00 00 00|"; within:4;
\end{verbatim}

Now that we have all the detection capabilities for our rule, let's put them all together.  

\begin{verbatim}
    content:"|00 00 00 00|"; offset:4; depth:4;
    content:"g00 01 87 88|"; offset:12; depth:4;
    content:"|00 00 00 01|"; offset:16; depth:4;
    content:"|00 00 00 01|"; offset:20; depth:4;
    byte_jump:4,36,align;
    content:"|00 00 00 00|"; within:4;
\end{verbatim}

The 3rd and fourth string match are right next to each other, so we should combine those patterns.  We end up with:

\begin{verbatim}
    content:"|00 00 00 00|"; offset:4; depth:4;
    content:"|00 01 87 88|"; offset:12; depth:4;
    content:"|00 00 00 01 00 00 00 01|"; offset:16; depth:8;
    byte_jump:4,36,align;
    content:"|00 00 00 00|"; within:4;
\end{verbatim}

If the sadmind service was vulnerable to a buffer overflow when reading the client's hostname, instead of reading the length of the hostname and jumping that many bytes forward, we would check the length of the hostname to make sure it is not too large.  

To do that, we would read 4 bytes, starting 36 bytes into the packet, turn it into a number, and then make sure it is not too large (let's say bigger than 200 bytes).  In Snort, we do: 

\begin{verbatim}
    byte_test:4,>,200,36;
\end{verbatim}
    
Our full rule would be:    

\begin{verbatim}
    content:"|00 00 00 00|"; offset:4; depth:4;
    content:"|00 01 87 88|"; offset:12; depth:4;
    content:"|00 00 00 01 00 00 00 01|"; offset:16; depth:8;
    byte_test:4,>,200,36;
\end{verbatim}

\newpage
\chapter{Making Snort Faster}

\section{MMAPed pcap}

On Linux, a modified version of libpcap is available that implements a shared memory ring buffer.  Phil Woods (cpw@lanl.gov) is the current maintainer of the libpcap implementation of the shared memory ring buffer.  The shared memory ring buffer libpcap can be downloaded from his website at \url{http://public.lanl.gov/cpw/}.

Instead of the normal mechanism of copying the packets from kernel memory into userland memory, by using a shared memory ring buffer, libpcap is able to queue packets into a shared buffer that Snort is able to read directly.  This change speeds up Snort by limiting the number of times the packet is copied before Snort gets to perform its detection upon it.

Once Snort linked against the shared memory libpcap, enabling the ring buffer is done via setting the enviornment variable \emph{PCAP\_FRAMES}.  \emph{PCAP\_FRAMES} is the size of the ring buffer.  According to Phil, the maximum size is 32768, as this appears to be the maximum number of iovecs the kernel can handle.  By using \emph{PCAP\_FRAMES=max}, libpcap will automatically use the most frames possible.  On Ethernet, this ends up being 1530 bytes per frame, for a total of around 52 Mbytes of memory for the ring buffer alone.

\newpage
\chapter{Dynamic Modules}\label{Dynamic Modules}

Preprocessors, detection capabilities, and rules can now be developed as 
dynamically loadable module to snort.  When enabled via the
{\em --enable-dynamicplugin} configure option, the dynamic
API presents a means for loading dynamic libraries and allowing the 
module to utilize certain functions within the main snort code.

The remainder of this chapter will highlight the data structures
and API functions used in developing preprocessors, detection engines,
and rules as a dynamic plugin to snort.

\section{Data Structures}

A number of data structures are central to the API.  The definition
of each is defined in the following sections.

\subsection{DynamicPluginMeta}
The {\em DynamicPluginMeta} structure defines the type of dynamic module
(preprocessor, rules, or detection engine), the version
information, and path to the shared library.  A shared library can
implement all three types, but typically is limited to a single functionality
such as a preprocessor.  It is defined in \texttt{sf\_dynamic\_meta.h} as:

\begin{verbatim}
#define TYPE_ENGINE 0x01
#define TYPE_DETECTION 0x02
#define TYPE_PREPROCESSOR 0x04

typedef struct _DynamicPluginMeta
{
    int type;
    int major;
    int minor;
    int build;
    char uniqueName[MAX_NAME_LEN];
    char *libraryPath;
} DynamicPluginMeta;
\end{verbatim}

\subsection{DynamicPreprocessorData}
The {\em DynamicPreprocessorData} structure defines the interface the
preprocessor uses to interact with snort itself.  This inclues functions
to register the preprocessor's configuration parsing, restart, exit,
and processing functions.  It includes function to log messages,
errors, fatal errors, and debugging info.  It also includes information
for setting alerts, handling Inline drops, access to the StreamAPI, and
it provides access to the normalized http and alternate data buffers.
This data structure should be initialized when the preprocessor shared
library is loaded.  It is defined in \texttt{sf\_dynamic\_preprocessor.h} as:

\begin{verbatim}
typedef struct _DynamicPreprocessorData
{
    int version;
    char *altBuffer;
    unsigned int altBufferLen;
    UriInfo *uriBuffers[MAX_URIINFOS];
    LogMsgFunc logMsg;
    LogMsgFunc errMsg;
    LogMsgFunc fatalMsg;
    DebugMsgFunc debugMsg;

    PreprocRegisterFunc registerPreproc;
    AddPreprocFunc addPreproc;
    AddPreprocRestart addPreprocRestart;
    AddPreprocExit addPreprocExit;
    AddPreprocConfCheck addPreprocConfCheck;
    RegisterPreprocRuleOpt preprocOptRegister;
    AddPreprocProfileFunc addPreprocProfileFunc;
    ProfilingFunc profilingPreprocsFunc;
    void *totalPerfStats;

    AlertQueueAdd alertAdd;
    ThresholdCheckFunc thresholdCheck;

    InlineFunc  inlineMode;
    InlineDropFunc  inlineDrop;

    DetectFunc detect;
    DisableDetectFunc disableDetect;
    DisableDetectFunc disableAllDetect;

    SetPreprocBitFunc setPreprocBit;

    StreamAPI *streamAPI;
    SearchAPI *searchAPI;

    char **config_file;
    int *config_line;
    printfappendfunc printfappend;
    TokenSplitFunc tokenSplit;
    TokenFreeFunc tokenFree;

    GetRuleInfoByNameFunc getRuleInfoByName;
    GetRuleInfoByIdFunc getRuleInfoById;
} DynamicPreprocessorData;
\end{verbatim}

\subsection{DynamicEngineData}
The {\em DynamicEngineData} structure defines the interface a detection
engine uses to interact with snort itself.  This includes functions for
logging messages, errors, fatal errors, and debugging info as well as
a means to register and check flowbits.  It also includes a location
to store rule-stubs for dynamic rules that are loaded, and
it provides access to the normalized http and alternate data buffers.
It is defined in \texttt{sf\_dynamic\_engine.h} as:

\begin{verbatim}
typedef struct _DynamicEngineData
{
    int version;
    char *altBuffer;
    UriInfo *uriBuffers[MAX_URIINFOS];
    RegisterRule ruleRegister;
    RegisterBit flowbitRegister;
    CheckFlowbit flowbitCheck;
    DetectAsn1 asn1Detect;
    LogMsg logMsg;
    LogMsg errMsg;
    LogMsg fatalMsg;
    char *dataDumpDirectory;

    GetPreprocRuleOptFuncs getPreprocOptFuncs;
} DynamicEngineData;
\end{verbatim}

\subsection{SFSnortPacket}
The {\em SFSnortPacket} structure mirrors the snort Packet structure
and provides access to all of the data contained in a given packet.

It and the data structures it incorporates are defined in
\texttt{sf\_snort\_packet.h} as follows.  Additional data structures
may be defined to reference other protocol fields.

\begin{verbatim}
#define IP_RESBIT       0x8000
#define IP_DONTFRAG     0x4000
#define IP_MOREFRAGS    0x2000

typedef struct _IPV4Header
{
    u_int8_t version_headerlength;
    u_int8_t type_service;
    u_int16_t data_length;
    u_int16_t identifier;
    u_int16_t offset;
    u_int8_t time_to_live;
    u_int8_t proto;
    u_int16_t checksum;
    struct in_addr source;
    struct in_addr destination;
} IPV4Header;

#define MAX_IP_OPTIONS 40
/* ip option codes */
#define IPOPTION_EOL            0x00
#define IPOPTION_NOP            0x01
#define IPOPTION_RR             0x07
#define IPOPTION_RTRALT         0x14
#define IPOPTION_TS             0x44
#define IPOPTION_SECURITY       0x82
#define IPOPTION_LSRR           0x83
#define IPOPTION_LSRR_E         0x84
#define IPOPTION_SATID          0x88
#define IPOPTION_SSRR           0x89

typedef struct _IPOptions
{
    u_int8_t option_code;
    u_int8_t length;
    u_int8_t *option_data;
} IPOptions;

typedef struct _TCPHeader
{
    u_int16_t source_port;
    u_int16_t destination_port;
    u_int32_t sequence;
    u_int32_t acknowledgement;
    u_int8_t offset_reserved;
    u_int8_t flags;
    u_int16_t window;
    u_int16_t checksum;
    u_int16_t urgent_pointer;
} TCPHeader;

#define TCPHEADER_FIN  0x01
#define TCPHEADER_SYN  0x02
#define TCPHEADER_RST  0x04
#define TCPHEADER_PUSH 0x08
#define TCPHEADER_ACK  0x10
#define TCPHEADER_URG  0x20
#define TCPHEADER_RES2 0x40
#define TCPHEADER_RES1 0x80
#define TCPHEADER_NORESERVED (TCPHEADER_FIN|TCPHEADER_SYN|TCPHEADER_RST \
                              |TCPHEADER_PUSH|TCPHEADER_ACK|TCPHEADER_URG)
#define MAX_TCP_OPTIONS 40
/* tcp option codes */
#define TCPOPT_EOL              0x00
#define TCPOPT_NOP              0x01
#define TCPOPT_MSS              0x02
#define TCPOPT_WSCALE           0x03     /* window scale factor (rfc1072) */
#define TCPOPT_SACKOK           0x04     /* selective ack ok (rfc1072) */
#define TCPOPT_SACK             0x05     /* selective ack (rfc1072) */
#define TCPOPT_ECHO             0x06     /* echo (rfc1072) */
#define TCPOPT_ECHOREPLY        0x07     /* echo (rfc1072) */
#define TCPOPT_TIMESTAMP        0x08     /* timestamps (rfc1323) */
#define TCPOPT_CC               0x11     /* T/TCP CC options (rfc1644) */
#define TCPOPT_CCNEW            0x12     /* T/TCP CC options (rfc1644) */
#define TCPOPT_CCECHO           0x13     /* T/TCP CC options (rfc1644) */

typedef IPOptions TCPOptions;

typedef struct _UDPHeader
{
    u_int16_t source_port;
    u_int16_t destination_port;
    u_int16_t data_length;
    u_int16_t checksum;
} UDPHeader;

typedef struct _ICMPSequenceID
{
    u_int16_t id;
    u_int16_t seq;
} ICMPSequenceID;

typedef struct _ICMPHeader
{
    u_int8_t type;
    u_int8_t code;
    u_int16_t checksum;

    union
    {
        /* type 12 */
        u_int8_t parameter_problem_ptr;

        /* type 5 */
        struct in_addr gateway_addr;

        /* type 8, 0 */
        ICMPSequenceID echo;

        /* type 13, 14 */
        ICMPSequenceID timestamp;

        /* type 15, 16 */
        ICMPSequenceID info;

        int voidInfo;

        /* type 3/code=4 (Path MTU, RFC 1191) */
        struct path_mtu
        {
            u_int16_t voidInfo;
            u_int16_t next_mtu;
        } path_mtu;

        /* type 9 */
        struct router_advertisement
        {
            u_int8_t number_addrs;
            u_int8_t entry_size;
            u_int16_t lifetime;
        } router_advertisement;
    } icmp_header_union;
#define icmp_parameter_ptr  icmp_header_union.parameter_problem_ptr
#define icmp_gateway_addr   icmp_header_union.gateway_waddr
#define icmp_echo_id        icmp_header_union.echo.id
#define icmp_echo_seq       icmp_header_union.echo.seq
#define icmp_timestamp_id   icmp_header_union.timestamp.id
#define icmp_timestamp_seq  icmp_header_union.timestamp.seq
#define icmp_info_id        icmp_header_union.info.id
#define icmp_info_seq       icmp_header_union.info.seq
#define icmp_void           icmp_header_union.void
#define icmp_nextmtu        icmp_header_union.path_mtu.nextmtu
#define icmp_ra_num_addrs   icmp_header_union.router_advertisement.number_addrs
#define icmp_ra_entry_size  icmp_header_union.router_advertisement.entry_size
#define icmp_ra_lifetime    icmp_header_union.router_advertisement.lifetime

    union
    {
        /* timestamp */
        struct timestamp
        {
            u_int32_t orig;
            u_int32_t receive;
            u_int32_t transmit;
        } timestamp;

        /* IP header for unreach */
        struct ipv4_header
        {
            IPV4Header *ip;
            /* options and then 64 bits of data */
        } ipv4_header;

        /* Router Advertisement */
        struct router_address
        {
            u_int32_t addr;
            u_int32_t preference;
        } router_address;

        /* type 17, 18 */
        u_int32_t mask;

        char    data[1];
    } icmp_data_union;
#define icmp_orig_timestamp     icmp_data_union.timestamp.orig
#define icmp_recv_timestamp     icmp_data_union.timestamp.receive
#define icmp_xmit_timestamp     icmp_data_union.timestamp.transmit
#define icmp_ipheader           icmp_data_union.ip_header
#define icmp_ra_addr0           icmp_data_union.router_address
#define icmp_mask               icmp_data_union.mask
#define icmp_data               icmp_data_union.data
} ICMPHeader;

#define ICMP_ECHO_REPLY             0    /* Echo Reply                   */
#define ICMP_DEST_UNREACHABLE       3    /* Destination Unreachable      */
#define ICMP_SOURCE_QUENCH          4    /* Source Quench                */
#define ICMP_REDIRECT               5    /* Redirect (change route)      */
#define ICMP_ECHO_REQUEST           8    /* Echo Request                 */
#define ICMP_ROUTER_ADVERTISEMENT   9    /* Router Advertisement         */
#define ICMP_ROUTER_SOLICITATION    10    /* Router Solicitation          */
#define ICMP_TIME_EXCEEDED          11    /* Time Exceeded                */
#define ICMP_PARAMETER_PROBLEM      12    /* Parameter Problem            */
#define ICMP_TIMESTAMP_REQUEST      13    /* Timestamp Request            */
#define ICMP_TIMESTAMP_REPLY        14    /* Timestamp Reply              */
#define ICMP_INFO_REQUEST           15    /* Information Request          */
#define ICMP_INFO_REPLY             16    /* Information Reply            */
#define ICMP_ADDRESS_REQUEST        17    /* Address Mask Request         */
#define ICMP_ADDRESS_REPLY          18    /* Address Mask Reply           */

#define CHECKSUM_INVALID_IP 0x01
#define CHECKSUM_INVALID_TCP 0x02
#define CHECKSUM_INVALID_UDP 0x04
#define CHECKSUM_INVALID_ICMP 0x08
#define CHECKSUM_INVALID_IGMP 0x10

typedef struct _SFSnortPacket
{
    struct pcap_pkthdr *pcap_header;
    u_int8_t *pkt_data;

    void *fddi_header;
    void *fddi_saps;
    void *fddi_sna;
    void *fddi_iparp;
    void *fddi_other;

    void *tokenring_header;
    void *tokenring_header_llc;
    void *tokenring_header_mr;

    void *sll_header;

    void *pflog_header;
    void *old_pflog_header;

    void *ether_header;
    void *vlan_tag_header;

    void *ether_header_llc;
    void *ether_header_other;

    void *wifi_header;

    void *ether_arp_header;

    void *ether_eapol_header; /* 802.1x */
    void *eapol_headear;
    u_int8_t *eapol_type;
    void *eapol_key;

    void *ppp_over_ether_header;

    IPV4Header *ip4_header, *orig_ip4_header;
    u_int32_t ip4_options_length;
    void *ip4_options_data;

    TCPHeader *tcp_header, *orig_tcp_header;
    u_int32_t tcp_options_length;
    void *tcp_options_data;

    UDPHeader *udp_header, *orig_udp_header;
    ICMPHeader *icmp_header, *orig_icmp_header;

    u_int8_t *payload;
    u_int16_t payload_size;
    u_int16_t normalized_payload_size;

    u_int16_t actual_ip_length;

    u_int8_t ip_fragmented;
    u_int16_t ip_fragment_offset;
    u_int8_t ip_more_fragments;
    u_int8_t ip_dont_fragment;
    u_int8_t ip_reserved;

    u_int16_t src_port;
    u_int16_t dst_port;
    u_int16_t orig_src_port;
    u_int16_t orig_dst_port;
    u_int32_t pcap_cap_len;

    u_int8_t num_uris;

    void *stream_session_ptr;
    void *fragmentation_tracking_ptr;
    void *flow_ptr;
    void *stream_ptr;

    IPOptions ip_options[MAX_IP_OPTIONS];
    u_int32_t num_ip_options;
    u_int8_t ip_last_option_invalid_flag;

    TCPOptions tcp_options[MAX_TCP_OPTIONS];
    u_int32_t num_tcp_options;
    u_int8_t tcp_last_option_invalid_flag;

    u_int8_t checksums_invalid;
    u_int32_t flags;
#define FLAG_REBUILT_FRAG     0x00000001
#define FLAG_REBUILT_STREAM   0x00000002
#define FLAG_STREAM_UNEST_UNI 0x00000004
#define FLAG_STREAM_UNEST_BI  0x00000008
#define FLAG_STREAM_EST       0x00000010
#define FLAG_FROM_SERVER      0x00000040
#define FLAG_FROM_CLIENT      0x00000080
#define FLAG_HTTP_DECODE      0x00000100
#define FLAG_STREAM_INSERT    0x00000400
#define FLAG_ALT_DECODE       0x00000800
    u_int32_t number_bytes_to_check;

    void *preprocessor_bit_mask;
} SFSnortPacket;

\end{verbatim}

\subsection{Dynamic Rules}
A dynamic rule should use any of the following data structures.  The
following structures are defined in \texttt{sf\_snort\_plugin\_api.h}.

\subsubsection{Rule}
The {\em Rule} structure defines the basic outline of a rule and
contains the same set of information that is seen in a text rule.
That includes protocol, address and port information and rule information
(classification, generator and signature IDs, revision, priority,
classification, and a list of references).  It also includes a list of
rule options and an optional evaluation function.

\begin{verbatim}
#define RULE_MATCH 1
#define RULE_NOMATCH 0

typedef struct _Rule
{
    IPInfo ip;
    RuleInformation info;

    RuleOption **options; /* NULL terminated array of RuleOption union */

    ruleEvalFunc evalFunc;

    char initialized;     /* Rule Initialized, used internally */
    u_int32_t numOptions; /* Rule option count, used internally */
    char noAlert;         /* Flag with no alert, used internally */
    void *ruleData;    /* Hash table for dynamic data pointers */
} Rule;
\end{verbatim}

The rule evaluation function is defined as

\begin{verbatim}
int (*ruleEvalFunc)(void *);
\end{verbatim}

where the parameter is a pointer to the SFSnortPacket structure.

\subsubsection{RuleInformation}
The {\em RuleInformation} structure defines the meta data for a rule
and includes generator ID, signature ID, revision, classification,
priority, message text, and a list of references.

\begin{verbatim}
int (*ruleEvalFunc)(void *);
truct _RuleInformation
{
    u_int32_t genID;
    u_int32_t sigID;
    u_int32_t revision;
    char     *classification; /* String format of classification name */
    u_int32_t priority;
    char     *message;
    RuleReference **references; /* NULL terminated array of references */
} RuleInformation;
\end{verbatim}

\subsubsection{RuleReference}
The {\em RuleReference} structure defines a single rule reference,
including the system name and rereference identifier.

\begin{verbatim}
typedef struct _RuleReference
{
    char *systemName;
    char *refIdentifier;
} RuleReference;
\end{verbatim}

\subsubsection{IPInfo}
The {\em IPInfo} structure defines the initial matching criteria
for a rule and includes the protocol, src address and port,
destination address and port, and direction.  Some of the standard
strings and variables are predefined - any, HOME\_NET, HTTP\_SERVERS,
HTTP\_PORTS, etc.

\begin{verbatim}
typedef struct _IPInfo
{
    u_int8_t protocol;
    char *   src_addr;
    char *   src_port; /* 0 for non TCP/UDP */
    char     direction;     /* non-zero is bi-directional */
    char *   dst_addr;
    char *   dst_port; /* 0 for non TCP/UDP */
} IPInfo;

#define ANY_NET         "any"
#define HOME_NET        "$HOME_NET"
#define EXTERNAL_NET    "$EXTERNAL_NET"
#define ANY_PORT        "any"
#define HTTP_SERVERS    "$HTTP_SERVERS"
#define HTTP_PORTS      "$HTTP_PORTS"
#define SMTP_SERVERS    "$SMTP_SERVERS"
\end{verbatim}

\subsubsection{RuleOption}
The {\em RuleOption} structure defines a single rule option as
an option type and a reference to the data specific to that option.
Each option has a flags field that contains specific flags for
that option as well as a "Not" flag.  The "Not" flag is used
to negate the results of evaluating that option.

%#define OPTION_TYPE_PREPROCESSOR 0x00
\begin{verbatim}
#define OPTION_TYPE_CONTENT      0x01
#define OPTION_TYPE_PCRE         0x02
#define OPTION_TYPE_FLOWBIT      0x03
#define OPTION_TYPE_FLOWFLAGS    0x04
#define OPTION_TYPE_ASN1         0x05
#define OPTION_TYPE_CURSOR       0x06
#define OPTION_TYPE_HDR_CHECK    0x07
#define OPTION_TYPE_BYTE_TEST    0x08
#define OPTION_TYPE_BYTE_JUMP    0x09
#define OPTION_TYPE_BYTE_EXTRACT 0x10
#define OPTION_TYPE_SET_CURSOR   0x11
#define OPTION_TYPE_LOOP         0x12

typedef struct _RuleOption
{
    int optionType;
    union
    {
        void *ptr;
        ContentInfo *content;
        CursorInfo *cursor;
        PCREInfo *pcre;
        FlowBitsInfo *flowBit;
        ByteData *byte;
        ByteExtract *byteExtract;
        FlowFlags *flowFlags;
        Asn1Context *asn1;
        HdrOptCheck *hdrData;
        LoopInfo    *loop;
    } option_u;
} RuleOption;

#define NOT_FLAG                0x10000000
\end{verbatim}
%        PreprocessorOption *preprocOpt;

Some options also contain information that is initialized at run
time, such as the compiled PCRE information, Boyer-Moore content
information, the integer ID for a flowbit, etc.

The option types and related structures are listed below.
\begin{itemize}
%\item {OptionType: Preprocessor defined \& Structure: {\em PreprocessorOption}}
%
%The {\em PreprocessorOption} structure defines an option for a
%preprocessor defined option. 
%
%\begin{verbatim}
%typedef struct _PreprocessorOption
%{
%    char *optionName;
%    char *optionParameters;
%    u_int32_t flags;
%    void *optionInit;
%    void *optionEval;
%    void *dataPtr;
%} PreprocessorOption;
%\end{verbatim}

\item {OptionType: Content \& Structure: {\em ContentInfo}}

The {\em ContentInfo} structure defines an option for a content
search.  It includes the pattern, depth and offset, and flags (one of
which must specify the buffer -- raw, URI or normalized -- to search).
Additional flags include nocase, relative, unicode, and a designation
that this content is to be used for snorts fast pattern evaluation.
The most unique content, that which distinguishes this rule as a
possible match to a packet, should be marked for fast pattern evaluation.
In the dynamic detection engine provided with Snort, if no {\em
ContentInfo} structure in a given rules uses that flag, the one with the
longest content length will be used.

\begin{verbatim}
typedef struct _ContentInfo
{
    u_int8_t *pattern;
    u_int32_t depth;
    int32_t   offset;
    u_int32_t flags;        /* must include a CONTENT_BUF_X */
    void     *boyer_ptr;
    u_int8_t *patternByteForm;
    u_int32_t patternByteFormLength;
    u_int32_t incrementLength;
} ContentInfo;

#define CONTENT_NOCASE          0x01
#define CONTENT_RELATIVE        0x02
#define CONTENT_UNICODE2BYTE    0x04
#define CONTENT_UNICODE4BYTE    0x08
#define CONTENT_FAST_PATTERN    0x10
#define CONTENT_END_BUFFER      0x20

#define CONTENT_BUF_NORMALIZED  0x100
#define CONTENT_BUF_RAW         0x200
#define CONTENT_BUF_URI         0x400
\end{verbatim}

\item {OptionType: PCRE \& Structure: {\em PCREInfo}}

The {\em PCREInfo} structure defines an option for a PCRE search.
It includes the PCRE expression, pcre\_flags such as caseless, as
defined in PCRE.h, and flags to specify the buffer.

\begin{verbatim}
/*
pcre.h provides flags:

PCRE_CASELESS
PCRE_MULTILINE
PCRE_DOTALL
PCRE_EXTENDED
PCRE_ANCHORED
PCRE_DOLLAR_ENDONLY
PCRE_UNGREEDY
*/

typedef struct _PCREInfo
{
    char     *expr;
    void     *compiled_expr;
    void     *compiled_extra;
    u_int32_t compile_flags;
    u_int32_t flags; /* must include a CONTENT_BUF_X */
} PCREInfo;
\end{verbatim}

\item {OptionType: Flowbit \& Structure: {\em FlowBitsInfo}}

The {\em FlowBitsInfo} structure defines a flowbits option.  It
includes the name of the flowbit and the operation (set, unset, toggle,
isset, isnotset).

\begin{verbatim}
#define FLOWBIT_SET       0x01
#define FLOWBIT_UNSET     0x02
#define FLOWBIT_TOGGLE    0x04
#define FLOWBIT_ISSET     0x08
#define FLOWBIT_ISNOTSET  0x10
#define FLOWBIT_RESET     0x20
#define FLOWBIT_NOALERT   0x40

typedef struct _FlowBitsInfo
{
    char      *flowBitsName;
    u_int8_t   operation;
    u_int32_t  id;
    u_int32_t  flags;
} FlowBitsInfo;
\end{verbatim}

\item {OptionType: Flow Flags \& Structure: {\em FlowFlags}}

The {\em FlowFlags} structure defines a flow option.  It includes
the flags, which specify the direction (from\_server, to\_server), 
established session, etc. 

\begin{verbatim}
#define FLOW_ESTABLISHED 0x10
#define FLOW_IGNORE_REASSEMBLED 0x1000
#define FLOW_ONLY_REASSMBLED    0x2000
#define FLOW_FR_SERVER   0x40
#define FLOW_TO_CLIENT   0x40 /* Just for redundancy */
#define FLOW_TO_SERVER   0x80
#define FLOW_FR_CLIENT   0x80 /* Just for redundancy */

typedef struct _FlowFlags
{
    u_int32_t   flags;
} FlowFlags;
\end{verbatim}

\item {OptionType: ASN.1 \& Structure: {\em Asn1Context}}

The {\em Asn1Context} structure defines the information for an
ASN1 option.  It mirrors the ASN1 rule option and also includes
a flags field.

\begin{verbatim}
#define ASN1_ABS_OFFSET 1
#define ASN1_REL_OFFSET 2

typedef struct _Asn1Context
{
    int bs_overflow;
    int double_overflow;
    int print;
    int length;
    unsigned int max_length;
    int offset;
    int offset_type;
    u_int32_t  flags;
} Asn1Context;
\end{verbatim}

\item {OptionType: Cursor Check \& Structure: {\em CursorInfo}}

The {\em CursorInfo} structure defines an option for a cursor
evaluation.  The cursor is the current position within the
evaluation buffer, as related to content and PCRE searches,
as well as byte tests and byte jumps.  It includes an offset
and flags that specify the buffer.  This can be used to
verify there is sufficient data to continue evaluation,
similar to the isdataat rule option.  

\begin{verbatim}
typedef struct _CursorInfo
{
    int32_t   offset;
    u_int32_t flags;        /* specify one of CONTENT_BUF_X */
} CursorInfo;
\end{verbatim}

\item {OptionType: Protocol Header \& Structure: {\em HdrOptCheck}}

The {\em HdrOptCheck} structure defines an option to check a
protocol header for a specific value.  It incldues the header
field, the operation (<,>,=,etc), a value, a mask to ignore
that part of the header field, and flags.

\begin{verbatim}
#define IP_HDR_ID           0x0001  /* IP Header ID */
#define IP_HDR_PROTO        0x0002  /* IP Protocol */
#define IP_HDR_FRAGBITS     0x0003  /* Frag Flags set in IP Header */
#define IP_HDR_FRAGOFFSET   0x0004  /* Frag Offset set in IP Header */
#define IP_HDR_OPTIONS      0x0005  /* IP Options -- is option xx included */
#define IP_HDR_TTL          0x0006  /* IP Time to live */
#define IP_HDR_TOS          0x0007  /* IP Type of Service */
#define IP_HDR_OPTCHECK_MASK 0x000f

#define TCP_HDR_ACK         0x0010  /* TCP Ack Value */
#define TCP_HDR_SEQ         0x0020  /* TCP Seq Value */
#define TCP_HDR_FLAGS       0x0030  /* Flags set in TCP Header */
#define TCP_HDR_OPTIONS     0x0040  /* TCP Options -- is option xx included */
#define TCP_HDR_WIN         0x0050  /* TCP Window */
#define TCP_HDR_OPTCHECK_MASK 0x00f0

#define ICMP_HDR_CODE       0x1000  /* ICMP Header Code */
#define ICMP_HDR_TYPE       0x2000  /* ICMP Header Type */
#define ICMP_HDR_ID         0x3000  /* ICMP ID for ICMP_ECHO/ICMP_ECHO_REPLY */
#define ICMP_HDR_SEQ        0x4000  /* ICMP ID for ICMP_ECHO/ICMP_ECHO_REPLY */
#define ICMP_HDR_OPTCHECK_MASK 0xf000

typedef struct _HdrOptCheck
{
    u_int16_t hdrField;   /* Field to check */
    u_int32_t op;         /* Type of comparison */
    u_int32_t value;      /* Value to compare value against */
    u_int32_t mask_value; /* bits of value to ignore */
    u_int32_t flags;
} HdrOptCheck;
\end{verbatim}

\item {OptionType: Byte Test \& Structure: {\em ByteData}}

The {\em ByteData} structure defines the information for both
ByteTest and ByteJump operations.  It includes the number of
bytes, an operation (for ByteTest, <,>,=,etc), a value,
an offset, multiplier, and flags.  The flags must specify the
buffer.

\begin{verbatim}
#define CHECK_EQ            0
#define CHECK_NEQ           1
#define CHECK_LT            2
#define CHECK_GT            3
#define CHECK_LTE           4
#define CHECK_GTE           5
#define CHECK_AND           6
#define CHECK_XOR           7
#define CHECK_ALL           8
#define CHECK_ATLEASTONE    9
#define CHECK_NONE          10

typedef struct _ByteData
{
    u_int32_t bytes;      /* Number of bytes to extract */
    u_int32_t op;         /* Type of byte comparison, for checkValue */
    u_int32_t value;      /* Value to compare value against, for checkValue, or extracted value */
    int32_t   offset;     /* Offset from cursor */
    u_int32_t multiplier; /* Used for byte jump -- 32bits is MORE than enough */
    u_int32_t flags;      /* must include a CONTENT_BUF_X */
} ByteData;
\end{verbatim}

\item {OptionType: Byte Jump \& Structure: {\em ByteData}}

See {\em Byte Test} above.

\item {OptionType: Set Cursor \& Structure: {\em CursorInfo}}

See {\em Cursor Check} above.

\item {OptionType: Loop \& Structures: {\em LoopInfo,ByteExtract,DynamicElement}}

The {\em LoopInfo} structure defines the information for a
set of options that are to be evaluated repeatedly.  The loop option
acts like a FOR loop and includes start, end, and increment values
as well as the comparison operation for termination.  It includes
a cursor adjust that happens through each iteration of the
loop, a reference to a RuleInfo structure that defines the
RuleOptions are to be evaluated through each iteration.  One of those
options may be a ByteExtract.

\begin{verbatim}
typedef struct _LoopInfo
{
    DynamicElement *start;      /* Starting value of FOR loop (i=start) */
    DynamicElement *end;        /* Ending value of FOR loop (i OP end) */
    DynamicElement *increment;  /* Increment value of FOR loop (i+= increment) */
    u_int32_t op;               /* Type of comparison for loop termination */
    CursorInfo *cursorAdjust;   /* How to move cursor each iteration of loop */
    struct _Rule *subRule;      /* Pointer to SubRule & options to evaluate within
                                 * the loop */
    u_int8_t initialized;       /* Loop initialized properly (safeguard) */
    u_int32_t flags;            /* can be used to negate loop results, specifies                                 * relative. */
} LoopInfo;
\end{verbatim}

The {\em ByteExtract} structure defines the information to use
when extracting bytes for a DynamicElement used a in Loop evaltion.
It includes the number of bytes, an offset, multiplier, flags
specifying the buffer, and a reference to the DynamicElement.

\begin{verbatim}
typedef struct _ByteExtract
{
    u_int32_t bytes;      /* Number of bytes to extract */
    int32_t   offset;     /* Offset from cursor */
    u_int32_t multiplier; /* Multiply value by this (similar to byte jump) */
    u_int32_t flags;      /* must include a CONTENT_BUF_X */
    char *refId;          /* To match up with a DynamicElement refId */
    void *memoryLocation; /* Location to store the data extracted */
} ByteExtract;
\end{verbatim}

The {\em DynamicElement} structure is used to define the values
for a looping evaluation.  It includes whether the element is
static (an integer) or dynamic (extracted from a buffer in the packet)
and the value.  For a dynamic element, the value is filled by
a related ByteExtract option that is part of the loop.

\begin{verbatim}
#define DYNAMIC_TYPE_INT_STATIC 1
#define DYNAMIC_TYPE_INT_REF    2

typedef struct _DynamicElement
{
    char dynamicType;           /* type of this field - static or reference */
    char *refId;                /* reference ID (NULL if static) */
    union
    {
        void *voidPtr;          /* Holder */
        int32_t staticInt;        /* Value of static */
        int32_t *dynamicInt;  /* Pointer to value of dynamic */
    } data;
} DynamicElement;
\end{verbatim}

\end{itemize}

\section{Required Functions}

Each dynamic module must define a set of functions and data objects
to work within this framework.

\subsection{Preprocessors}

Each dynamic preprocessor library must define the following functions.  These
are defined in the file \texttt{sf\_dynamic\_preproc\_lib.c}.  The metadata
and setup function for the preprocessor should be defined
\texttt{sf\_preproc\_info.h}.

\begin{itemize}
\item {\em int LibVersion(DynamicPluginMeta *)}

This function returns the metadata for the shared library.

\item {\em int InitializePreprocessor(DynamicPreprocessorData *)}

This function initializes the data structure for use by the preprocessor
into a library global variable, \texttt{\_dpd} and invokes the setup
function.
\end{itemize}

\subsection{Detection Engine}

Each dynamic detection engine library must define the following functions.

\begin{itemize}
\item {\em int LibVersion(DynamicPluginMeta *)}

This function returns the metadata for the shared library.

\item {\em int InitializeEngineLib(DynamicEngineData *)}

This function initializes the data structure for use by the engine.
\end{itemize}

The sample code provided with Snort predefines those functions 
and defines the following APIs to be used by a dynamic rules
library.

\begin{itemize}
\item {\em int RegisterRules(Rule **)}

This is the function to iterate through each rule in the list,
initialize it to setup content searches, PCRE evalution data,
and register flowbits.

\item {\em int DumpRules(char *,Rule **)}

This is the function to iterate through each rule in the list and
write a rule-stop to be used by snort to control the action of the
rule (alert, log, drop, etc).

\item {\em int ruleMatch(void *p, Rule *rule)}

This is the function to evaluate a rule if the rule does not have
its own Rule Evaluation Function.  This uses the individual
functions outlined below for each of the rule options and handles
repetitive content issues.  

Each of the functions below returns RULE\_MATCH if the option
matches based on the current criteria (cursor position, etc).

\begin{itemize}

\item {\em int contentMatch(void *p, ContentInfo* content, u\_int8\_t **cursor)}

This function evaluates a single content for a given packet, checking
for the existence of that content as delimited by ContentInfo and
cursor.  Cursor position is updated and returned in *cursor.

With a text rule, the with option corresponds to depth, and the
distance option corresponds to offset.

\item {\em int checkFlow(void *p, FlowFlags *flowflags)}

This function evaluates the flow for a given packet.

\item {\em int extractValue(void *p, ByteExtract *byteExtract, u\_int8\_t *cursor)}

This function extracts the bytes from a given packet, as specified
by ByteExtract and delimited by cursor.  Value extracted is stored
in ByteExtract memoryLocation paraneter.

\item {\em int processFlowbits(void *p, FlowBitsInfo *flowbits)}

This function evaluates the flowbits for a given packet, as specified
by FlowBitsInfo.  It will interact with flowbits used by text-based
rules.

\item {\em int setCursor(void *p, CursorInfo *cursorInfo, u\_int8\_t **cursor)}

This function adjusts the cursor as delimited by CursorInfo.
New cursor position is returned in *cursor.  It handles bounds
checking for the specified buffer and returns RULE\_NOMATCH if
the cursor is moved out of bounds.  

It is also used by contentMatch, byteJump, and pcreMatch to adjust
the cursor position after a successful match.

\item {\em int checkCursor(void *p, CursorInfo *cursorInfo, u\_int8\_t *cursor)}

This function validates that the cursor is within bounds of the
specified buffer.

\item {\em int checkValue(void *p, ByteData *byteData, u\_int32\_t value, u\_int8\_t *cursor)}

This function compares the {\em value} to the value stored in ByteData.

\item {\em int byteTest(void *p, ByteData *byteData, u\_int8\_t *cursor)}

This is a wrapper for extractValue() followed by checkValue().

\item {\em int byteJump(void *p, ByteData *byteData, u\_int8\_t **cursor)}

This is a wrapper for extractValue() followed by setCursor().

\item {\em int pcreMatch(void *p, PCREInfo *pcre, u\_int8\_t **cursor)}

This function evaluates a single pcre for a given packet, checking
for the existence of the expression as delimited by PCREInfo and
cursor.  Cursor position is updated and returned in *cursor.

\item {\em int detectAsn1(void *p, Asn1Context *asn1, u\_int8\_t *cursor)}

This function evaluates an ASN.1 check for a given packet, as
delimited by Asn1Context and cursor.

\item {\em int checkHdrOpt(void *p, HdrOptCheck *optData)}

This function evaluates the given packet's protocol headers,
as specified by HdrOptCheck.

\item {\em int loopEval(void *p, LoopInfo *loop, u\_int8\_t **cursor)}

This function iterates through the SubRule of LoopInfo, as
delimited by LoopInfo and cursor.  Cursor position is updated and
returned in *cursor.

\item {\em int preprocOptionEval(void *p, PreprocessorOption *preprocOpt, u\_int8\_t **cursor)}

This function evaluates the preprocessor defined option, as
spepcifed by PreprocessorOption.  Cursor position is updated and
returned in *cursor.

\item {\em void setTempCursor(u\_int8\_t **temp\_cursor, u\_int8\_t **cursor)}

This function is used to handled repetitive contents to save off
a cursor position temporarily to be reset at later point.

\item {\em void revertTempCursor(u\_int8\_t **temp\_cursor, u\_int8\_t **cursor)}

This function is used to revert to a previously saved temporary
cursor position.

\end{itemize}

\begin{note}
If you decide to write you own rule evaluation function, patterns
that occur more than once may result in false negatives.  Take
extra care to handle this situation and search for the matched pattern
again if subsequent rule options fail to match.  This should be done
for both content and PCRE options.
\end{note}
\end{itemize}

\subsection{Rules}

Each dynamic rules library must define the following functions.
Examples are defined in the file \texttt{sfnort\_dynamic\_detection\_lib.c}.
The metadata and setup function for the preprocessor should be defined
\texttt{sfsnort\_dynamic\_detection\_lib.h}.

\begin{itemize}
\item {\em int LibVersion(DynamicPluginMeta *)}

This function returns the metadata for the shared library.

\item {\em int EngineVersion(DynamicPluginMeta *)}

This function defines the version requirements for the corresponding
detection engine library.

\item {\em int DumpSkeletonRules()}

This functions writes out the rule-stubs for rules that are loaded.

\item {\em int InitializeDetection()}

This function registers each rule in the rules library.  It should
set up fast pattern-matcher content, register flowbits, etc.
\end{itemize}

The sample code provided with Snort predefines those functions 
and uses the following data within the dynamic rules library.

\begin{itemize}

\item {\em Rule *rules[]}

A NULL terminated list of Rule structures that this library defines.

\end{itemize}

\section{Examples}

This section provides a simple example of a dynamic preprocessor
and a dynamic rule.

\subsection{Preprocessor Example}

The following is an example of a simple preprocessor.  This preprocessor
always alerts on a Packet if the TCP port matches the one configured.

This assumes the the files {\em sf\_dynamic\_preproc\_lib.c} and
{\em sf\_dynamic\_preproc\_lib.h} are used.  

This is the metadata for this preprocessor, defined in
{\em sf\_preproc\_info.h}.

\begin{verbatim}
#define MAJOR_VERSION 1
#define MINOR_VERSION 0
#define BUILD_VERSION 0
#define PREPROC_NAME    "SF_Dynamic_Example_Preprocessor"

#define DYNAMIC_PREPROC_SETUP   ExampleSetup
extern void ExampleSetup();
\end{verbatim}

The remainder of the code is defined in {\em spp\_example.c} and is
compiled together with {\em sf\_dynamic\_preproc\_lib.c} into
lib\_sfdynamic\_preprocessor\_example.so.

Define the Setup function to register the initialization function.

\begin{verbatim}
#define GENERATOR_EXAMPLE 256
extern DynamicPreprocessorData _dpd;

void ExampleInit(unsigned char *);
void ExampleProcess(void *, void *);

void ExampleSetup()
{
    _dpd.registerPreproc("dynamic_example", ExampleInit);

    DEBUG_WRAP(_dpd.debugMsg(DEBUG_PLUGIN, "Preprocessor: Example is setup\n"););
}
\end{verbatim}

The initialization function to parse the keywords from \texttt{snort.conf}.

\begin{verbatim}
u_int16_t portToCheck;

void ExampleInit(unsigned char *args)
{
    char *arg;
    char *argEnd;
    unsigned long port;

    _dpd.logMsg("Example dynamic preprocessor configuration\n");

    arg = strtok(args, " \t\n\r");

    if(!strcasecmp("port", arg))
    {
        arg = strtok(NULL, "\t\n\r");
        if (!arg)
        {
            _dpd.fatalMsg("ExamplePreproc: Missing port\n");
        }
        
        port = strtoul(arg, &argEnd, 10);
        if (port < 0 || port > 65535)
        {
            _dpd.fatalMsg("ExamplePreproc: Invalid port %d\n", port);
        }
        portToCheck = port;
    
        _dpd.logMsg("    Port: %d\n", portToCheck);
    }
    else
    {
        _dpd.fatalMsg("ExamplePreproc: Invalid option %s\n", arg);
    }

    /* Register the preprocessor function, Transport layer, ID 10000 */
    _dpd.addPreproc(ExampleProcess, PRIORITY_TRANSPORT, 10000);

    DEBUG_WRAP(_dpd.debugMsg(DEBUG_PLUGIN, "Preprocessor: Example is initialized\n"););
}
\end{verbatim}

The function to process the packet and log an alert if the either port
matches.

\begin{verbatim}
#define SRC_PORT_MATCH  1
#define SRC_PORT_MATCH_STR "example_preprocessor: src port match"
#define DST_PORT_MATCH  2
#define DST_PORT_MATCH_STR "example_preprocessor: dest port match"
void ExampleProcess(void *pkt, void *context)
{
    SFSnortPacket *p = (SFSnortPacket *)pkt;
    if (!p->ip4_header || p->ip4_header->proto != IPPROTO_TCP || !p->tcp_header)
    {
        /* Not for me, return */
        return;
    }

    if (p->src_port == portToCheck)
    {
        /* Source port matched, log alert */
        _dpd.alertAdd(GENERATOR_EXAMPLE, SRC_PORT_MATCH,
                      1, 0, 3, SRC_PORT_MATCH_STR, 0);
        return;
    }

    if (p->dst_port == portToCheck)
    {
        /* Destination port matched, log alert */
        _dpd.alertAdd(GENERATOR_EXAMPLE, DST_PORT_MATCH,
                      1, 0, 3, DST_PORT_MATCH_STR, 0);
        return;
    }
}
\end{verbatim}

\subsection{Rules}

The following is an example of a simple rule, take from the current
rule set, SID 109.  It is implemented to work with the detection engine
provided with snort.

The snort rule in normal format:

\begin{verbatim}
alert tcp $HOME_NET 12345:12346 -> $EXTERNAL_NET any \
(msg:"BACKDOOR netbus active"; flow:from_server,established; \
content:"NetBus"; reference:arachnids,401; classtype:misc-activity; \
sid:109; rev:5;)
\end{verbatim}

This is the metadata for this rule library, defined in
{\em detection\_lib\_meta.h}.

\begin{verbatim}
/* Version for this rule library */
#define DETECTION_LIB_MAJOR_VERSION 1
#define DETECTION_LIB_MINOR_VERSION 0
#define DETECTION_LIB_BUILD_VERSION 1
#define DETECTION_LIB_NAME "Snort_Dynamic_Rule_Example"

/* Required version and name of the engine */
#define REQ_ENGINE_LIB_MAJOR_VERSION 1
#define REQ_ENGINE_LIB_MINOR_VERSION 0
#define REQ_ENGINE_LIB_NAME "SF_SNORT_DETECTION_ENGINE"

\end{verbatim}

The definition of each data structure for this rule is in 
{\em sid109.c}.

Declaration of the data structures.

\begin{itemize}

\item{Flow option}

Define the {\em FlowFlags} structure and its corresponding {\em RuleOption}.
Per the text version, flow is from\_server,established.

\begin{verbatim}
static FlowFlags sid109flow =
{
    FLOW_ESTABLISHED|FLOW_TO_CLIENT
};

static RuleOption sid109option1 =
{
    OPTION_TYPE_FLOWFLAGS,
    {
        &sid109flow
    }
};
\end{verbatim}

\item{Content Option}

Define the {\em ContentInfo} structure and its corresponding {\em RuleOption}.
Per the text version, content is "NetBus", no depth or offset, case sensitive,
and non-relative.  Search on the normalized buffer by default.  {\bf NOTE}:
This content will be used for the fast pattern matcher since it is the
longest content option for this rule and no contents have a flag of {\em
CONTENT\_FAST\_PATTERN}.

\begin{verbatim}
static ContentInfo sid109content =
{
    "NetBus",               /* pattern to search for */
    0,                      /* depth */
    0,                      /* offset */
    CONTENT_BUF_NORMALIZED, /* flags */
    NULL,                   /* holder for boyer/moore info */
    NULL,                   /* holder for byte representation of "NetBus" */
    0,                      /* holder for length of byte representation */
    0                       /* holder for increment length */
};

static RuleOption sid109option2 =
{
    OPTION_TYPE_CONTENT,
    {
        &sid109content
    }
};
\end{verbatim}

\item{Rule and Meta Data}

Define the references.

\begin{verbatim}
static RuleReference sid109ref_arachnids =
{
    "arachnids",    /* Type */
    "401"           /* value */
};

static RuleReference *sid109refs[] =
{
    &sid109ref_arachnids,
    NULL
};
\end{verbatim}

The list of rule options.  Rule options are evaluated in the order
specified.

\begin{verbatim}
RuleOption *sid109options[] =
{
    &sid109option1,
    &sid109option2,
    NULL
};
\end{verbatim}

The rule itself, with the protocl header, meta data (sid,
classification, message, etc).  

\begin{verbatim}
Rule sid109 =
{
    /* protocol header, akin to => tcp any any -> any any               */
    {
        IPPROTO_TCP,        /* proto */
        HOME_NET,           /* source IP     */
        "12345:12346",      /* source port(s) */
        0,                  /* Direction */
        EXTERNAL_NET,       /* destination IP     */
        ANY_PORT,           /* destination port   */
    },
    /* metadata */
    {
        3,                  /* genid -- use 3 to distinguish a C rule */
        109,                /* sigid */
        5,                  /* revision */
        "misc-activity",    /* classification */
        0,                  /* priority */
        "BACKDOOR netbus active",     /* message */
        sid109refs          /* ptr to references */
    },
    sid109options,          /* ptr to rule options */
    NULL,                   /* Use internal eval func */
    0,                      /* Holder, not yet initialized, used internally */
    0,                      /* Holder, option count, used internally */
    0,                      /* Holder, no alert, used internally for flowbits */
    NULL                    /* Holder, rule data, used internally */
\end{verbatim}

\item{The List of rules defined by this rules library}

The NULL terminated list of rules.  The InitializeDetection iterates through
each Rule in the list and initializes the content, flowbits, pcre, etc.

\begin{verbatim}
extern Rule sid109;
extern Rule sid637;

Rule *rules[] = 
{
    &sid109,
    &sid637,
    NULL
};
\end{verbatim}

\end{itemize}
\newpage
\chapter{Snort Development}

Currently, this chapter is here as a place holder. It will someday
contain references on how to create new detection plugins and
preprocessors.  End users don't really need to be reading this
section. This is intended to help developers get a basic understanding
of whats going on quickly.

If you are going to be helping out with Snort development, please
use the \textsc{head} branch of cvs. We've had problems in the past
of people submitting patches only to the stable branch (since they
are likely writing this stuff for their own IDS purposes). Bugfixes
are what goes into \textsc{stable}. Features go into \textsc{head}.

\section{Submitting Patches}
Patches to Snort should be sent to the \verb!snort-devel@lists.sourceforge.net!
mailing list.  Patches should done with the command \verb!diff -nu snort-orig snort-new!.

\section{Snort Data Flow}
First, traffic is acquired from the network link via libpcap. Packets
are passed through a series of decoder routines that first fill out
the packet structure for link level protocols then are further decoded
for things like TCP and UDP ports.

Packets are then sent through the registered set of preprocessors.
Each preprocessor checks to see if this packet is something it should
look at.

Packets are then sent through the detection engine. The detection
engine checks each packet against the various options listed in the
Snort rules files. Each of the keyword options is a plugin. This allows
this to be easily extensible.


\subsection{Preprocessors}

For example, a TCP analysis preprocessor could simply return if the
packet does not have a TCP header. It can do this by checking: 

\begin{verbatim}
if (p->tcph==null)
   return;
\end{verbatim}
Similarly, there are a lot of packet\_flags available that can be
used to mark a packet as ``reassembled'' or logged. Check out src/decode.h
for the list of pkt\_{*} constants.

\subsection{Detection Plugins}
Basically, look at an existing output plugin and copy it to a new item
and change a few things. Later, we'll document what these few things are.

\subsection{Output Plugins}
Generally, new output plugins should go into the barnyard project
rather than the Snort project. We are currently cleaning house on the
available output options.

\section{The Snort Team}

\begin{tabular}{p{3in} p{3in}}

\textbf{Creator and Lead Architect} &	 Marty Roesch\\
\\
\textbf{Lead Snort Developers} &	 Marc Norton\\
 & 					 Andrew Mullican\\
 & 					 Steve Sturges\\
\\
\textbf{Snort Rules Maintainer} & 	 Brian Caswell\\
\\
\textbf{Snort Rules Team} &		 Nigel Houghton\\
 		& 			Alex Kirk\\
		&			Judy Novak\\
		&			Matt Watchinski\\
\\
\textbf{Win32 Maintainer} &	 	Chris Reid\\
\\
\textbf{RPM Maintainers} &	 	JP Vossen\\
			&		Daniel Wittenberg\\
\\
\textbf{Inline Developers} &	 	Victor Julien\\
				&	Rob McMillen\\
				& 	William Metcalf\\
\\
\textbf{Major Contributors} & 	Daniel Roelker\\
		&		Andrew Baker\\
		&		Erek Adams\\
		&		Scott Campbell\\
		&		Roman D.\\
		&		Michael Davis\\
		&		Chris Green\\
		&		Jed Haile\\
        &	 Jeremy Hewlett\\
		&		Glenn Mansfield Keeni\\
		&		Chad Kreimendahl\\
		&		Jeff Nathan\\
		&		Andreas Ostling\\
		&		Dragos Ruiu\\
		&		Fyodor Yarochkin\\
		&		Phil Wood
\end{tabular}
\appendix

\begin{thebibliography}{99}
\bibitem{phracknmaparticle}http://packetstorm.securify.com/mag/phrack/phrack49/p49-06
\bibitem{nmaphomepage}http://www.nmap.org
\bibitem{cidrnotation}http://public.pacbell.net/dedicated/cidr.html
\bibitem{whitehatsurl}http://www.whitehats.com
\bibitem{snortdb}http://www.incident.org/snortdb
\bibitem{pcre}http://www.pcre.org
\end{thebibliography}

\end{document}
