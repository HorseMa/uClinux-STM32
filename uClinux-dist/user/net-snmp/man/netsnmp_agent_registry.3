.TH "Maintain a registry of MIB subtrees, together with related information regarding mibmodule, sessions, etc" 3 "24 Jan 2005" "net-snmp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Maintain a registry of MIB subtrees, together with related information regarding mibmodule, sessions, etc \- 
.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBlookup_cache_s\fP"
.br
.ti -1c
.RI "struct \fBlookup_cache_context_s\fP"
.br
.in -1c
.SS "Defines"

.in +1c
.ti -1c
.RI "#define \fBIN_SNMP_VARS_C\fP"
.br
.ti -1c
.RI "#define \fBSUBTREE_DEFAULT_CACHE_SIZE\fP   8"
.br
.ti -1c
.RI "#define \fBSUBTREE_MAX_CACHE_SIZE\fP   32"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef lookup_cache_s \fBlookup_cache\fP"
.br
.ti -1c
.RI "typedef lookup_cache_context_s \fBlookup_cache_context\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "NETSNMP_STATIC_INLINE void \fBinvalidate_lookup_cache\fP (const char *context)"
.br
.ti -1c
.RI "void \fBnetsnmp_set_lookup_cache_size\fP (int newsize)"
.br
.RI "\fIset the lookup cache size for optimized agent registration performance. \fP"
.ti -1c
.RI "int \fBnetsnmp_get_lookup_cache_size\fP (void)"
.br
.RI "\fIretrieves the current value of the lookup cache size \fP"
.ti -1c
.RI "void \fBnetsnmp_subtree_free\fP (netsnmp_subtree *a)"
.br
.ti -1c
.RI "netsnmp_subtree * \fBnetsnmp_subtree_deepcopy\fP (netsnmp_subtree *a)"
.br
.ti -1c
.RI "subtree_context_cache * \fBget_top_context_cache\fP (void)"
.br
.ti -1c
.RI "netsnmp_subtree * \fBnetsnmp_subtree_find_first\fP (const char *context_name)"
.br
.ti -1c
.RI "netsnmp_subtree * \fBadd_subtree\fP (netsnmp_subtree *new_tree, const char *context_name)"
.br
.ti -1c
.RI "netsnmp_subtree * \fBnetsnmp_subtree_replace_first\fP (netsnmp_subtree *new_tree, const char *context_name)"
.br
.ti -1c
.RI "int \fBnetsnmp_subtree_compare\fP (const netsnmp_subtree *ap, const netsnmp_subtree *bp)"
.br
.ti -1c
.RI "void \fBnetsnmp_subtree_join\fP (netsnmp_subtree *root)"
.br
.ti -1c
.RI "netsnmp_subtree * \fBnetsnmp_subtree_split\fP (netsnmp_subtree *current, oid name[], int name_len)"
.br
.ti -1c
.RI "int \fBnetsnmp_subtree_load\fP (netsnmp_subtree *new_sub, const char *context_name)"
.br
.ti -1c
.RI "int \fBnetsnmp_register_mib\fP (const char *moduleName, struct variable *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen, int priority, int range_subid, oid range_ubound, \fBnetsnmp_session\fP *ss, const char *context, int timeout, int flags, \fBnetsnmp_handler_registration\fP *reginfo, int perform_callback)"
.br
.ti -1c
.RI "void \fBregister_mib_reattach\fP (void)"
.br
.ti -1c
.RI "void \fBregister_mib_detach\fP (void)"
.br
.ti -1c
.RI "int \fBregister_mib_context\fP (const char *moduleName, struct variable *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen, int priority, int range_subid, oid range_ubound, \fBnetsnmp_session\fP *ss, const char *context, int timeout, int flags)"
.br
.ti -1c
.RI "int \fBregister_mib_range\fP (const char *moduleName, struct variable *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen, int priority, int range_subid, oid range_ubound, \fBnetsnmp_session\fP *ss)"
.br
.ti -1c
.RI "int \fBregister_mib_priority\fP (const char *moduleName, struct variable *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen, int priority)"
.br
.ti -1c
.RI "int \fBregister_mib\fP (const char *moduleName, struct variable *var, size_t varsize, size_t numvars, oid *mibloc, size_t mibloclen)"
.br
.ti -1c
.RI "void \fBnetsnmp_subtree_unload\fP (netsnmp_subtree *sub, netsnmp_subtree *prev, const char *context)"
.br
.ti -1c
.RI "int \fBunregister_mib_context\fP (oid *name, size_t len, int priority, int range_subid, oid range_ubound, const char *context)"
.br
.RI "\fIUnregisters an OID that has an associated context name value. \fP"
.ti -1c
.RI "int \fBnetsnmp_unregister_mib_table_row\fP (oid *name, size_t len, int priority, int var_subid, oid range_ubound, const char *context)"
.br
.ti -1c
.RI "int \fBunregister_mib_range\fP (oid *name, size_t len, int priority, int range_subid, oid range_ubound)"
.br
.ti -1c
.RI "int \fBunregister_mib_priority\fP (oid *name, size_t len, int priority)"
.br
.ti -1c
.RI "int \fBunregister_mib\fP (oid *name, size_t len)"
.br
.ti -1c
.RI "void \fBunregister_mibs_by_session\fP (\fBnetsnmp_session\fP *ss)"
.br
.ti -1c
.RI "int \fBin_a_view\fP (oid *name, size_t *namelen, \fBnetsnmp_pdu\fP *pdu, int type)"
.br
.ti -1c
.RI "int \fBcheck_access\fP (\fBnetsnmp_pdu\fP *pdu)"
.br
.ti -1c
.RI "int \fBnetsnmp_acm_check_subtree\fP (\fBnetsnmp_pdu\fP *pdu, oid *name, size_t namelen)"
.br
.RI "\fIchecks to see if everything within a given subtree is either: in view, not in view, or possibly both. \fP"
.ti -1c
.RI "NETSNMP_STATIC_INLINE lookup_cache_context * \fBget_context_lookup_cache\fP (const char *context)"
.br
.ti -1c
.RI "NETSNMP_STATIC_INLINE void \fBlookup_cache_add\fP (const char *context, netsnmp_subtree *next, netsnmp_subtree *previous)"
.br
.ti -1c
.RI "NETSNMP_STATIC_INLINE void \fBlookup_cache_replace\fP (lookup_cache *ptr, netsnmp_subtree *next, netsnmp_subtree *previous)"
.br
.ti -1c
.RI "NETSNMP_STATIC_INLINE lookup_cache * \fBlookup_cache_find\fP (const char *context, oid *name, size_t name_len, int *retcmp)"
.br
.ti -1c
.RI "netsnmp_subtree * \fBnetsnmp_subtree_find_prev\fP (oid *name, size_t len, netsnmp_subtree *subtree, const char *context_name)"
.br
.ti -1c
.RI "netsnmp_subtree * \fBnetsnmp_subtree_find_next\fP (oid *name, size_t len, netsnmp_subtree *subtree, const char *context_name)"
.br
.ti -1c
.RI "netsnmp_subtree * \fBnetsnmp_subtree_find\fP (oid *name, size_t len, netsnmp_subtree *subtree, const char *context_name)"
.br
.ti -1c
.RI "\fBnetsnmp_session\fP * \fBget_session_for_oid\fP (oid *name, size_t len, const char *context_name)"
.br
.ti -1c
.RI "void \fBsetup_tree\fP (void)"
.br
.ti -1c
.RI "int \fBremove_tree_entry\fP (oid *name, size_t len)"
.br
.ti -1c
.RI "void \fBshutdown_tree\fP (void)"
.br
.ti -1c
.RI "void \fBclear_subtree\fP (netsnmp_subtree *sub)"
.br
.ti -1c
.RI "void \fBclear_lookup_cache\fP (void)"
.br
.ti -1c
.RI "void \fBclear_context\fP (void)"
.br
.ti -1c
.RI "void \fBdump_idx_registry\fP (void)"
.br
.ti -1c
.RI "void \fBdump_registry\fP (void)"
.br
.ti -1c
.RI "int \fBregister_readfd\fP (int fd, void(*func)(int, void *), void *data)"
.br
.ti -1c
.RI "int \fBregister_writefd\fP (int fd, void(*func)(int, void *), void *data)"
.br
.ti -1c
.RI "int \fBregister_exceptfd\fP (int fd, void(*func)(int, void *), void *data)"
.br
.ti -1c
.RI "int \fBunregister_readfd\fP (int fd)"
.br
.ti -1c
.RI "int \fBunregister_writefd\fP (int fd)"
.br
.ti -1c
.RI "int \fBunregister_exceptfd\fP (int fd)"
.br
.ti -1c
.RI "RETSIGTYPE \fBagent_SIGCHLD_handler\fP (int sig)"
.br
.ti -1c
.RI "int \fBregister_signal\fP (int sig, void(*func)(int))"
.br
.ti -1c
.RI "int \fBunregister_signal\fP (int sig)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "subtree_context_cache * \fBcontext_subtrees\fP = NULL"
.br
.ti -1c
.RI "int \fBlookup_cache_size\fP = 0"
.br
.ti -1c
.RI "int \fBexternal_readfd\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "int \fBexternal_readfdlen\fP = 0"
.br
.ti -1c
.RI "int \fBexternal_writefd\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "int \fBexternal_writefdlen\fP = 0"
.br
.ti -1c
.RI "int \fBexternal_exceptfd\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "int \fBexternal_exceptfdlen\fP = 0"
.br
.ti -1c
.RI "void(* \fBexternal_readfdfunc\fP [NUM_EXTERNAL_FDS])(int, void *)"
.br
.ti -1c
.RI "void(* \fBexternal_writefdfunc\fP [NUM_EXTERNAL_FDS])(int, void *)"
.br
.ti -1c
.RI "void(* \fBexternal_exceptfdfunc\fP [NUM_EXTERNAL_FDS])(int, void *)"
.br
.ti -1c
.RI "void * \fBexternal_readfd_data\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "void * \fBexternal_writefd_data\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "void * \fBexternal_exceptfd_data\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "int \fBexternal_signal_scheduled\fP [NUM_EXTERNAL_SIGS]"
.br
.ti -1c
.RI "void(* \fBexternal_signal_handler\fP [NUM_EXTERNAL_SIGS])(int)"
.br
.ti -1c
.RI "int \fBexternal_readfd\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "int \fBexternal_readfdlen\fP"
.br
.ti -1c
.RI "int \fBexternal_writefd\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "int \fBexternal_writefdlen\fP"
.br
.ti -1c
.RI "int \fBexternal_exceptfd\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "int \fBexternal_exceptfdlen\fP"
.br
.ti -1c
.RI "void(* \fBexternal_readfdfunc\fP [NUM_EXTERNAL_FDS])(int, void *)"
.br
.ti -1c
.RI "void(* \fBexternal_writefdfunc\fP [NUM_EXTERNAL_FDS])(int, void *)"
.br
.ti -1c
.RI "void(* \fBexternal_exceptfdfunc\fP [NUM_EXTERNAL_FDS])(int, void *)"
.br
.ti -1c
.RI "void * \fBexternal_readfd_data\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "void * \fBexternal_writefd_data\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "void * \fBexternal_exceptfd_data\fP [NUM_EXTERNAL_FDS]"
.br
.ti -1c
.RI "int \fBexternal_signal_scheduled\fP [NUM_EXTERNAL_SIGS]"
.br
.ti -1c
.RI "void(* \fBexternal_signal_handler\fP [NUM_EXTERNAL_SIGS])(int)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "int netsnmp_acm_check_subtree (\fBnetsnmp_pdu\fP * pdu, oid * name, size_t namelen)"
.PP
checks to see if everything within a given subtree is either: in view, not in view, or possibly both. If the entire subtree is not-in-view we can use this information to skip calling the sub-handlers entirely. 
.PP
\fBReturns:\fP
.RS 4
0 if entire subtree is accessible, 5 if not and 7 if portions are both. 1 on error (illegal pdu version). 
.RE
.PP
Definition at line 1249 of file agent_registry.c.
.PP
References snmp_pdu::flags, snmp_call_callbacks(), and snmp_pdu::version.
.PP
Referenced by netsnmp_add_varbind_to_cache().
.SS "int netsnmp_get_lookup_cache_size (void)"
.PP
retrieves the current value of the lookup cache size \fBReturns:\fP
.RS 4
the current lookup cache size 
.RE
.PP
Definition at line 1322 of file agent_registry.c.
.PP
Referenced by unregister_mib_context().
.SS "void netsnmp_set_lookup_cache_size (int newsize)"
.PP
set the lookup cache size for optimized agent registration performance. \fBParameters:\fP
.RS 4
\fInewsize\fP set to the maximum size of a cache for a given context. Set to 0 to completely disable caching, or to -1 to set to the default cache size (8), or to a number of your chosing. The rough guide is that it should be equal to the maximum number of simultanious managers you expect to talk to the agent (M) times 80% (or so, he says randomly) the average number (N) of varbinds you expect to receive in a given request for a manager. ie, M times N. Bigger does NOT necessarily mean better. Certainly 16 should be an upper limit. 32 is the hard coded limit. 
.RE
.PP
Definition at line 1309 of file agent_registry.c.
.PP
References netsnmp_set_lookup_cache_size().
.PP
Referenced by netsnmp_set_lookup_cache_size(), and unregister_mib_context().
.SS "int unregister_mib_context (oid * name, size_t len, int priority, int range_subid, oid range_ubound, const char * context)"
.PP
Unregisters an OID that has an associated context name value. Typically used when a module has multiple contexts defined. The parameters priority, range_subid, and range_ubound should be used in conjunction with agentx, see RFC 2741, otherwise these values should always be 0.
.PP
\fBParameters:\fP
.RS 4
\fIname\fP the specific OID to unregister if it conatins the associated context.
.br
\fIlen\fP the length of the OID, use OID_LENGTH macro.
.br
\fIpriority\fP a value between 1 and 255, used to achieve a desired configuration when different sessions register identical or overlapping regions. Subagents with no particular knowledge of priority should register with the default value of 127.
.br
\fIrange_subid\fP permits specifying a range in place of one of a subtree sub-identifiers. When this value is zero, no range is being specified.
.br
\fIrange_ubound\fP the upper bound of a sub-identifier's range. This field is present only if range_subid is not 0.
.br
\fIcontext\fP a context name that has been created
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
Definition at line 921 of file agent_registry.c.
.PP
References netsnmp_get_lookup_cache_size(), netsnmp_oid_equals(), netsnmp_set_lookup_cache_size(), and snmp_call_callbacks().
.PP
Referenced by netsnmp_unregister_handler().
